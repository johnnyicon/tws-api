URL: https://www.interactivebrokers.com/campus/ibkr-api-page/twsapi-doc/
Scraped on: 2025-07-31 13:57:38
================================================================================


--- TWS API Documentation ---


--- IntroductionCopy Location ---


--- Notes & LimitationsCopy Location ---


--- RequirementsCopy Location ---


--- LimitationsCopy Location ---


--- C# for MacOSCopy Location ---


--- Paper TradingCopy Location ---


--- Download TWS or IB GatewayCopy Location ---


--- TWS Online or Offline Version?Copy Location ---


--- TWS SettingsCopy Location ---


--- TWS Configuration For API UseCopy Location ---


--- Best Practice: Configure TWS / IB GatewayCopy Location ---


--- "Never Lock Trader Workstation" SettingCopy Location ---


--- Memory AllocationCopy Location ---


--- Daily & Weekly ReauthenticationCopy Location ---


--- Daily Reauthentication ---


--- Weekly Reauthentication ---


--- Order PrecautionsCopy Location ---


--- Connected IB Server Location in TWSCopy Location ---


--- SMART AlgorithmCopy Location ---


--- Allocation Setup (For Financial Advisors)Copy Location ---


--- Intelligent Order ResubmissionCopy Location ---


--- Disconnect on Invalid FormatCopy Location ---


--- Download the TWS APICopy Location ---


--- Install the TWS API on WindowsCopy Location ---


--- Windows: ---


--- Install the TWS API on MacOs / LinuxCopy Location ---


--- Unix/ Linux: ---


--- MacOS: ---


--- TWS API File Location & ToolsCopy Location ---


--- TWS API Folder Files Explanation: ---


--- TWSAPI Basics TutorialCopy Location ---


--- Third Party API PlatformsCopy Location ---


--- Non-Standard TWS API Languages and PackagesCopy Location ---


--- ib_insync and ib_asyncCopy Location ---


--- Unique ConfigurationsCopy Location ---


--- Implementing the Intel Decimal Library for MacOS and LinuxCopy Location ---


--- Updating The Python InterpreterCopy Location ---


--- 1. Open Command Prompt or TerminalCopy Location ---


--- 2. Navigate to Python SourceCopy Location ---


--- 3. Run The setup.py FileCopy Location ---


--- 4. Confirm UpdatesCopy Location ---


--- 5. Confirm your installationCopy Location ---


--- Protobuf UserWarning messagesCopy Location ---


--- Implementing Visual Basic .NETCopy Location ---


--- Troubleshooting & SupportCopy Location ---


--- Log FilesCopy Location ---


--- API LogsCopy Location ---


--- How To Enable Debug LoggingCopy Location ---


--- Location of Interactive Brokers LogsCopy Location ---


--- How To Delete LogsCopy Location ---


--- Uploading LogsCopy Location ---


--- Exporting LogsCopy Location ---


--- Reading Exported LogsCopy Location ---


--- Unset ValuesCopy Location ---


--- ArchitectureCopy Location ---


--- The Trader WorkstationCopy Location ---


--- The IB GatewayCopy Location ---


--- Pacing LimitationsCopy Location ---


--- Pacing BehaviorCopy Location ---


--- ConnectivityCopy Location ---


--- Establishing an API connectionCopy Location ---


--- Verify API ConnectionCopy Location ---


--- The EReader ThreadCopy Location ---


--- C++, C#, and Java ImplementationsCopy Location ---


--- Python ImplementationCopy Location ---


--- Remote TWS API Connections with Trader WorkstationCopy Location ---


--- Accepting an API connection from TWSCopy Location ---


--- Logging into multiple applicationsCopy Location ---


--- Broken API socket connectionCopy Location ---


--- Account & Portfolio DataCopy Location ---


--- Account SummaryCopy Location ---


--- Requesting Account SummaryCopy Location ---


--- EClient.reqAccountSummary( ---


--- Account Summary TagsCopy Location ---


--- Receiving Account SummaryCopy Location ---


--- EWrapper.accountSummary( ---


--- EWrapper.accountSummaryEnd( ---


--- Cancel Account SummaryCopy Location ---


--- EClient.cancelAccountSummary( ---


--- Account UpdatesCopy Location ---


--- Requesting Account UpdatesCopy Location ---


--- EClient.reqAccountUpdates( ---


--- Receiving Account UpdatesCopy Location ---


--- EWrapper.updateAccountValue( ---


--- EWrapper.updatePortfolio( ---


--- EWrapper.updateAccountTime( ---


--- EWrapper.accountDownloadEnd( ---


--- Account Value KeysCopy Location ---


--- Cancel Account UpdatesCopy Location ---


--- EClient.reqAccountUpdates( ---


--- Account Update by ModelCopy Location ---


--- Requesting Account Update by ModelCopy Location ---


--- EClient.reqAccountUpdatesMulti( ---


--- Receiving Account Updates by ModelCopy Location ---


--- EWrapper.accountUpdateMulti( ---


--- EWrapper.accountUpdateMultiEnd( ---


--- Cancel Account Updates by ModelCopy Location ---


--- EClient.reqAccountUpdatesMulti ( ---


--- Family CodesCopy Location ---


--- Request Family CodesCopy Location ---


--- EClient.reqFamilyCodes() ---


--- Receive Family CodesCopy Location ---


--- EWrapper.familyCodes( ---


--- Managed AccountsCopy Location ---


--- Request Managed AccountsCopy Location ---


--- EClient.reqManagedAccts() ---


--- Receive Managed AccountsCopy Location ---


--- EWrapper.managedAccounts ( ---


--- PositionsCopy Location ---


--- Request PositionsCopy Location ---


--- EClient.reqPositions() ---


--- Receive PositionsCopy Location ---


--- EWrapper.position( ---


--- Ewrapper.positionEnd() ---


--- Cancel Positions RequestCopy Location ---


--- EClient.cancelPositions() ---


--- Positions By ModelCopy Location ---


--- Request Positions By ModelCopy Location ---


--- EClient.reqPositionsMulti( ---


--- Receive Positions By ModelCopy Location ---


--- EWrapper.positionMulti( ---


--- EWrapper.positionMultiEnd( ---


--- Cancel Positions By ModelCopy Location ---


--- EClient.cancelPositionsMulti ( ---


--- Profit & Loss (PnL)Copy Location ---


--- Request P&L for individual positionsCopy Location ---


--- EClient.reqPnLSingle ( ---


--- Receive P&L for individual positionsCopy Location ---


--- EWrapper.pnlSingle ( ---


--- Cancel P&L request for individual positionsCopy Location ---


--- EClient.cancelPnLSingle ( ---


--- Request P&L for accountsCopy Location ---


--- EClient.reqPnL ( ---


--- Receive P&L for accountsCopy Location ---


--- EWrapper.pnl ( ---


--- Cancel P&L subscription requests for accountsCopy Location ---


--- EClient.cancelPnL ( ---


--- White Branding User InfoCopy Location ---


--- Requesting White Branding InfoCopy Location ---


--- EClient.reqUserInfo( ---


--- Receiving White Branding InfoCopy Location ---


--- EWrapper.userInfo ( ---


--- BulletinsCopy Location ---


--- Request IB BulletinsCopy Location ---


--- EClient.reqNewsBulletins ( ---


--- Receive IB BulletinsCopy Location ---


--- EWrapper.updateNewsBulletin ( ---


--- Cancel Bulletin RequestCopy Location ---


--- EClient.cancelNewsBulletin () ---


--- Contracts (Financial Instruments)Copy Location ---


--- The Contract ObjectCopy Location ---


--- Contract() ---


--- Finding Contract Details in Trader WorkstationCopy Location ---


--- Contract DetailsCopy Location ---


--- Request Contract DetailsCopy Location ---


--- EClient.reqContractDetails ( ---


--- Receive Contract DetailsCopy Location ---


--- EWrapper.contractDetails ( ---


--- EWrapper.contractDetailsEnd ( ---


--- Receive Bond DetailsCopy Location ---


--- EWrapper.bondContractDetails ( ---


--- Option ChainsCopy Location ---


--- Request Option ChainsCopy Location ---


--- EClient.reqSecDefOptParams ( ---


--- Receive Option ChainsCopy Location ---


--- EWrapper.securityDefinitionOptionParameter ( ---


--- Stock Symbol SearchCopy Location ---


--- Request Stock Contract SearchCopy Location ---


--- EClient.reqMatchingSymbols ( ---


--- Receive Searched Stock ContractCopy Location ---


--- EWrapper.symbolSamples ( ---


--- Event TradingCopy Location ---


--- IntroductionCopy Location ---


--- ForecastEx Forecast ContractsCopy Location ---


--- CME Event ContractsCopy Location ---


--- Contract Definition & DiscoveryCopy Location ---


--- ForecastEx Contract ExampleCopy Location ---


--- Market DataCopy Location ---


--- Order SubmissionCopy Location ---


--- Order ExampleCopy Location ---


--- Other FunctionalityCopy Location ---


--- Error HandlingCopy Location ---


--- Understanding Message CodesCopy Location ---


--- System Message CodesCopy Location ---


--- Error CodesCopy Location ---


--- Receiving Error MessagesCopy Location ---


--- EWrapper.error( ---


--- Common Error ResolutionCopy Location ---


--- Market data farm connection is OKCopy Location ---


--- Requested market data requires additional subscription for API. See link in 'Market Data Connections' dialog for more details.Delayed market data is available.Copy Location ---


--- Financial AdvisorsCopy Location ---


--- Request FA Groups and ProfilesCopy Location ---


--- EClient.requestFA ( ---


--- requestFA FA Data Types ---


--- Receiving FA Groups and ProfilesCopy Location ---


--- EWrapper.receiveFA ( ---


--- Replace FA AllocationsCopy Location ---


--- EClient.replaceFA ( ---


--- replaceFA FA Data Types ---


--- EWrapper.replaceFAEnd ( ---


--- Allocation Methods and GroupsCopy Location ---


--- IB-computed allocation methods ---


--- User-specified allocation methods ---


--- Allocation Method XML FormatCopy Location ---


--- Available EquityCopy Location ---


--- Contracts Or SharesCopy Location ---


--- Equal QuantityCopy Location ---


--- MonetaryAmountCopy Location ---


--- Net Liquidation ValueCopy Location ---


--- PercentagesCopy Location ---


--- RatiosCopy Location ---


--- Model Portfolios and the APICopy Location ---


--- Unification of Groups and ProfilesCopy Location ---


--- Order PlacementCopy Location ---


--- Market Data: DelayedCopy Location ---


--- Market Data Type BehaviorCopy Location ---


--- Request Market Data TypeCopy Location ---


--- EClient.reqMarketDataType ( ---


--- Receive Market Data TypeCopy Location ---


--- EWrapper.marketDataType ( ---


--- Market Data: HistoricalCopy Location ---


--- Historical Data LimitationsCopy Location ---


--- Historical Data FilteringCopy Location ---


--- Historical Volume ScalingCopy Location ---


--- Pacing Violations for Small Bars (30 secs or less)Copy Location ---


--- Unavailable Historical DataCopy Location ---


--- Finding the Earliest Available Data PointCopy Location ---


--- Requesting the Earliest Data PointCopy Location ---


--- EClient.reqHeadTimestamp ( ---


--- Receiving the Earliest Data PointCopy Location ---


--- EWrapper.headTimestamp ( ---


--- Cancelling Timestamp RequestsCopy Location ---


--- EWrapper.cancelHistogramData ( ---


--- Historical BarsCopy Location ---


--- Requesting Historical BarsCopy Location ---


--- EClient.reqHistoricalData( ---


--- DurationCopy Location ---


--- Valid Duration String Units: ---


--- Historical Bar SizesCopy Location ---


--- Valid Bar Sizes: ---


--- Step SizesCopy Location ---


--- Max Duration Per Bar SizeCopy Location ---


--- Format Date ReceivedCopy Location ---


--- Keep Up To DateCopy Location ---


--- Receiving Historical BarsCopy Location ---


--- EWrapper.historicalData ( ---


--- Default Return Format ---


--- EWrapper.historicalSchedule ( ---


--- EWrapper.historicalDataUpdate ( ---


--- EWrapper.historicalDataEnd ( ---


--- Historical Bar whatToShowCopy Location ---


--- AGGTRADESCopy Location ---


--- ASKCopy Location ---


--- BIDCopy Location ---


--- BID_ASKCopy Location ---


--- FEE_RATECopy Location ---


--- HISTORICAL_VOLATILITYCopy Location ---


--- MIDPOINTCopy Location ---


--- OPTION_IMPLIED_VOLATILITYCopy Location ---


--- SCHEDULECopy Location ---


--- TRADESCopy Location ---


--- YIELD_ASKCopy Location ---


--- YIELD_BIDCopy Location ---


--- YIELD_BID_ASKCopy Location ---


--- YIELD_LASTCopy Location ---


--- Histogram DataCopy Location ---


--- Requesting Histogram DataCopy Location ---


--- EClient.reqHistogramData ( ---


--- Receiving Histogram DataCopy Location ---


--- EWrapper.histogramData ( ---


--- Cancelling Histogram DataCopy Location ---


--- EClient.cancelHistogramData ( ---


--- Historical Time & SalesCopy Location ---


--- Requesting Time and Sales dataCopy Location ---


--- EClient.reqHistoricalTicks ( ---


--- Receiving Time and Sales dataCopy Location ---


--- EWrapper.historicalTicks ( ---


--- EWrapper.historicalTicksBidAsk ( ---


--- EWrapper.historicalTicksLast ( ---


--- Historical Halted and Unhalted ticksCopy Location ---


--- Historical Date FormattingCopy Location ---


--- Operator Time ZoneCopy Location ---


--- Exchange Time ZoneCopy Location ---


--- Coordinated Universal Time (UTC)Copy Location ---


--- Modifying Returned DateCopy Location ---


--- Market Data: LiveCopy Location ---


--- Live Data LimitationsCopy Location ---


--- 5 Second BarsCopy Location ---


--- Request Real Time BarsCopy Location ---


--- EClient.reqRealTimeBars ( ---


--- Receive Real Time BarsCopy Location ---


--- EWrapper.realtimeBar ( ---


--- Cancel Real Time BarsCopy Location ---


--- EClient.cancelRealTimeBars ( ---


--- Component ExchangesCopy Location ---


--- Request Component ExchangesCopy Location ---


--- EClient.reqSmartComponents ( ---


--- Receive Component ExchangesCopy Location ---


--- EWrapper.smartComponents ( ---


--- Market Depth ExchangesCopy Location ---


--- Requesting Market Depth ExchangesCopy Location ---


--- EClient.reqMktDepthExchanges () ---


--- Receive Market Depth ExchangesCopy Location ---


--- EWrapper.mktDepthExchanges ( ---


--- Market Depth (L2)Copy Location ---


--- Request Market DepthCopy Location ---


--- EClient.reqMarketDepth ( ---


--- Receive Market DepthCopy Location ---


--- EWrapper.updateMktDepth ( ---


--- EWrapper.updateMktDepthL2 ( ---


--- Cancel Market DepthCopy Location ---


--- EClient.cancelMarketDepth ( ---


--- Option GreeksCopy Location ---


--- Request Options GreeksCopy Location ---


--- EClient.reqMktData ( ---


--- Calculating option pricesCopy Location ---


--- EClient.calculateOptionPrice ( ---


--- Calculating historical volatilityCopy Location ---


--- EClient.calculateImpliedVolatility ( ---


--- Receiving Options DataCopy Location ---


--- EWrapper.tickOptionComputation ( ---


--- Top of Book (L1)Copy Location ---


--- Request Watchlist DataCopy Location ---


--- EClient.reqMktData ( ---


--- Market Data Update FrequencyCopy Location ---


--- Generic Tick TypesCopy Location ---


--- Streaming Data SnapshotsCopy Location ---


--- EWrapper.tickSnapshotEnd ( ---


--- Regulatory SnapshotsCopy Location ---


--- Receive Live DataCopy Location ---


--- EWrapper.tickGeneric ( ---


--- EWrapper.tickPrice ( ---


--- EWrapper.tickSize ( ---


--- EWrapper.tickString ( ---


--- Exchange Component MappingCopy Location ---


--- EWrapper.tickReqParams ( ---


--- Re-Routing CFDsCopy Location ---


--- EWrapper.rerouteMktDataReq ( ---


--- EWrapper.rerouteMktDepthReq ( ---


--- Cancel Watchlist DataCopy Location ---


--- EClient.cancelMktData( ---


--- Available Tick TypesCopy Location ---


--- HaltedCopy Location ---


--- ShortableCopy Location ---


--- Volume DataCopy Location ---


--- RT VolumeCopy Location ---


--- IB DividendsCopy Location ---


--- Tick By Tick DataCopy Location ---


--- Request Tick By Tick DataCopy Location ---


--- EClient.reqTickByTickData ( ---


--- Receive Tick By Tick DataCopy Location ---


--- EWrapper.tickByTickAllLast ( ---


--- EWrapper.tickByTickBidAsk ( ---


--- EWrapper.tickByTickMidPoint ( ---


--- Cancel Tick By Tick DataCopy Location ---


--- EClient.cancelTickByTickData ( ---


--- Halted and Unhalted ticksCopy Location ---


--- Market ScannerCopy Location ---


--- Market Scanner ParametersCopy Location ---


--- Request Market Scanner ParametersCopy Location ---


--- EClient.reqScannerParameters () ---


--- Receive Market Scanner ParametersCopy Location ---


--- EWrapper.scannerParameters ( ---


--- Market Scanner SubscriptionCopy Location ---


--- ScannerSubscription() ---


--- Request Market Scanner SubscriptionCopy Location ---


--- EClient.reqScannerSubscription ( ---


--- Receive Market Scanner SubscriptionCopy Location ---


--- EWrapper.scannerData ( ---


--- Cancel Market Scanner SubscriptionCopy Location ---


--- EClient.cancelScannerSubscription ( ---


--- NewsCopy Location ---


--- News ProvidersCopy Location ---


--- Request News ProvidersCopy Location ---


--- EClient.reqNewsProviders() ---


--- Receive News ProvidersCopy Location ---


--- EWrapper.newsProviders ( ---


--- Live News HeadlinesCopy Location ---


--- Request Contract Specific NewsCopy Location ---


--- EClient.reqMktData ( ---


--- Request BroadTape NewsCopy Location ---


--- BroadTape News Contracts ---


--- Example news contract ---


--- Example news contract ---


--- Example news contract ---


--- Example news contract ---


--- Example news contract ---


--- EClient.reqMktData ( ---


--- Receive Live News HeadlinesCopy Location ---


--- EWrapper.tickNews ( ---


--- Historical News HeadlinesCopy Location ---


--- Requesting Historical NewsCopy Location ---


--- EClient.reqHistoricalNews ( ---


--- Receive Historical NewsCopy Location ---


--- EWrapper.historicalNews ( ---


--- EWrapper.historicalNewsEnd ( ---


--- News ArticlesCopy Location ---


--- Request News ArticlesCopy Location ---


--- EClient.reqNewsArticle ( ---


--- Receive News ArticlesCopy Location ---


--- EWrapper.newsArticle ( ---


--- Next Valid IDCopy Location ---


--- Request Next Valid IDCopy Location ---


--- EClient.reqIds ( ---


--- Receive Next Valid IDCopy Location ---


--- EWrapper.nextValidId ( ---


--- Reset Order ID SequenceCopy Location ---


--- Order ManagementCopy Location ---


--- ClientId 0 and the Master Client IDCopy Location ---


--- Commission And Fees ReportCopy Location ---


--- EWrapper.commissionReport ( ---


--- Execution DetailsCopy Location ---


--- ExecID BehaviorCopy Location ---


--- The Execution ObjectCopy Location ---


--- Execution() ---


--- Request Execution DetailsCopy Location ---


--- EClient.reqExecutions ( ---


--- Receive Execution DetailsCopy Location ---


--- EWrapper.execDetails ( ---


--- EWrapper.execDetailsEnd ( ---


--- Open OrdersCopy Location ---


--- EWrapper.openOrder ( ---


--- EWrapper.openOrderEnd () ---


--- Order StatusCopy Location ---


--- EWrapper.orderStatus ( ---


--- Understanding Order Status MessageCopy Location ---


--- Requesting Currently Active OrdersCopy Location ---


--- API client's ordersCopy Location ---


--- EClient.reqOpenOrders () ---


--- All submitted ordersCopy Location ---


--- EClient.reqAllOpenOrders () ---


--- Manually Submitted TWS OrdersCopy Location ---


--- EClient.reqAutoOpenOrders ( ---


--- Order Binding NotificationCopy Location ---


--- EWrapper.orderBound ( ---


--- Retrieving Completed OrdersCopy Location ---


--- Requesting Completed OrdersCopy Location ---


--- EClient.reqCompletedOrders( ---


--- Receiving Completed OrdersCopy Location ---


--- EWrapper.completedOrders( ---


--- OrdersCopy Location ---


--- The Order ObjectCopy Location ---


--- Order() ---


--- Cancelling an OrderCopy Location ---


--- Cancel Individual OrderCopy Location ---


--- EClient.cancelOrder ( ---


--- Cancel All Open OrdersCopy Location ---


--- EClient.reqGlobalCancel () ---


--- Exercise OptionsCopy Location ---


--- EClient.exerciseOptions ( ---


--- Minimum Price IncrementCopy Location ---


--- Request Market RuleCopy Location ---


--- EClient.reqMarketRule ( ---


--- Receive Market RuleCopy Location ---


--- EWrapper.marketRule ( ---


--- MiFIR Transaction Reporting FieldsCopy Location ---


--- Modifying OrdersCopy Location ---


--- Place OrderCopy Location ---


--- EClient.placeOrder ( ---


--- Understanding Order PrecautionsCopy Location ---


--- Disabling Warning Messages ---


--- Modifying Precautionary Settings ---


--- Order Placement ConsiderationsCopy Location ---


--- Pre-Borrow Shares For ShortingCopy Location ---


--- Test Order Impact (WhatIf)Copy Location ---


--- Trigger MethodsCopy Location ---


--- TWS UI Display GroupsCopy Location ---


--- Query Display GroupsCopy Location ---


--- Request Query Display GroupsCopy Location ---


--- EClient.queryDisplayGroups ( ---


--- Receive Query Display GroupsCopy Location ---


--- EWrapper.displayGroupList ( ---


--- Subscribe To Group EventsCopy Location ---


--- Request Group Events SubscriptionCopy Location ---


--- EClient.subscribeToGroupEvents ( ---


--- Receive Group Events SubscriptionCopy Location ---


--- EWrapper.displayGroupUpdated ( ---


--- Unsubscribe From Group EventsCopy Location ---


--- EClient.unsubscribeFromGroupEvents ( ---


--- Update Display GroupCopy Location ---


--- EClient.updateDisplayGroup ( ---


--- Wall Street HorizonCopy Location ---


--- Meta DataCopy Location ---


--- Meta Data FiltersCopy Location ---


--- Requesting Meta DataCopy Location ---


--- EClient.reqWshMetaData ( ---


--- Receive Meta DataCopy Location ---


--- EWrapper.wshEventData ( ---


--- Cancel Meta DataCopy Location ---


--- EClient.cancelWshMetaData ( ---


--- Event DataCopy Location ---


--- WshEventData ObjectCopy Location ---


--- WshEventData() ---


--- Request Event DataCopy Location ---


--- EClient.reqWshEventData ( ---


--- Receive Event DataCopy Location ---


--- EWrapper.wshEventData ( ---


--- Cancel Event DataCopy Location ---


--- EClient.cancelWshEventData ( ---


--- Traders' Insight RSS ---


--- To add IBKR Traders’ Insight to your RSS Feed, please paste the following link into your reader: ---


--- IBKR Quant RSS ---


--- To add IBKR Quant to your RSS Feed,please paste the following link into your reader: ---


--- Attention ---


--- This page contains information regarding Options Trading ---


--- Privacy Preference Center ---


--- Your Privacy ---


--- Strictly Necessary Cookies ---


--- Performance Cookies ---


--- Functional Cookies ---


--- Marketing Cookies and Web Beacons ---


--- Interactive Brokers Group Cookie Policy ---


--- IBKR LLC (U.S.) ---

Financial Education
More Campus Resources
Language
SHARE Facebook LinkedIn X Email
The TWS API is a TCP Socket Protocol API based on connectivity to the Trader Workstation or IB Gateway. The API acts as an interface to retrieve and send data autonomously to Interactive Brokers. Interactive Brokers provides code systems in Python, Java, C++, C#, and VisualBasic.
The TWS API is a message protocol as its core, and any library that implements the TWS API, whether created by IB or someone else, is a tool to send and receive these messages over a TCP socket connection with the IB host platform (TWS or IB Gateway). As such the system can be tweaked and modified into any language of interest given the intention to translate the underlying decoder.
In short, a library written in any other languages must be sending and receiving the same data in the same format as any other conformant TWS API library, so users can look at the documentation for our libraries to see what a given request or response consists of (what it must include, in what form, etc.) and implement them in their own structure.
Our TWS API components are aimed at experienced professional developers willing to enhance the current TWS functionality. Before you use TWS API, please make sure you fully understand the concepts of OOP ( https://www.geeksforgeeks.org/introduction-of-object-oriented-programming/ ) and other Computer Science Concepts. Regrettably, Interactive Brokers cannot offer any programming consulting. Before contacting our API support, please always refer to our available documentation, sample applications and Recorded Webinars
This guide references the Java, VB, C#, C++ and Python Testbed sample projects to demonstrate the TWS API functionality. Code snippets are extracted from these projects and we suggest all those users new to the TWS API to get familiar with them in order to quickly understand the fundamentals of our programming interface. The Testbed sample projects can be found within the samples folder of the TWS API’s installation directory.
While Interactive Brokers does maintain a Python, Java, C#, and C++ offering for the TWS API, C# and our Excel offerings are exclusively available for Windows PC. As a result, these features are not available on Linux or Mac OS.
The minimum supported language version is documented on the right for each of our supported languages.
Please be sure to toggle the indicated language to the language of your choosing.
Minimum supported Python release is version 3.11.0.
The minimum supported Java version is Java 8 (JDK 8).
The minimum supported C++ version is C++ 14 Standard.
The C# implementation was built using:
Our programming interface is designed to automate some of the operations a user normally performs manually within the TWS Software such as placing orders, monitoring your account balance and positions, viewing an instrument’s live data… etc. There is no logic within the API other than to ensure the integrity of the exchanged messages. Most validations and checks occur in the backend of TWS and our servers. Because of this it is highly convenient to familiarize with the TWS itself, in order to gain a better understanding on how our platform works. Before spending precious development time troubleshooting on the API side, it is recommended to first experiment with the TWS directly.
Remember: If a certain feature or operation is not available in the TWS, it will not be available on the API side either!
The TWS API C# source files are not available through the Mac and Unix distribution download as the language is built around Dynamic Link Library (DLL) files for execution. This is because DLL files are exclusively supported through Windows platforms.
If your regular trading account has been approved and funded, you can use your Account Management page to open a Paper Trading Account which lets you use the full range of trading facilities in a simulated environment using real market conditions. Using a Paper Trading Account will allow you not only to get familiar with the TWS API but also to test your trading strategies without risking your capital. Note the paper trading environment has inherent limitations .
In order to use the TWS API, all customers must install either Trader Workstation or IB Gateway to connect the API to. Both downloads maintain the same level of usage and support; however, they both have equal benefits. For example, IB Gateway will be less resource intensive as there is no UI; however, the Trader Workstation has access all of the same information as the API, if users would like an interface to confirm data.

It is recommended for API users to use offline TWS because TWS online version has automatic update. Please use same TWS version to make sure the TWS version and TWS API version are synced. These will help preventing version conflict issue.

Some TWS Settings affect API.
The settings required to use the TWS API with the Trader Workstation are managed in the Global Configuration under “API” -> “Settings”
In this section, only the most important API settings for API connection are covered.
Please:

The information listed below are not required or necessary in order to operate the TWS API. However, these steps include many references which can help improve the day to day usage of the TWS API that is not explicitly offered as a callable method within the API itself.
Note: For IBHK API users, it is commended to use IB Gateway instead of TWS. It is because all IBHK users cannot choose “Never Lock Trader Workstation” in TWS – Global Configuration – Lock and Exit. If there is inactivity, TWS will be locked and there will be API disconnection.
In TWS/ IB Gateway – “Global Configuration” – “General”, you can adjust the Memory Allocation (in MB)* .
This feature is to control how much memory your computer can assign to the TWS/ IB Gateway application. Usually, higher value allows users to have faster data returning speed.
Normally, it is recommended for API users to set 4000. However, it depends on your computer memory size because setting too high may cause High Memory Usage and application not responding.

For details, please visit: https://www.ibkrguides.com/traderworkstation/increase-tws-memory-size.htm

Note:
In TWS/ IB Gateway – “Global Configuration” – “Lock and Exit”, you can choose the time of your TWS being shut down.
For API users, it is recommended to choose “Never lock Trader Workstation” and “Auto restart”.

Note:

The weekly authentication cycle starts on every Monday. If you receive Login failed = Soft token=0 received instead of expected permanent for zdc1.ibllc.com:4001 (SSL) ,  this means you need to manually login again to complete the weekly reauthentication task.
In TWS – “Global Configuration” – “API” – “Precautions”, you can enable the following items to stop receiving the order submission messages.

Each IB account has a pre-decided IB server. You can visit this link to know our IB servers’ locations: https://www.interactivebrokers.com/download/IB-Host-and-Ports.pdf
Yet, all IB paper accounts are connected to US server by default and its location cannot be changed.
As IB servers in different regions have different scheduled server maintenance time ( https://www.interactivebrokers.com/en/software/systemStatus.php ), you may need to change the IB server location in order to avoid service downtime.
For checking your connected IB server location, you can go to TWS and click “Data” to see your Primary server. In the below image, the pre-decided IB server location is: cdc1.ibllc.com

If you want to change your live IB account server location in TWS, please submit a web ticket to “Technical Assistance” – “Connectivity” in order to request changing the IB server location.
In the web ticket, you need to provide:
After you submit the ticket, you will receive a web ticket reply which require you to confirm and understand the migration request .

Note:
In TWS Global Configuration – Orders – Smart Routing, you can set your SMART order routing algorithm. For available SMART Routing via TWS API, please visit: https://www.interactivebrokers.com/campus/ibkr-api-page/contracts/#smart-routing

In TWS Global Configuration – Advisor Setup – Presets, you can need to choose Allocation Preference in order to avoid wrong allocation result.

The TWS Setting listed in the Global Configuration under API -> Setting for Maintain and resubmit orders when connection is restored , is enabled by default in TWS 10.28 and above. When this setting is checked, all orders received while connectivity is lost will be saved and automatically resubmitted when connectivity is restored. Please note, if the Trader Workstation is closed during this time, the orders are deleted regardless of the setting.
The TWS Setting listed in the Global Configuration under API -> Setting for Maintain connection upon receiving incorrectly formatted fields , is enabled by default in TWS 10.28 and above. For clients operating on Client Version 100 and above, users will not disconnect from fields with invalid value submissions when the setting is enabled.
It is recommended for API users to use same TWS API version to make sure the TWS version and TWS API version are synced in order to prevent version conflict issue.

Running the Windows version of the API installer creates a directory “C:\\TWS API\” for the API source code in addition to automatically copying two files into the Windows directory for the DDE and C++ APIs. It is important that the API installs to the C: drive , as otherwise API applications may not be able to find the associated files. The Windows installer also copies compiled dynamic linked libraries (DLL) of the ActiveX control TWSLib.dll, C# API CSharpAPI.dll, and C++ API TwsSocketClient.dll. Starting in API version 973.07 , running the API installer is designed to install an ActiveX control TWSLib.dll, and TwsRtdServer control TwsRTDServer.dll which are compatible with both 32 and 64 bit applications.

It is important to know that the TWS API is only available through the interactivebrokers.github.io MSI or ZIP file. Any other resource, including pip, NuGet, or any other online repository is not hosted, endorsed, supported, or connected to Interactive Brokers. As such, updates to the installation should always be downloaded from the github directly.
$ cd ~/TWS API/source/pythonclient $ python3 setup.py install

$ cd ~/Downloads $ ls

Note:


Note: On MacOS, if you directly open the twsapi_macunix.<Major Version>.<Minor Version>.zip file, you will get an error: “ Unable to expand…… It is an unsupported format “. It is required for users to unzip the zipped TWS API file using the above MacOS Terminal command.


File Path: ~\ TWS API\ API_VersionNum.txt
You can check your API version in this file.

File Path: ~\TWS API\samples\CSharp\IBSampleApp\bin\Release\IBSampleApp.exe
You can manually use the IBSampleApp to test the API functions.

File Path: ~\TWS API\samples\Java\ApiDemo.jar
This is built with Java. Java users can use it to quickly test the IB TWS API functions.
Many of our most common features, as well as instructions for installing and running the Trader Workstation API, are available in our TWS API Tutorial Series. The series uses Python to implement the TWS API functionality; however, the function calls are identical across languages, and will follow a similar patter regardless of language.
This tutorial covers:
Third party software vendors make use of the TWS’ programming interface (API) to integrate their platforms with Interactive Broker’s. Thanks to the TWS API, well known platforms such as Ninja Trader or Multicharts can interact with the TWS to fetch market data, place orders and/or manage account and portfolio information.
It is important to keep in mind that most third party API platforms are not compatible with all IBKR account structures . Always check first with the software vendor before opening a specific account type or converting an IBKR account type. For instance, many third party API platforms such as NinjaTrader and TradeNavigator are not compatible with IBKR linked account structures, so it is highly recommended to first check with the third party vendor before linking your IBKR accounts.
An ongoing list of common Third Party Connections are available within our documentation. This resource will also link out to connection guides detailing how a user can connect with a given platform.
A non-exhaustive list of third party platforms implementing our interface can be found in our Investor’s Marketplace . As stated in the marketplace, the vendors’ list is in no way a recommendation from Interactive Brokers. If you are interested in a given platform that is not listed, please contact the platform’s vendor directly for further information.
Noted in further depth through our Architecture section, the TWS API is built using standardized socket protocol. As a result, users may develop or access alternative third party modules and classes in place of Interactive Brokers default modules through the TWS API Download . While the API is adaptable for client implementations, please understand that Interactive Brokers API Support cannot provide support for non-standard implementations. While we can review your API logs to affirm what content is being submitted, any further assistance will need to take place with the module’s original developer.
This is neither an endorsement or admonishment of third party implementations. Interactive Brokers will always advise clients use our direct TWS API implementation whenever possible.
While Interactive Brokers’ API Support is aware of the ib_insync package, we cannot provide coding assistance for the package.
With that in mind, users should be aware that the original ib_insync package is built using a legacy release of the TWS API and is no longer updated. Users who wish to implement the ib_insync structure using supported releases of the Trader Workstation should migrate to the ib_async package , which is a modernized implementation of the package by one of its original developers.
This is neither an endorsement or admonishment of either the ib_insync or ib_async library. Interactive Brokers will always advise clients use our direct TWS API implementation whenever possible.
While all of the available Trader Workstation API default samples provide equivalent functionality, some languages have unique configurations that must be implemented in order to use our samples or program code with the underlying API.
Due to the malleability of the many Linux distributions including MacOS, Interactive Brokers is unable to provide a pre-built binary for the library. As such, users programming in C++ on a Linux machine must manually build the Intel® Decimal Floating-Point Math Library manually.
As described in the README file from the linked page, you can find the library’s build steps within the ~/IntelRDFPMathLib20U2/LIBRARY/README file.
Python has a unique system for importing libraries into it’s IDEs. This extends even further when it comes to virtual environments. In order to utilize Python code with the TWS API, you must run our setup file in order to import the code.
In order to update the Python IDE, these steps MUST be performed through Command Prompt or Terminal. This can not be done through an explorer interface.
As such, users should begin by launching their respective command line interface.
These samples will display Windows commands, though the procedure is identical on Windows, MacOS, and Linux.

Customers should then change their directory to {TWS API}\source\pythonclient .
It is then recommend to display the contents of the directory with “ls” for Unix, or “dir” for Windows users.

Customers will now need to run the setup.py steps with the installation parameter. This can be done with the command: python setup.py install

After running the prior command, users should see a large block of text describing various values being updated and added to their system. It is important to confirm that the version installed on your system mirrors the build version displayed. This example represents 10.25; however, you may have a different version.

Finally, users should look to confirm their installation. The simplest way to do this is to confirm their version with pip. Typing this command should show the latest installed version on your system: python -m pip show ibapi

After resolving the reference errors, using the TWSAPI may print a UserWarning upon connection. These warnings are predominantly cosmetic and can be ignored. These issues are caused by the Pypi release of protobuf running version 6.30.1 and above, while the TWS API is built with 5.29.3. The warning is simply notifying users that their version is 1 major version different. However, given protobuf is currently backgwards compatible, this should not present any issues with the implementation. Developers uncomfortable with the warning messages have a few options:
Our VB.NET code is provided for demonstration purposes only; there is no pure, standalone VB.NET-based TWS API library. Both our “VB_API_Sample” and the VB.NET “Testbed” projects included with our TWS API releases call the C# TWS API source. The provided VB.NET code only interfaces with the C# source. Please keep in mind that these samples are in VB.NET, not Visual Basic for Applications.
If there are remaining questions about available API functionality after reviewing the content of this documentation, the API Support group is available to help.
-> It is important to keep in mind that IB cannot provide programming assistance or give suggestions on how to code custom applications. The API group can review log files which contain a record of communications between API applications and TWS, and give details about what the API can provide.
General suggestions on starting out with the IB system:
Log files are used by developers and support to unambiguously understand the behavior of a request.
These files are stored on the clients machine and are only sent to Interactive Brokers by client request.
These logs will recycle every 7 days. This would include the current day and the prior 6 days.
TWS and IB Gateway can be configured to create a separate log file which has a record of just communications with API applications. This log is not enabled by default; but needs to be enabled by the Global Configuration setting “Create API Message Log File” (picture below).
Note: Both the API and TWS logs are encrypted locally. The API logs can be decrypted for review from the associated TWS or IB Gateway session, just like the TWS logs, as shown in the section describing the Local location of logs.
Note: The TWS/IB Gateway log file setting has to be set to ‘Detail’ level before an issue occurs so that information recorded correctly when it manifests. However due to the high amount of information that will be generated under this level, the resulting logs can grow considerably in size.
Enabling creation of API logs
TWS:


IB Gateway:

Enabling DEBUG-level logging for the host platform (TWS or IBG, this does not affect API logs):
Setting debug=1 has added benefits in TWS.

Logs are stored in the TWS settings directory, C:\Jts\ and then your user subdirectory by default on a Windows computer (the default can be configured differently on the login screen).
The path to the log file directory can be found from a TWS or IB Gateway session by using the combination Ctrl-Alt-U . This will reveal path such as C:\Jts\detcfsvirl\ (on Windows).
Due to privacy regulations, logs are encrypted before they are saved to disk. To review them on your machine, you may need to Export Your Logs from the associated TWS or IB Gateway session.
In some instances, your logs may be too large to export or upload for Client Services to review. In scenarios such as this, the Support team may request that you delete your existing API logs, and then replicate the error before attempting to upload them again.
To delete your logs:
If API logging has been enabled with the setting “Create API Message Log” during the time when an issue occurs, it can be uploaded to the API group.
Important: Please be aware that the process of uploading logs does not notify support, nor is a ticket logged. You will need to contact our representatives through a direct call, chat, or  secure message center message for our representatives to be aware of the upload.
To upload logs as a Windows user:
To upload logs as a Mac and Linux user:
If logs have been uploaded, please let the API Support group know by creating a webticket in the Message Center in Account Management (under Support) indicating the username of the associated TWS session. In some cases a TWS log may also be requested at the Detailed logging level. The TWS log can grow quite large and may not be uploadable by the automatic method; in this case an alternative means of upload can be found.
Each supported API language of the API contains a message file that translates a given number identifier into their corresponding request. The message identifier numbers used in the underlying wire protocol is the core of the TWS API.
The information on the right documents where each message reader file is located. The {TWS API} listed is the path to the primary TWS API or JTS folder created from the API installation.
By default, this will be saved directly on the C: drive.
Both the Incoming and Outgoing message IDs are listed in one file.
{TWS API}\source\pythonclient\ibapi\messages.py
Incoming Message IDs: {TWS API}\source\JavaClient\com\ib\client\EDecoder.java
Outgoing Message IDs: {TWS API}\source\JavaClient\com\ib\client\EClient.java
Incoming Message IDs: {TWS API}\source\CppClient\client\EDecoder.h
Outgoing Message IDs: {TWS API}\source\CppClient\client\EClient.h
Incoming Message IDs: {TWS API}\source\CSharpClient\client\IncomingMessage.cs
Outgoing Message IDs: {TWS API}\source\CSharpClient\client\OutgoingMessages.cs
Depending on the Excel structure used, either C# or Java file path will be used.
For ActiveX and RTD, see C#
For DDE, see Java.
In our API logs, the direction of the message is indicated by the arrow at the beginning:
-> for incoming messages (TWS to client)
<- for outgoing messages (client to TWS)
Thus <- 3 (outgoing request of type 3) is a placeOrder request, and the subsequent incoming requests are:
-> 5 = openOrder response
-> 11 = executionData response
-> 59 = commissionReport response
Also note that the first openOrder response carries with it an orderStatus response in the same message. If that status were to change later, it would be delivered as a standalone message:
-> 3 = orderStatus response
Developers may often find a super-massive value returned from requests like market data, P&L information, and elsewhere. These are known as Unset values. Unset values are used throughout programming systems to indicate that a value is not available. Unset values are used in place of NULL characters to prevent any unexpected error be thrown in your code. Unset values are also used in place of values like 0 to avoid confusing viewers to believe they have an account balance of 0, or that an equity is worth $0.
An unset value is the maximum value of a given data type. So the Unset Double value will appear like 1.7976931348623157E308, which contains approximately 308 digits to intentionally appear extraneous.
The TWS API is a BSD implementation that communicates request and response values across TCP socket using a end-line-delimited message protocol. While the underlying structure of the message will vary by request, requests typically follow a patter of indicating a message identifier, request identifier, and then directly relevant content for the request such as contract details or market data parameters.
The provided TWS API package use two distinct classes to accommodate the request / response functionality of the socket protocol, EClient and EWrapper respectively.
The EWrapper class is used to receive all messages from the host and distribute them amongst the affiliated response functions. The EReader class will retrieve the messages from the socket connection and decode them for distribution by the EWrapper class.





EClient or EClientSocket is used to send requests to the Trader Workstation. This client class contains all the available methods to communicate with the host. Up to 32 clients can be connected to a single instance of the host Trader Workstation or IB Gateway simultaneously.
The primary distinction in EClient and EClientSocket is the involvement of the EReader Class to trigger when requests should be processed. EClient is unique to the Python implementation and utilizes the Python Queue module in place of the EReaderSignal directly. Both the EReaderSignal and Python Queue module handle the queueing process for submitting messages across the socket connection. In either scenario, the EWrapper class must be implemented first to acknowledge the EClient requests.
Note : The EReaderSignal class is not used for Python API. The Python Queue module is used for inter-thread communication and data exchange.
…

…

…

…

Our market maker-designed IBKR Trader Workstation (TWS) lets traders, investors, and institutions trade stocks, options, futures, forex, bonds, and funds on over 100 markets worldwide from a single account. The TWS API is a programming interface to TWS, and as such, for an application to connect to the API there must first be a running instance of TWS or IB Gateway.
As an alternative to TWS for API users, IBKR also offers IB Gateway (IBGW). From the perspective of an API application, IB Gateway and TWS are identical; both represent a server to which an API client application can open a socket connection after the user has authenticated. With either application (TWS or IBGW), the user must manually enter their username and password into a login window. For security reasons, a headless session of TWS or IBGW without a GUI is not supported. From the user’s perspective, IB Gateway may be advantageous because it is a lighter application which consumes about 40% fewer resources.
Both TWS and IBGW were designed to be restarted daily. This is necessary to perform functions such as re-downloading contract definitions in cases where contracts have been changed or new contracts have been added. Beginning in version 974+ both applications offer an autorestart feature that allows the application to restart daily without user intervention. With this option enabled, TWS or IBGW can potentially run from Sunday to Sunday without re-authenticating. After the nightly server reset on Saturday night it will be necessary to again enter security credentials.
The advantages of TWS over IBGW is that it provides the end user with many tools (Risk Navigator, OptionTrader, BookTrader, etc) and a graphical user interface which can be used to monitor an account or place orders. For beginning API users, it is recommended to first become acquainted with TWS before using IBGW.
For simplicity, this guide will mostly refer to the TWS although the reader should understand that for the TWS API’s purposes, TWS and IB Gateway are synonymous.
Pacing Limitations with regards to the TWS API are based on the number of requests submitted by a client connection. A “request” is a user-submitted query to retrieve some form of data.
An example of a request is a query to retrieve live watchlist data . While you may make a single request for market data, you will receive market data until the subscription is cancelled or your session is disconnected. Only the original request to begin the flow of data will contribute to the pacing limitation.
The maximum number of API requests that can be submitted are equivalent to your Maximum Market Data Lines divided by 2, per second.
By default, all users maintain 100 market data lines. Therefore, users have a pacing limitation of (100/2)= 50 requests per second .
Clients that have increased their market data lines to 200, by way of commission or Quote Booster Subscription , would receive (200/2)= 100 requests per second, and this would increment as your market data lines increase or decrease.
In some use cases, if you plan to send more than 50 requests per second, some orders may be queued and delayed. For this scenario, please consider switching to FIX API.
For FIX API users in IB Gateway, the limitation is 250 messages per second.
For FIX API users without using IB Gateway or TWS, there is no limitation on messages per second, but less is better.
The TWS API supports two formats for users who break the pacing limitations. This behavior is set in the Global Configuration of Trader Workstation or IB Gateway. Under “API” and then “Settings” users will see a setting for “Reject messages above maximum allowed message rate vs applying pacing.”


A socket connection between the API client application and TWS is established with the IBApi.EClientSocket.eConnect function. TWS acts as a server to receive requests from the API application (the client) and responds by taking appropriate actions. The first step is for the API client to initiate a connection to TWS on a socket port where TWS is already listening. It is possible to have multiple TWS instances running on the same computer if each is configured with a different API socket port number. Also, each TWS session can receive up to 32 different client applications simultaneously. The client ID field specified in the API connection is used to distinguish different API clients.
Once our two main objects have been created, EWrapper and ESocketClient, the client application can connect via the IBApi.EClientSocket object:





eConnect starts by requesting from the operating system that a TCP socket be opened to the specified IP address and socket port. If the socket cannot be opened, the operating system (not TWS) returns an error which is received by the API client as error code 502 to IBApi.EWrapper.error (Note: since this error is not generated by TWS it is not captured in TWS log files). Most commonly error 502 will indicate that TWS is not running with the API enabled, or it is listening for connections on a different socket port. If connecting across a network, the error can also occur if there is a firewall or antivirus program blocking connections, or if the router’s IP address is not listed in the “Trusted IPs” in TWS.
After the socket has been opened, there must be an initial handshake in which information is exchanged about the supported version of the TWS and API to ensure each platform can interpret received messages correctly.
After the highest version number which can be used for communication is established, TWS will return certain pieces of data that correspond specifically to the logged-in TWS user’s session. This includes (1) the account number(s) accessible in this TWS session, (2) the next valid order identifier (ID), and (3) the time of connection. In the most common mode of operation the EClient.AsyncEConnect field is set to false and the initial handshake is taken to completion immediately after the socket connection is established. TWS will then immediately provides the API client with this information.
There is an alternative, deprecated mode of connection used in special cases in which the variable AsyncEconnect is set to true, and the call to startAPI is only called from the connectAck() function. All IB samples use the mode AsyncEconnect = False.
The ConnectAck function is called automatically once a connection has been established with the Trader Workstation or IB Gateway.




A user can verify whether their API session is connected at any point with the EClient.isConnected() function.





eConnect starts by requesting from the operating system that a TCP socket be opened to the specified IP address and socket port. If the socket cannot be opened, the operating system (not TWS) returns an error which is received by the API client as error code 502 to IBApi.EWrapper.error (Note: since this error is not generated by TWS it is not captured in TWS log files). Most commonly error 502 will indicate that TWS is not running with the API enabled, or it is listening for connections on a different socket port. If connecting across a network, the error can also occur if there is a firewall or antivirus program blocking connections, or if the router’s IP address is not listed in the “Trusted IPs” in TWS.
After the socket has been opened, there must be an initial handshake in which information is exchanged about the supported version of the TWS and API to ensure each platform can interpret received messages correctly.
After the highest version number which can be used for communication is established, TWS will return certain pieces of data that correspond specifically to the logged-in TWS user’s session. This includes (1) the account number(s) accessible in this TWS session, (2) the next valid order identifier (ID), and (3) the time of connection. In the most common mode of operation the EClient.AsyncEConnect field is set to false and the initial handshake is taken to completion immediately after the socket connection is established. TWS will then immediately provides the API client with this information.
There is an alternative, deprecated mode of connection used in special cases in which the variable AsyncEconnect is set to true, and the call to startAPI is only called from the connectAck() function. All IB samples use the mode AsyncEconnect = False.
API programs always have at least two threads of execution. One thread is used for sending messages to TWS, and another thread is used for reading returned messages. The second thread uses the API EReader class to read from the socket and add messages to a queue. Everytime a new message is added to the message queue, a notification flag is triggered to let other threads know that there is a message waiting to be processed. In the two-thread design of an API program, the message queue is also processed by the first thread. In a three-thread design, an additional thread is created to perform this task. The thread responsible for the message queue will decode messages and invoke the appropriate functions in EWrapper. The two-threaded design is used in the IB Python sample Program.py and the C++ sample TestCppClient, while the ‘Testbed’ samples in the other languages use a three-threaded design. Commonly in a Python asynchronous network application, the asyncio module will be used to create a more sequential looking code design.
The class which has functionality for reading and parsing raw messages from TWS is the IBApi.EReader class.
For C#, Java, C++, and Visual Basic, we instead maintain a triple thread structure which requires the creation of a reader thread, a queue thread, and then a wrapper thread. The documentation listed here further elaborates on the structure for those languages.



Now it is time to revisit the role of IBApi.EReaderSignal initially introduced in The EClientSocket Class. As mentioned in the previous paragraph, after the EReader thread places a message in the queue, a notification is issued to make known that a message is ready for processing. In the (C++, C#/.NET, Java) APIs, this is done via the IBApi.EReaderSignal object we initiated within the IBApi.EWrapper’s implementer.
In Python IB API, the EReader logic is handled in the EClient.connect so the EReader thread is automatically started upon connection. There is no need for user to start the reader.
Once the client is connected, a reader thread will be automatically created to handle incoming messages and put the messages into a message queue for further process. User is required to trigger Client::run() below, where the message queue is processed in an infinite loop and the EWrapper call-back functions are automatically triggered.
Now it is time to revisit the role of IBApi.EReaderSignal initially introduced in The EClientSocket Class. As mentioned in the previous paragraph, after the EReader thread places a message in the queue, a notification is issued to make known that a message is ready for processing. In the Python API, this is handled automatically by the Queue class.
If you want to connect TWS/ IB Gateway from a remote server, uncheck the “Allow connection from localhost only” setting. Under the “Trusted IPs” section, click “Create” and enter the IP Address detected in “Accept incoming connection attempt from <IP Address>” into “Trusted IPs”.
“Trusted IPs” does not accept subnet (e.g. /27, /28). It only accepts single IP Addresses. In the following example, there is a remote computing cluster /27 which has 32 IP Addresses and the remote computing cluster will randomly assign one of the computing nodes to connect to TWS in every connection.  To make this happen, every Private IPv4 Address of the subnet are put into the “Trusted IPs” (You can also exclude the first IP Network Address and the last IP Broadcast Address of the subnet).

For security reasons, by default the API is not configured to automatically accept connection requests from API applications. After a connection attempt, a dialogue will appear in TWS asking the user to manually confirm that a connection can be made:
Untrusted IPs attempting to make a connection will be denied without prompting.

To prevent the TWS from asking the end user to accept the connection, it is possible to configure it to automatically accept the connection from a trusted IP address and/or the local machine. This can easily be done via the TWS API settings:

It is not possible to login to multiple trading applications simultaneously with the same username. However, it is possible to create additional usernames for an account that can be used in different trading applications simultaneously, as long as there is not more than a single trading application logged in with a given username at a time. There are some additional cases in which it is also useful to create additional usernames:
If a different username is utilized to login to Client Portal in either of these cases, then it will not affect the TWS/IBGW session.
How to add additional usernames in Account Management
If there is a problem with the socket connection between TWS and the API client, for instance if TWS suddenly closes, this will trigger an exception in the EReader thread which is reading from the socket. This exception will also occur if an API client attempts to connect with a client ID that is already in use.
The socket EOF is handled slightly differently in different API languages. For instance in Java, it is caught and sent to the client application to IBApi::EWrapper::error with errorCode 507: “Bad Message”. In C# it is caught and sent to IBApi::EWrapper::error with errorCode -1. The client application needs to handle this error message and use it to indicate that an exception has been thrown in the socket connection.
Clients can validate a broken connection with the EWrapper.connectionClosed and EClient.isConnected functions.
Once a connection fails for any reason, the EWrapper.connectionClosed function will be called. This function can be used to build reconnection logic or affirm a system disconnect.




The IBApi.EClient.reqAccountSummary method creates a subscription for the account data displayed in the TWS Account Summary window. It is commonly used with multiple-account structures. Introducing broker (IBroker) accounts with more than 50 subaccounts or configured for on-demand account lookup cannot use reqAccountSummary with group=”All”. A profile name can be accepted in place of group. See Unification of Groups and Profiles.
The TWS offers a comprehensive overview of your account and portfolio through its Account and Portfolio windows. This information can be obtained via the TWS API through three different kind of requests/operations.
The initial invocation of reqAccountSummary will result in a list of all requested values being returned, and then every three minutes those values which have changed will be returned. The update frequency of 3 minutes is the same as the TWS Account Window and cannot be changed.
Requests a specific account’s summary. This method will subscribe to the account summary as presented in the TWS’ Account Summary tab. Customers can specify the data received by using a specific tags value. See the Account Summary Tags section for available options.
Alternatively, many languages offer the import of AccountSummaryTags with a method to retrieve all tag values.
reqId: int. The unique request identifier.
group: String. set to “All” to return account summary data for all accounts, or set to a specific Advisor Account Group name that has already been created in TWS Global Configuration.
tags: String. A comma separated list with the desired tags
)
Important: only two active summary subscriptions are allowed at a time!

Code example:





reqId: int. the request’s unique identifier.
account: String. the account id
tag: String. the account’s attribute being received.
value: String. the account’s attribute’s value.
currency: String. the currency on which the value is expressed.
)
Receives the account information. This method will receive the account information just as it appears in the TWS’ Account Summary Window.

reqId: String. The request’s identifier.
)
Notifies when all the accounts’ information has ben received. Requires TWS 967+ to receive accountSummaryEnd in linked account structures.



Once the subscription to account summary is no longer needed, it can be cancelled via the IBApi::EClient::cancelAccountSummary method:
reqId: int. The identifier of the previously performed account request
)


The IBApi.EClient.reqAccountUpdates function creates a subscription to the TWS through which account and portfolio information is delivered. This information is the exact same as the one displayed within the TWS’ Account Window. Just as with the TWS’ Account Window, unless there is a position change this information is updated at a fixed interval of three minutes.
Unrealized and Realized P&L is sent to the API function IBApi.EWrapper.updateAccountValue function after a subscription request is made with IBApi.EClient.reqAccountUpdates. This information corresponds to the data in the TWS Account Window, and has a different source of information, a different update frequency, and different reset schedule than PnL data in the TWS Portfolio Window and associated API functions (below). In particular, the unrealized P&L information shown in the TWS Account Window which is sent to EWrapper.updatePortfolio will update either (1) when a trade for that particular instrument occurs or (2) every 3 minutes. The realized P&L data in the TWS Account Window is reset to 0 once per day.
It is important to keep in mind that the P&L data shown in the Account Window and Portfolio Window will sometimes differ because there is a different source of information and a different reset schedule.
See Profit & Loss for alternative PnL data
Subscribes to a specific account’s information and portfolio. Through this method, a single account’s subscription can be started/stopped. As a result from the subscription, the account’s information, portfolio and last update time will be received at EWrapper.updateAccountValue, EWrapper.updatePortfolio, EWrapper.updateAccountTime respectively. All account values and positions will be returned initially, and then there will only be updates when there is a change in a position, or to an account value every 3 minutes if it has changed. Only one account can be subscribed at a time. A second subscription request for another account when the previous one is still active will cause the first one to be canceled in favor of the second one.
subscribe: bool. Set to true to start the subscription and to false to stop it.
acctCode: String. The account id (i.e. U123456) for which the information is requested.
)

Code example:





Resulting account and portfolio information will be delivered via the IBApi.EWrapper.updateAccountValue, IBApi.EWrapper.updatePortfolio, IBApi.EWrapper.updateAccountTime and IBApi.EWrapper.accountDownloadEnd
key: String. The value being updated.
value: String. up-to-date value
currency: String. The currency on which the value is expressed.
accountName: String. The account identifier. )
Receives the subscribed account’s information. Only one account can be subscribed at a time. After the initial callback to updateAccountValue, callbacks only occur for values which have changed. This occurs at the time of a position change, or every 3 minutes at most. This frequency cannot be adjusted.
Note: An important key passed back in EWrapper.updateAccountValue after a call to EClient.reqAccountUpdates is a boolean value ‘accountReady’. If an accountReady value of false is returned that means that the IB server is in the process of resetting at that moment, i.e. the account is ‘not ready’. When this occurs subsequent key values returned to EWrapper.updateAccountValue in the current update can be out of date or incorrect.





contract: Contract. The Contract for which a position is held.
position: Decimal. The number of positions held.
marketPrice: Double. The instrument’s unitary price
marketValue: Double. Total market value of the instrument.
averageCost: Double. Average cost of the overall position.
unrealizedPNL: Double. Daily unrealized profit and loss on the position.
realizedPNL: Double. Daily realized profit and loss on the position.
accountName: String. Account ID for the update.
)
Receives the subscribed account’s portfolio. This function will receive only the portfolio of the subscribed account. After the initial callback to updatePortfolio, callbacks only occur for positions which have changed.





timestamp: String. the last update system time.
)
Receives the last time on which the account was updated.





account: String. The account identifier.
)
Notifies when all the account’s information has finished.





When requesting reqAccountUpdates customers will receive values corresponding to various account key/value pairs. The table below documents potential responses and what they mean.
Account values delivered via IBApi.EWrapper.updateAccountValue can be classified in the following way:
Once the subscription to account updates is no longer needed, it can be cancelled by invoking the IBApi.EClient.reqAccountUpdates method while specifying the susbcription flag to be False.
Important : only one account at a time can be subscribed at a time. Attempting a second subscription without previously cancelling an active one will not yield any error message although it will override the already subscribed account with the new one. With Financial Advisory (FA) account structures there is an alternative way of specifying the account code such that information is returned for ‘All’ sub accounts- this is done by appending the letter ‘A’ to the end of the account number, i.e. reqAccountUpdates(true, “F123456A”)
subscribe: bool. Set to true to start the subscription and to false to stop it.
acctCode: String. The account id (i.e. U123456) for which the information is requested.
)





The IBApi.EClient.reqAccountUpdatesMulti can be used in any account structure to create simultaneous account value subscriptions from one or multiple accounts and/or models. As with IBApi.EClient.reqAccountUpdates the data returned will match that displayed within the TWS Account Window.
reqId: int. Identifier to label the request
account: String. Account values can be requested for a particular account
modelCode: String. Values can also be requested for a model
ledgerAndNLV: bool. returns light-weight request; only currency positions as opposed to account values and currency positions
)
Requests account updates for account and/or model.
IBApi.EClient.reqAccountUpdatesMulti cannot be used with Account=”All” in IBroker accounts with more than 50 subaccounts.
A profile name can be accepted in place of group in the account parameter for Financial Advisors

Code example:





The resulting account and portfolio information will be delivered via the IBApi.EWrapper.accountUpdateMulti and IBApi.EWrapper.accountUpdateMultiEnd
requestId: int. The id of request.
account: String. The account with updates.
modelCode: String. The model code with updates.
key: String. The name of parameter.
value: String. The value of parameter.
currency: String. The currency of parameter. )
Provides the account updates.





requestId: int. The id of request
)
Indicates all the account updates have been transmitted.





reqId: int. Identifier to label the request
account: String. Account values can be requested for a particular account
modelCode: String. Values can also be requested for a model
ledgerAndNLV: bool. Specify false to cancel your subscription.
)





It is possible to determine from the API whether an account exists under an account family, and find the family code using the function reqFamilyCodes.
For instance, if individual account U112233 is under a financial advisor with account number F445566, if the function reqFamilyCodes is invoked for the user of account U112233, the family code “F445566A” will be returned, indicating that it belongs within that account family.
Requests family codes for an account, for instance if it is a FA, IBroker, or associated account.





familyCodes: FamilyCodes[]. Unique family codes array of accountIds.
)
Returns array of family codes.





A single user name can handle more than one account. As mentioned in the Connectivity section, the TWS will automatically send a list of managed accounts once the connection is established. The list can also be fetched via the IBApi.EClient.reqManagedAccts method.
Requests the accounts to which the logged user has access to.





accountsList: String. A comma-separated string with the managed account ids.
)
Returns a string of all available accounts for the logged in user. Occurs automatically on initial API client connection.





A limitation of the function IBApi.EClient.reqAccountUpdates is that it can only be used with a single account at a time. To create a subscription for position updates from multiple accounts, the function IBApi.EClient.reqPositions is available.
Note: The reqPositions function is not available in Introducing Broker or Financial Advisor master accounts that have very large numbers of subaccounts (> 50) to optimize the performance of TWS/IB Gateway. Instead the function reqPositionsMulti can be used to subscribe to updates from individual subaccounts. Also not available with IBroker accounts configured for on-demand account lookup.
After initially invoking reqPositions, information about all positions in all associated accounts will be returned, followed by the IBApi::EWrapper::positionEnd callback. Thereafter, when a position has changed an update will be returned to the IBApi::EWrapper::position function. To cancel a reqPositions subscription, invoke IBApi::EClient::cancelPositions.
Subscribes to position updates for all accessible accounts. All positions sent initially, and then only updates as positions change.

Code example:





account: String. The account holding the position.
contract: Contract. The position’s Contract
pos: decimal. The number of positions held. avgCost the average cost of the position.
avgCost: double. The total average cost of all trades for the currently held position. )
Provides the portfolio’s open positions. After the initial callback (only) of all positions, the IBApi.EWrapper.positionEnd function will be triggered.
For futures, the exchange field will not be populated in the position callback as some futures trade on multiple exchanges





Indicates all the positions have been transmitted. Only returned after the initial callback of EWrapper.position.





Cancels a previous position subscription request made with EClient.reqPositions().





The function IBApi.EClient.reqPositionsMulti can be used with any account structure to subscribe to positions updates for multiple accounts and/or models. The account and model parameters are optional if there are not multiple accounts or models available. It is more efficient to use this function for a specific subset of accounts than using IBApi.EClient.reqPositions. A profile name can be accepted in place of group in the account parameter.
requestId: int. Request’s identifier.
account: String. If an account Id is provided, only the account’s positions belonging to the specified model will be delivered.
modelCode: String. The code of the model’s positions we are interested in. )
Requests position subscription for account and/or model Initially all positions are returned, and then updates are returned for any position changes in real time.

Code example:





requestId: int. The id of request
account: String. The account holding the position.
modelCode: String. The model code holding the position.
contract: Contract. The position’s Contract
pos: decimal. The number of positions held.
avgCost: double. The average cost of the position. )
Provides the portfolio’s open positions.





requestId: int. The id of request )
Indicates all the positions have been transmitted.





requestId: int. The identifier of the request to be canceled.
)
Cancels positions request for account and/or model.





Requests can be made to receive real time updates about the daily P&L and unrealized P&L for an account, or for individual positions. Financial Advisors can also request P&L figures for ‘All’ subaccounts, or for a portfolio model. This is further extended to include realized P&L information at the account or individual position level.
The P&L API functions demonstrated below return the data which is displayed in the TWS Portfolio Window in current versions of TWS. As such, the P&L values are calculated based on the reset schedule specified in TWS Global Configuration (by default an instrument-specific reset schedule) and this setting affects values sent to the associated API functions as well. Also in TWS, P&L data from virtual forex positions will be included in the account P&L if and only if the Virtual Fx section of the Account Window is expanded.
See Account Updates for alternative PnL data.
Subscribe using the IBApi::EClient::reqPnLSingle function Cannot be used with IBroker accounts configured for on-demand lookup with account = ‘All’. Currently updates are returned to IBApi.EWrapper.pnlSingle approximately once per second*.
*subject to change in the future.
reqId: int. Request identifier for to track the data.
account: String. Account in which position exists
modelCode: String. Model in which position exists
conId: int. Contract ID (conId) of contract to receive daily PnL updates for. Note: does not return message if invalid conId is entered
)
Requests real time updates for daily PnL of individual positions.

Code example:





reqId: int. Request identifier used for tracking.
pos: decimal. Current size of the position
dailyPnL: double. DailyPnL for the position
unrealizedPnL: double. Total unrealized PnL for the position (since inception) updating in real time
realizedPnL: double. Total realized PnL for the position (since inception) updating in real time
value: double. Current market value of the position. )
Receives real time updates for single position daily PnL values





reqId: int. Request identifier to cancel the P&L subscription for. )
Cancels real time subscription for a positions daily PnL information.





Subscribe using the IBApi::EClient::reqPnL function. Updates are sent to IBApi.EWrapper.pnl.
reqId: int. Request ID to track the data.
account: String. Account for which to receive PnL updates
modelCode: String. Specify to request PnL updates for a specific model. )
Creates subscription for real time daily PnL and unrealized PnL updates.

Code example:





reqId: int. Request identifier for tracking data.
dailyPnL: double. DailyPnL updates for the account in real time
unrealizedPnL: double. Total Unrealized PnL updates for the account in real time
realizedPnL: double. Total Realized PnL updates for the account in real time
)





reqId: int. Request identifier for tracking data. )
Cancels subscription for real time updated daily PnL params reqId





This function will return White Branding ID associated with the user.
Please note, that nothing will be returned if requesting username is not associated with any White Branding entity.
reqId: int. Request ID
)





reqId: int. Identifier for the given request.
whiteBrandingId: String. Identifier for the white branded entity. )





From time to time, IB sends out important News Bulletins , which can be accessed via the TWS API through the EClient.reqNewsBulletins. Bulletins are delivered via IBApi.EWrapper.updateNewsBulletin whenever there is a new bulletin. In order to stop receiving bulletins you need to cancel the subscription.
allMessages: bool. If set to true, will return all the existing bulletins for the current day, set to false to receive only the new bulletins. )
Subscribes to IB’s News Bulletins.





msgId: int. The bulletin’s identifier.
msgType: int. 1: Regular news bulletin; 2: Exchange no longer available for trading; 3: Exchange is available for trading.
message: String. The news bulletin context.
origExchange: String. The exchange where the message comes from. )
Provides IB’s bulletins





Cancels IB’s news bulletin subscription.





An IBApi.Contract object represents trading instruments such as a stocks, futures or options. Every time a new request that requires a contract (i.e. market data, order placing, etc.) is sent to TWS, the platform will try to match the provided contract object with a single candidate.
The Contract object is an object used throughout the TWS API to define the target of your requests. Contract objects will be used for market data, portfolios, orders, executions, and even some news request. This is the staple structure used for all of the TWS API.
In all contracts, the minimum viable structure requires at least a conId and exchange; or a symbol, secType, exchange, primaryExchange, and currency. Derivatives will require additional fields, such as lastTradeDateOrExpiration, tradingClass, multiplier, strikes, and so on.
The values to the right represent the most common Contract values to pass for complete contracts. For a more comprehensive list of contract structures, please see the Contracts page .
ConId: int. Identifier to specify an exact contract.
Symbol: String. Ticker symbol of the underlying instrument.
SecType: String. Security type of the traded instrument.
Exchange: String. Exchange for which data or trades should be routed.
PrimaryExchange: String. Primary listing exchange of the instrument.
Currency: String. Base currency the instrument is traded on.
LastTradeDateOrContractMonth: String. For derivatives, the expiration date of the contract.
Strike: double. For derivatives, the strike price of the instrument.
Right: String. For derivatives, the right (P/C) of the instrument.
TradingClass: String. For derivatives, the trading class of the instrument. May be used to indicate between a monthly or a weekly contract.
Given additional structures for contracts are ever evolving, it is recommended to review the relevant Contract class in your programming language for a comprehensive review of what fields are available.
If there is more than one contract matching the same description, TWS will return an error notifying you there is an ambiguity. In these cases the TWS needs further information to narrow down the list of contracts matching the provided description to a single element.
The best way of finding a contract’s description is within TWS itself. Within TWS, you can easily check a contract’s description either by double clicking it or through the Financial Instrument Info -> Description menu, which you access by right-clicking a contract in TWS:

The description will then appear:
Note: you can see the extended contract details by choosing Contract Info -> Details. This option will open a web page showing all available information on the contract.

Whenever a contract description is provided via the TWS API, the TWS will try to match the given description to a single contract. This mechanism allows for great flexibility since it gives the possibility to define the same contract in multiple ways.
The simplest way to define a contract is by providing its symbol, security type, currency, exchange, and primary exchange. The vast majority of stocks, CFDs, Indexes or FX pairs can be uniquely defined through these four attributes. More complex contracts such as options and futures require some extra information due to their nature. Below are several examples for different types of instruments.
Complete details about a contract in IB’s database can be retrieved using the function IBApi.EClient.reqContractDetails . This includes information about a contract’s conID, symbol, local symbol, currency, etc. which is returned in a IBApi.ContractDetails object. reqContractDetails takes as an argument a Contract object which may uniquely match one contract, and unlike other API functions it can also take a Contract object which matches multiple contracts in IB’s database. When there are multiple matches, they will each be returned individually to the function IBApi::EWrapper::contractDetails.
Request for Bond details will be returned to IBApi::EWrapper::bondContractDetails instead. Because of bond market data license restrictions, there are only a few available fields to be returned in a bond contract description, namely the minTick, exchange, and short name.
Note: Invoking reqContractDetails with a Contract object which has currency = USD will only return US contracts, even if there are non-US instruments which have the USD currency.
Another function of IBApi::EClient::reqContractDetails is to request the trading schedule of an instrument via the TradingHours and LiquidHours fields. The corresponding timeZoneId field will then indicate the time zone for the trading schedule of the instrument. TWS sends these timeZoneId strings to the API from the schedule responses as-is, and may not exactly match the time zones displayed in the TWS contract description.
Possible timeZoneId values are:
reqId: int. Request identifier to track data.
contract: ContractDetails. the contract used as sample to query the available contracts. Typically contains at least the Symbol, SecType, Exchange, and Currency. )
Upon requesting EClient.reqContractDetails, all contracts matching the requested Contract Object will be returned to EWrapper.contractDetails or EWrapper.bondContractDetails .




reqId: int. Request identifier to track data.
contract: ContractDetails. Contains the full contract object contents including all information about a specific traded instrument. )
Receives the full contract’s definitions This method will return all contracts matching the requested via EClientSocket::reqContractDetails. For example, one can obtain the whole option chain with it.





reqId: int. Request identifier to track data. )
After all contracts matching the request were returned, this method will mark the end of their reception.





reqId: int. Request identifier to track data.
contract: ContractDetails. Contains the full contract object contents including all information about a specific traded instrument. )
Delivers the Bond contract data after this has been requested via reqContractDetails.





The option chain for a given security can be returned using the function EClient.reqContractDetails . If an option contract is incompletely defined (for instance with the strike undefined) and used as an argument to EClient.reqContractDetails , a list of all matching option contracts will be returned.
One limitation of this technique is that the return of option chains will be throttled and take a longer time the more ambiguous the contract definition. The function EClient.reqSecDefOptParams was introduced that does not have the throttling limitation.
EClient.reqSecDefOptParams returns a list of expiries and a list of strike prices. In some cases, it is possible there are combinations of strike and expiry that would not give a valid option contract.
reqId: int. The ID chosen for the request
underlyingSymbol: String. Contract symbol of the underlying.
futFopExchange: String. The exchange on which the returned options are trading. Can be set to the empty string “” for all exchanges.
underlyingSecType: String. The type of the underlying security, i.e. STK
underlyingConId: int. The contract ID of the underlying security. )
Requests security definition option parameters for viewing a contract’s option chain.





reqId: int. ID of the request initiating the callback.
underlyingConId: int. The conID of the underlying security.
tradingClass: String. The option trading class.
multiplier: String. The option multiplier.
exchange: String. Exchange for which the derivative is hosted.
expirations: HashSet. A list of the expiries for the options of this underlying on this exchange.
strikes: HashSet. A list of the possible strikes for options of this underlying on this exchange. )
Returns the option chain for an underlying on an exchange specified in reqSecDefOptParams There will be multiple callbacks to securityDefinitionOptionParameter if multiple exchanges are specified in reqSecDefOptParams





The function IBApi::EClient::reqMatchingSymbols is available to search for stock contracts. The input can be either the first few letters of the ticker symbol, or for longer strings, a character sequence matching a word in the security name. For instance to search for the stock symbol ‘IBKR’, the input ‘I’ or ‘IB’ can be used, as well as the word ‘Interactive’. Up to 16 matching results are returned.
There must be an interval of at least 1 second between successive calls to reqMatchingSymbols
Matching stock contracts are returned to IBApi::EWrapper::symbolSamples with information about types of derivative contracts which exist (warrants, options, dutch warrants, futures).
reqId: int. Request identifier used to track data.
pattern: String. Either start of ticker symbol or (for larger strings) company name. )
Requests matching stock symbols.





reqID: int. Request identifier used to track data.
contractDescription: ContractDescription[]. Provide an array of contract objects matching the requested descriptoin. )
Returns array of sample contract descriptions





Forecast and Event Contracts enable investors to trade their opinion on specific yes-or-no questions on economic indicators such as the Consumer Price Index and the Fed Funds Rate, climate indicators including temperatures and atmospheric CO2, key futures markets including  energy, metals, and equity indexes.
Interactive Brokers models Event Contract instruments on options (for ForecastEx products) and futures options (for CME Group products).
Event Contracts can generally be thought of as options products in the TWS API, and their discovery workflow follows a familiar options-like sequence. This guide will make analogies to conventional index options for both ForecastEx and CME Group products.
Forecast Contracts let you trade your view on the outcomes of various economic, government and environmental indicators, elections and tight races.
Each contract pays USD 1.00 at expiry if expiring in-the-money, and your max profit per contract is USD 1.00 minus the premium you paid to purchase the contract. Forecast Contracts are quoted in USD 0.01 increments.
ForecastEx Website: https://forecastex.com/
CME event contracts let you trade your view on whether the price of key futures markets will move up or down by the end of each day’s trading session.
Each contract pays USD 100.00 at expiry if expiring in-the-money, and your max profit per contract is USD 100.00 minus the premium you paid to purchase the contract (plus fees and commissions). CME event contracts are quoted in USD 1.00 increments.
ForecastEx Website: https://www.cmegroup.com/activetrader/event-contracts.html
IB’s Event Contract instrument records use the following fields inherited from the options model:
Given the information above, we can establish a working example against the Global Carbon Dioxide Emissions contract on the ForecastTrader Website .
Reviewing the page to the right, we can see all of the contract details necessary to get started.
While not explicitly stated in the web page, there are several details that may be inferred based on the information present:


In order to request our specific contract, we will need to focus on the “Market closes in 287 days” statement. This value indicates the last day the contract may be traded.
This document is written on the 19th of March, 2025. That is the 78th day of the calendar year.
Given the context that this is day 78, and the market will close in 287 days, the contract’s last trade date would then be the 365th day of the year, or December 31st, 2025.
Given the TWS API date standards, this will be written as 20251231.
This information can now be distilled into a standard TWS API contract definition:
Symbol: “GCE”
SecType: “OPT”
Exchange: “FORECASTX”
Currency: “USD”
LastTradeDateOrContractMonth: “20251231”
Right: “C”
Strike: 40500




Requesting market data for event contracts will follow the same request structure as for any other security type.
Noted in our Contract Definition & Discovery section, ForecastEx instruments do not support buying and selling. Therefore, “BID” and “ASK” values will not correlate to buy and sell values, but the “Highest Bid” and “Buy Yes Now at” prices for the Bid and Ask respectively.
Because “BID” and “ASK” do not correctly directly to Buying and Selling, historical “Trades” nor real-time “Last” prices will not be available.
Order Submission for Event Contracts function the same as any other instrument offered at Interactive Brokers.
There are some unique order behaviors for both CME Group and ForecastEx contracts:
Event Contracts cannot be sold short.
Reviewing the same material as our Contract Example , we have all the tools needed to submit our order with some additional context available in the Order Ticket, featured on the right.
We are already aware that:
This leaves us to decide the quantity, limit price, and time-in-force values.
We can set our limit price based on the values shown in the Order Ticket, or base the value on the Bid and Ask Price from our Requested Market Data .

Given the information above, we are able to create a full order ticket.
Action: “BUY”
TotalQuantity: 1000
OrderType: “LMT”
LmtPrice: 0.57
Tif: “DAY”





When a client application sends a message to TWS which requires a response which has an expected response (i.e. placing an order, requesting market data, subscribing to account updates, etc.), TWS will almost either always 1) respond with the relevant data or 2) send an error message to EWrapper.error() .
Error messages sent by the TWS are handled by the EWrapper.error() method. The EWrapper.error() event contains the originating request Id (or the orderId in case the error was raised when placing an order), a numeric error code and a brief description. It is important to keep in mind that this function is used for true error messages as well as notifications that do not mean anything is wrong.
API Error Messages when TWS is not set to the English Language
The TWS uses the EWrapper.error method not only to deliver errors but also warnings or informative messages. This is done mostly for simplicity’s sake. Below is a table with all the messages which can be sent by the TWS/IB Gateway. All messages delivered by the TWS are usually accompanied by a brief but meaningful description pointing in the direction of the problem.
Remember that the TWS API simply connects to a running TWS/IB Gateway which most of times will be running on your local network if not in the same host as the client application. It is your responsibility to provide reliable connectivity between the TWS and your client application.
The messages in the table below are not a consequence of any action performed by the client application. They are notifications about the connectivity status between the TWS and our servers. Your client application must pay special attention to them and handle the situation accordingly. You are very likely to lose connectivity to our servers at least once a day due to our daily server maintenance downtime as clearly detailed in our Current System Status page. Note that after the system reset, the TWS/IB Gateway will automatically reconnect to our servers and you can resume your operations normally.

Note:
Error codes in different ranges have different indications.
reqId: int. The request identifier corresponding to the most recent reqId that maintained the error stream. This does not pertain to the orderId from placeOrder, but whatever the most recent requestId is.
errorTime: int. The Unix timestamp of when the error took place. Note: This is only implemented for TWS API 10.33+
errorCode: int. The code identifying the error.
errorMsg: String. The error’s description.
advancedOrderRejectJson: String. Advanced order reject description in json format. )





The content below references some of the most common errors received by clients at Interactive Brokers, and offers direct resolutions for the matters in most instances. If further information is required, please feel to contact Customer Service for additional insight.
Error code 2104, 2106, and 2158 all generally state that farm connection is OK. What this means is that the API has successfully connected to Trader Workstation or the IB Gateway, and that connection is able to reach Interactive Brokers servers. There is no issue with the connection, and it is a sign you connected successfully.
While using IB Gateway, users may encounter the error, “A historical data farm connection has become inactive but should be available upon demand.” This means that while no historical data requests are being sent, the connection is halted. Once a historical data request is sent over the API connection, the market data farm will reconnect and supply market data.
Error 10089 notes that clients are requesting market data when they do not maintain a valid market data subscription. To resolve this issue, users must add a market data subscription to the specific user they are requesting market data with . Alternatively, users must request delayed market data prior to requesting market data.
Market data availability is different in TWS versus the API . As a result, market data you can receive in Trader Workstation may not be available in the API.
Interactive Brokers lists many of our most popular market data subscriptions here .
Financial Advisors are able to manage their allocation groups from the TWS API.
Note: Modifications made through the API will effect orders placed through TWS, the TWS API, Client Portal, and the Client Portal API.
faDataType: int. The configuration to change. Set to 1 or 3 as defined in the table below. )
Requests the FA configuration as set in TWS for the given FA Group or Profile.







faDataType: int. Receive the faDataType value specified in the requestFA. See FA Data Types
faXmlData: String. The xml-formatted configuration. )
Receives the Financial Advisor’s configuration available in the TWS.





reqId: int. Request identifier used to track data.
faDataType: int. The configuration structure to change. Set to 1 or 3 as defined above.
xml: String. XML configuration for allocation profiles or group. See Allocation Method XML Format for more details. )








Note:
In order to confirm that your FA changes were saved, you may wait for the EWrapper.replaceFAEnd callback, which provides the corresponding reqId. In addition, after saving changes, it is advised to verify the new FA setup via EClient.requestFA . If it is called before changes are fully saved, you may receive an error, such as error 10230 . See Message Codes .

EClient.replaceFA only accepts faDataType 1 now. Otherwise, it may trigger error 585 .
reqId: int. Request identifier used to track data.
text: String. the message text.
)
Marks the ending of the replaceFA reception.





A number of methods for account allocations are available with Financial Advisor and IBroker account structures to specify how trades should be distributed across multiple accounts.
Allocation Groups can be created or modified in the Trader Workstation directly as described in TWS: Allocations and Transfers .
Alternatively, allocation groups can be created or modified through the EClient.replaceFA() method in the API.
Interactive Brokers supports two forms of allocation methods. Allocation methods that have calculations completed by Interactive Brokers, and a set of allocation methods calculated by the user and then specified.
Allocation methods for financial advisor’s allocation groups are created using an XML format. The content below signifies the supported allocation groups and how to format them in their respective XML.
Requires you to specify an order size. This method distributes shares based on the amount of available equity in each account. The system calculates ratios based on the Available Equity in each account and allocates shares based on these ratios.

Example: You transmit an order for 700 shares of stock XYZ. The account group includes three accounts, A, B and C with available equity in the amounts of $25,000, $50,000 and $100,000 respectively. The system calculates a ratio of 1:2:4 and allocates 100 shares to Client A, 200 shares to Client B, and 400 shares to Client C.

This method allocates the absolute number of shares you enter to each account listed. If you use this method, the order size is calculated by adding together the number of shares allocated to each account in the profile.

Example:
Assume an order for 300 shares of stock ABC is transmitted.
In the example code shown in the right side, you can see that:

Requires you to specify an order size. This method distributes shares equally between all accounts in the group.

Example: You transmit an order for 400 shares of stock ABC. If your Account Group includes four accounts, each account receives 100 shares. If your Account Group includes six accounts, each account receives 66 shares, and then 1 share is allocated to each account until all are distributed.
The Monetary Amount method calculates the number of units to be allocated based on the monetary value assigned to each account.

Requires you to specify an order size. This method distributes shares based on the net liquidation value of each account. The system calculates ratios based on the Net Liquidation value in each account and allocates shares based on these ratios.

Example: You transmit an order for 700 shares of stock XYZ. The account group includes three accounts, A, B and C with Net Liquidation values of $25,000, $50,000 and $100,000 respectively. The system calculates a ratio of 1:2:4 and allocates 100 shares to Client A, 200 shares to Client B, and 400 shares to Client C.
This method will split the total number of shares in the order between listed accounts based on the percentages you indicate.

Example:
Assume an order for 300 shares of stock ABC is transmitted.
In the example code shown in the right side, you can see that:

While making modifications to allocations for profiles, the method uses an enumerated value. The number shown below demonstrates precisely what profile corresponds to which value.

Note: Do not specify an order size. Since the quantity is calculated by the system, the order size is displayed in the Quantity field after the order is acknowledged. This method increases or decreases an already existing position. Positive percents will increase a position, negative percents will decrease a position. For exmaple, to fully close out a position, you just need to specify percentage to be -100.


This method calculates the allocation of shares based on the ratios you enter.
Example:
Assume an order for 300 shares of stock ABC is transmitted.
In the example code shown in the right side, you can see that:

Advisors can use Model Portfolios to easily invest some or all of a client’s assets into one or multiple custom-created portfolios, rather than tediously managing individual investments in single instruments.
More about Model Portfolios
The TWS API can access model portfolios in accounts where this functionality is available and a specific model has previously been setup in TWS. API functionality allows the client application to request model position update subscriptions, request model account update subscriptions, or place orders to a specific model.
Model Portfolio functionality not available in the TWS API:
To request position updates from a specific model, the function IBApi::EClient::reqPositionsMulti can be used: Position Update Subscription by Model
To request model account updates, there is the function IBApi::EClient::reqAccountUpdatesMulti , see: Account Value Update Subscriptions by Model
To place an order to a model, the IBApi.Order.ModelCode field must be set accordingly, for example:





With TWS/IBGW build 983+, the API settings will have a new flag/checkbox, “Use Account Groups with Allocation Methods” (enabled by default for new users). If not enabled, groups and profiles would behave the same as before. If it is checked, group and profile functionality will be merged.
With TWS/IBGW Build 10.20+, this setting is now enabled by default, and moving forward into new versions, the two systems can be deemed as interchangeable for modifying allocation groups, placing orders, requesting account or portfolio summaries, or requesting multiple positions.
For advisors to place orders to their allocation groups users would simply declare their allocation group name in the order object. This would be done with the Order’s faGroup field. The example to the right references a standard market order placed to our allocation group, MyTestProfile.






Delayed market data can only be used with EClient.reqMktData and EClient.reqHistoricalData . This does not function for tick data.
The API can request Live, Frozen, Delayed and Delayed Frozen market data from Trader Workstation by switching market data type via the EClient.reqMarketDataType before making a market data request. A successful switch to a different (non-live) market data type for a particular market data request will be indicated by a callback to EWrapper.marketDataType with the ticker ID of the market data request which is returning a different type of data.
Free, delayed data is 15 – 20 minutes delayed. In TWS, delayed data is displayed in brown background. When you set market data type to delayed, you are telling TWS to automatically switch to delayed market data if the user does not have the necessary real time data subscription. If live data is available a request for delayed data would be ignored by TWS. Delayed market data is returned with delayed Tick Types (Tick ID 66~76).
1) If user sends reqMarketDataType(1) – TWS will start sending only regular (1) market data.
2) If user sends reqMarketDataType(2) – frozen, TWS will start sending regular (1) as default and frozen (2) market data. TWS sends marketDataType callback (1 or 2) indicating what market data will be sent after this callback. It can be regular or frozen.
3) If user sends reqMarketDataType(3) – delayed, TWS will start sending regular (1) as default and delayed (3) market data.
4) If user sends reqMarketDataType(4) – delayed-frozen, TWS will start sending regular (1) as default, delayed (3) and delayed-frozen (4) market data.
Interactive Brokers data will always try to provide the most up to date market data possible, but will permit additional delayed or frozen data if available upon request.
marketDataType: int. Type of market data to retrieve. )
Switches data type returned from reqMktData request to Live (1), Frozen (2), Delayed (3), or Frozen-Delayed (4).





reqId: int. Request identifier used to track data.
marketDataType: int. Type of market data to retrieve. )





Historical Market data is available for Interactive Brokers market data subscribers in a range of methods and structures. This includes requests for historical bars, identical to the Trader Workstation, historical Time & Sales, as well as Histogram data.
Historical market data has it’s own set of market data limitations unique to other requests such as real time market data. This section will cover all limitations that effect historical market data in the Trader Workstation API.
Historical data at IB is filtered for trade types which occur away from the NBBO such as combo legs, block trades, and derivative trades. For that reason the daily volume from the (unfiltered) real time data functionality will generally be larger than the (filtered) historical volume reported by historical data functionality. Also, differences are expected in other fields such as the VWAP between the real time and historical data feeds.

As historical data at IB gets adjusted, compressed and filtered by default, there may be historical data differences if you request historical data at different time points.
Volume data returned for historical bars can be modified to return in shares or lots.
If the setting is checked, historical volume data will return as a Round Lot .
If the setting is unchecked, historical volume data will return in Shares.

Although Interactive Brokers offers our clients high quality market data, IB is not a specialised market data provider and as such it is forced to put in place restrictions to limit traffic which is not directly associated to trading. A Pacing Violation occurs whenever one or more of the following restrictions is not observed:
Important: these limitations apply to all our clients and it is not possible to overcome them. If your trading strategy’s market data requirements are not met by our market data services please consider contacting a specialized provider.

The other historical data limitations listed are general limitations for all trading platforms:
For many functions, such as EClient.reqHistoricalData, you will need to request market data for a contract. Given that you may not know how long a symbol has been available, you can use EClient.reqHeadTimestamp to find the first available point of data for a given whatToShow value.
ReqHeadTimeStamp counts as an ongoing historical data request, similar to using EClient.reqHistoricalData’s keepUpToDate=True flag. As a result, users should always:
tickerId: int., A unique identifier which will serve to identify the incoming data.
contract: Contract . The IBApi.Contract you are interested in.
whatToShow: String. The type of data to retrieve. See Historical Data Types
useRTH: int. Whether (1) or not (0) to retrieve data generated only within Regular Trading Hours (RTH)
formatDate: int. Using 1 will return UTC time in YYYYMMDD-hh:mm:ss format. Using 2 will return epoch time. )
Returns the timestamp of earliest available historical data for a contract and data type.





requestId: int. Request identifier used to track data.
headTimestamp: String. Value identifying earliest data date )
The data requested will be returned to EWrapper.headTimeStamp.





tickerId: int. Request identifier used to track data. )
A reqHeadTimeStamp request can be cancelled with EClient.cancelHeadTimestamp





Historical Bar data returns a candlestick value based on the requested duration and bar size. This will always return an open, high, low, and close values. Based on which whatToShow value is used, you may also receive volume data. See the whatToShow section for more details.
reqId: int, A unique identifier which will serve to identify the incoming data.
contract: Contract, The IBApi.Contract object you are working with.
endDateTime: String, The request’s end date and time. This should be formatted as “YYYYMMDD HH:mm:ss TMZ” or an empty string indicates current present moment). Please be aware that endDateTime must be left as an empty string when requesting continuous futures contracts.
durationStr: String, The amount of time (or Valid Duration String units) to go back from the request’s given end date and time.
barSizeSetting: String, The data’s granularity or Valid Bar Sizes
whatToShow: String, The type of data to retrieve. See Historical Data Types
useRTH: bool, Whether (1) or not (0) to retrieve data generated only within Regular Trading Hours (RTH)
formatDate: bool, The format in which the incoming bars’ date should be presented. Note that for day bars, only yyyyMMdd format is available.
keepUpToDate: bool, Whether a subscription is made to return updates of unfinished real time bars as they are available (True), or all data is returned on a one-time basis (False). If True , and endDateTime cannot be specified. Supported whatToShow values: Trades, Midpoint, Bid, Ask.
chartOptions: TagValueList, This is a field used exclusively for internal use.
)





The Interactive Brokers Historical Market Data maintains a duration parameter which specifies the overall length of time that data can be collected. The duration specified will derive the bars of data that can then be collected.

Bar sizes dictate the data returned by historical bar requests. The bar size will dictate the scale over which the OHLC/V is returned to the API.

The functionality of market data requests are predicated on preset step sizes. As such, not all bar sizes will work with all duration values. The table listed here will discuss the smallest to largest bar size value for each duration string.
The table below displays the maximum duration values allowed for a given bar.
As an example, the maximum duration for Seconds values supported for 5 seconds bars are 86400 S. This means that if I want to retrieve more than 1 day’s worth of 5 second bars, I will then need to request data in increments of D (days).
Interactive Brokers will return historical market data based on the format set from the request. The formatDate parameter can be provided an integer value to indicate how data should be returned.
Note: Day bars will only return dates in the yyyyMMdd format. Time data is not available.
When using keepUpToDate=True for historical data requests, you will see several bars returned with the same timestamp. This is because data is updated approximately every 1-2 seconds. These updates compound until the end of the specified bar size.
In our example to the below, 15 second bars are requested, and we can see the 30 second bar built out incrementally until 20231204 13:30:30 is completed. At which point, we move on to the 45th second bars. This same logic extends into minute, hourly, or daily bars.
keepUpToDate is only available for whatToShow: Trades, Midpoint, Bid, Ask

reqId: int. Request identifier used to track data.
bar: Bar. The OHLC historical data Bar. The time zone of the bar is the time zone chosen on the TWS login screen. Smallest bar size is 1 second. )
The historical data will be delivered via the EWrapper.historicalData method in the form of candlesticks. The time zone of returned bars is the time zone chosen in TWS on the login screen.





The text on the right is the default formatting for returning data.
The datetime value here was modified to return UTC datetime formatting.
Note: The datetime value indicates the beginning of the request range rather than the end. The last bar on the right would then indicate data that took place between 20241111-16:53:15 to 20241111-16:53:20.
reqId: int. Request identifier used to track data.
startDateTime: String. Returns the start date and time of the historical schedule range.
endDateTime: String. Returns the end date and time of the historical schedule range.
timeZone: String. Returns the time zone referenced by the schedule.
sessions: HistoricalSession[]. Returns the full block of historical schedule data for the duration. )
In the case of whatToShow=”schedule”, you will need to also define the EWrapper.historicalSchedule value. This is a unique method that will only be called in the case of the unique whatToShow value to display calendar information.





reqId: int. Request identifier used to track data.
bar: Bar. The OHLC historical data Bar. The time zone of the bar is the time zone chosen on the TWS login screen. Smallest bar size is 1 second. )
Receives bars in real time if keepUpToDate is set as True in reqHistoricalData. Similar to realTimeBars function, except returned data is a composite of historical data and real time data that is equivalent to TWS chart functionality to keep charts up to date. Returned bars are successfully updated using real time data.





reqId: int. Request identifier used to track data.
start: String. Returns the starting time of the first historical data bar.
end: String. Returns the end time of the last historical data bar. )
Marks the ending of the historical bars reception.





The historical bar types listed below can be used as the whatToShow value for historical bars. These values are used to request different data such as Trades, Midpoint, Bid_Ask data and more. Some bar types support more products than others. Please note the Supported Products section for each bar type below.
Bar Values:
Supported Products: Cryptocurrency
Bar Values:
Supported Products: Bonds, CFDs, Commodities, Cryptocurrencies, ETFs, FOPs, Forex, Funds, Futures,  Metals, Options, SSFs, Stocks, Structured Products, Warrants
Bar Values:
Supported Products: Bonds, CFDs, Commodities, Cryptocurrencies, ETFs, FOPs, Forex, Funds, Futures,  Metals, Options, SSFs, Stocks, Structured Products, Warrants
Bar Values:
Supported Products: Bonds, CFDs, Commodities, Cryptocurrencies, ETFs, FOPs, Forex, Funds, Futures, Metals, Options, SSFs, Stocks, Structured Products, Warrants
Bar Values:
Supported Products: Stocks, ETFs,
Bar Values:
Supported Products: ETFs, Indices, Stocks
Bar Values:
Supported Products: Bonds, CFDs, Commodities, Cryptocurrencies, ETFs, FOPs, Forex, Funds, Futures,  Metals, Options, SSFs, Stocks, Structured Products, Warrants
Bar Values:
Supported Products: ETFs, Indices, Stocks
Bar Values:
Supported Products: Bonds, CFDs, Commodities, Cryptocurrencies, ETFs, Forex, Funds, Futures, Indices, Metals,  SSFs, Stocks, Structured Products, Warrants
NOTE: SCHEDULE data returns only on 1 day bars but returns historical trading schedule only with no information about OHLCV.
Bar Values:
Supported Products: Bonds, ETFs, FOPs, Futures, Indices, Metals, Options, SSFs, Stocks, Structured Products, Warrants
NOTES: TRADES data is adjusted for splits, but not dividends.
Bar Values:
Supported Products: Indices
Note: Yield historical data only available for corporate bonds.
Bar Values:
Supported Products: Indices
Note: Yield historical data only available for corporate bonds.
Bar Values:
Supported Products: Indices
Note: Yield historical data only available for corporate bonds.
Bar Values:
Supported Products: Indices
Note: Yield historical data only available for corporate bonds.
Instead of returned data points as a function of time as with the function IBApi::EClient::reqHistoricalData, histograms return data as a function of price level with function IBApi::EClient::reqHistogramData
requestId: int, id of the request
contract: Contract, Contract object that is subject of query.
useRth: bool, Data from regular trading hours (1), or all available hours (0).
period: String, string value of requested date range. This will be tied to the same bar size strings as the historical bar sizes )
Returns data histogram of specified contract.





requestId: int. Request identifier used to track data.
data: HistogramEntry[]. Returned Tuple of histogram data, number of trades at specified price level. )
Returns relevant histogram data.





tickerId: int. Request identifier used to track data. )
An active histogram request which has not returned data can be cancelled with EClient.cancelHistogramData





The highest granularity of historical data from IB’s database can be retrieved using the API function EClient.reqHistoricalTicks for historical time and sales values. Historical Time & Sales will return the same data as what is available in Trader Workstation under the Time and Sales window. This is a series of ticks indicating each trade based on the requested values.
requestId: int , id of the request
contract: Contract , Contract object that is subject of query.
startDateTime: String , i.e. “20170701 12:01:00”. Uses TWS timezone specified at login.
endDateTime: String , i.e. “20170701 13:01:00”. In TWS timezone. Exactly one of startDateTime or endDateTime must be defined.
numberOfTicks: int , Number of distinct data points. Max is 1000 per request.
whatToShow: String , (Bid_Ask, Midpoint, or Trades) Type of data requested.
useRth: bool , Data from regular trading hours (1), or all available hours (0).
ignoreSize: bool , Omit updates that reflect only changes in size, and not price. Applicable to Bid_Ask data requests. Note: Options and Future Options will only display a value of 1, unless to indicate a removed bid/ask, which will instead return a price and size value of 0.
miscOptions: list, Should be defined as null ; reserved for internal use. )
Requests historical Time & Sales data for an instrument.





Data is returned to unique functions based on what is requested in the whatToShow field.
reqId: int, id of the request
ticks: ListOfHistoricalTick, object containing a list of tick values for the requested timeframe.
done: bool, return whether or not this is the end of the historical ticks requested. )
For whatToShow=MIDPOINT





reqId: int, id of the request
ticks: ListOfHistoricalTick, object containing a list of tick values for the requested timeframe.
done: bool, return whether or not this is the end of the historical ticks requested. )
For whatToShow=BidAsk





reqId: int, id of the request
ticks: ListOfHistoricalTick, object containing a list of tick values for the requested timeframe.
done: bool, return whether or not this is the end of the historical ticks requested. )
For whatToShow=Last & AllLast





The tick attribute pastLimit is also returned with streaming Tick-By-Tick responses. Check Halted and Unhalted ticks section.
When creating dates in the TWS API, Interactive Brokers typically supports three methods:
Operator Time Zone is the local time set by the user in Trader Workstation. The Operator Time Zone typically maintains a unique formatting structure separate from Exchange Time Zones; however, they can match.
A user can confirm their Operator Time Zone by launching Trader Workstation then, before logging in, click “More Options >”.

Users can then confirm their active Operator Time Zone by referencing the “Time Zone” field.
For US residents, this will typically appear as “America/New_York”, “America/Chicago”, or “America/Los_Angeles”. It is essential to note the Time Zone value, as this will be the value supplied when making requests with the Operator Time Zone.

After logging in to Trader Workstation or IB Gateway, you would be able to submit time stamps in the format of “YYYYMMDD HH:mm:ss Operator/Time_Zone”.
Given our prior example, a historical data endDateTime value would appear as”20250101 23:59:59 America/Chicago”. This would mean the latest value I want is just before midnight in Chicago on January 1st, 2025. Even if I am trading contracts in New York or overseas, all historical data requests would be relative to my own time zone.
The exchange Time Zone is the value the exchange itself uses to calculate time. This value is typically unique to the Operator Time Zone, but these values can overlap.
As an example, the New York Stock Exchange operates on “US/Eastern”. However, the CME operates on “US/Central”. This values can be programmatically requested using the EClient.reqContractDetails method, and then received from EWrapper.contractDetails in contractDetails.Time ZoneId.
Note that this will be interpreted differently from “America/Chicago”.

UTC is a time standard centered around Greenwich Mean Time (GMT). UTC historical data can be formatted as “YYYYMMDD-hh:mm:ss”. Please keep in mind this is based on UTC+0, and as a reference, US/Eastern time is approximately UTC-4 or UTC-5 depending on U.S. Daylight savings.
Please note GMT is unaffected by Daylight savings, and so 09:00:00 will be the same time of day year round regardless of the exchange’s or your local daylight savings observation.
You may also log in to the Trader Workstation and modify this in the Global Configuration under API and then Settings. Here, you will find a modifiable setting labeled “Send instrument-specific attributes for dual-mode API client in” Here you can select one of the following:

For all data, besides Delayed Watchlist Data , a paid data subscription is required to receive market data through the API. See the Market Data Subscriptions page for more information.
Live market data and historical bars are currently not available from the API for the exchange OSE . Only 15 minute delayed streaming data will be available for this exchange.
The bid, ask, and last size quotes are displayed in shares instead of lots.
API users have the option to configure the TWS API to work in compatibility mode for older programs, but we recommend migrating to “quotes in shares” at your earliest convenience.
To display quotes as lots, from the Global Configuration > API > Settings page, check “Bypass US Stocks market data in shares warning for API orders.”

Real time and historical data functionality is combined through the EClient.reqRealTimeBars request. reqRealTimeBars will create an active subscription that will return a single bar in real time every five seconds that has the OHLC values over that period. reqRealTimeBars can only be used with a bar size of 5 seconds.
Important: real time bars subscriptions combine the limitations of both, top and historical market data. Make sure you observe Market Data Lines and Pacing Violations for Small Bars (30 secs or less) . For example, no more than 60 *new* requests for real time bars can be made in 10 minutes, and the total number of active active subscriptions of all types cannot exceed the maximum allowed market data lines for the user.
tickerId: int. Request identifier used to track data.
contract: Contract. The Contract object for which the depth is being requested
barSize: int. Currently being ignored
whatToShow: String. The nature of the data being retrieved: Available Values: TRADES, MIDPOINT, BID, ASK
useRTH: int. Set to 0 to obtain the data which was also generated outside of the Regular Trading Hours, set to 1 to obtain only the RTH data )
realTimeBarOptions : List<TagValue>. Internal use only.

Requests real time bars.
Only 5 seconds bars are provided. This request is subject to the same pacing as any historical data request: no more than 60 API queries in more than 600 seconds.
Real time bars subscriptions are also included in the calculation of the number of Level 1 market data subscriptions allowed in an account.

Code example:





reqId: int. Request identifier used to track data.
time: long. The bar’s start date and time (Epoch/Unix time)
open: double. The bar’s open point
high: double. The bar’s high point
low: double. The bar’s low point
close: double. The bar’s closing point
volume: decimal. The bar’s traded volume (only returned for TRADES data)
WAP: decimal. The bar’s Weighted Average Price rounded to minimum increment (only available for TRADES).
count: int. The number of trades during the bar’s timespan (only available for TRADES). )
Receives the real time 5 second bars.





tickerId: int. Request identifier used to track data. )
Cancels Real Time Bars’ subscription.





A single data request from the API can receive aggregate quotes from multiple exchanges. The tick types ‘bidExch’ (tick type 32), ‘askExch’ (tick type 33), ‘lastExch’ (tick type 84) are used to identify the source of a quote. To preserve bandwidth, the data returned to these tick types consists of a sequence of capital letters rather than a long list of exchange names for every returned exchange name field. To find the full exchange name corresponding to a single letter code returned in tick types 32, 33, or 84, and API function IBApi:: EClient::reqSmartComponents is available. Note: This function can only be used when the exchange is open.
Different IB contracts have a different exchange map containing the set of exchanges on which they trade. Each exchange map has a different code, such as “a6” or “a9”. This exchange mapping code is returned to EWrapper.tickReqParams immediately after a market data request is made by a user with market data subscriptions. To find a particular map of single letter codes to full exchange names, the function reqSmartComponents is invoked with the exchange mapping code returned to tickReqParams.
For instance, a market data request for the IBKR US contract may return the exchange mapping identifier “a6” to EWrapper.tickReqParams . Invoking the function EClient.reqSmartComponents with the symbol “a9” will reveal the list of exchanges offering market data for the IBKR US contract, and their single letter codes. The code for “ARCA” may be “P”. In that case if “P” is returned to the exchange tick types, that would indicate the quote was provided by ARCA.
reqId: int. Request identifier used to track data.
bboExchange: String. Mapping identifier received from EWrapper.tickReqParams )
Returns the mapping of single letter codes to exchange names given the mapping identifier.





reqId: int. Request identifier used to track data.
smartComponentMap: SmartComponentMap. Unique object containing a map of all key-value pairs )
Containing a bit number to exchange + exchange abbreviation dictionary. All IDs can be initially retrieved using reqTickParams .





To check which exchanges offer deep book data, the function EClient.reqMktDepthExchanges can be invoked. It will return a list of exchanges from where market depth is available if the user has the appropriate market data subscription.
API ‘Exchange’ fields for which a market depth request would return market maker information and result in a callback to EWrapper.updateMktDepthL2 will be indicated in the results from the  EWrapper.mktDepthExchanges field by a ‘True’ value in the ‘isL2’ field:
Requests venues for which market data is returned to updateMktDepthL2 (those with market makers).





depthMktDataDescriptions: DepthMktDataDescription[]. A list containing all available exchanges offering market depth. )
Called when receives Depth Market Data Descriptions.





Market depth data, also known as level II, represents an instrument’s order book. Via the TWS API it is possible to obtain this information with the EClient.reqMarketDepth function.
Unlike Top Market Data (Level I) , market depth data is sent without sampling or filtering, however we cannot guarantee that every price quoted for a particular security will be displayed. In particular, odd lot orders are not included.
It is possible to Smart-route a EClient.reqMarketDepth request to receive aggregated data from all available exchanges.
An integral part of processing the incoming data is monitoring EWrapper.error for message 317 “Market depth data has been RESET. Please empty deep book contents before applying any new entries.” and handling it appropriately, otherwise the update process would be corrupted.
Market Depth is not support for Calendar Spreads or Combos.
Important: Please note that the languages use different method names for requesting market depth.
The C# and Visual Basic APIs use reqMarketDepth() .
The Python, Java, and C++ APIs use reqMktDepth() .
tickerId: int. Request identifier used to track data.
contract: Contract. The Contract for which the depth is being requested.
numRows: int. The number of rows on each side of the order book.
isSmartDepth: bool. Flag indicates that this is a Smart-routed market depth request. Supplying true will return data identical to the TWS Book Trader while False returns direct routed data similar to the TWS Market Depth tool .
mktDepthOptions: List. Internal use only. Leave an empty array or None type. )
Requests the contract’s market depth (order book).





tickerId: int. Request identifier used to track data.
position: int. The order book’s row being updated
operation: int. Indicates a change in the row’s value.:
side: int. 0 for ask, 1 for bid
price: double. The order’s price
size: decimal. The order’s size )
Returns the order book. Used for direct routed requests only.





tickerId: int. Request identifier used to track data.
position: int. The order book’s row being updated.
marketMaker: String. The exchange holding the order if isSmartDepth is True, otherwise the MPID of the market maker.
operation: int. Indicates a change in the row’s value.:
side: int. 0 for ask, 1 for bid
price: double. The order’s price
size: decimal. The order’s size
isSmartDepth: bool. Flag indicating if this is smart depth response (True) or the MPID of the market maker. )
Returns the order book.





tickerId: int. Request identifier used to track data.
isSmartDepth: bool. Flag indicates that this is smart depth request.
)
Cancel’s market depth’s request.





The option greek values- delta, gamma, theta, vega- are returned by default following a reqMktData() request for the option. See Available Tick Types
Tick types “Bid Option Computation” (#10), “Ask Option Computation” (#11), “Last Option Computation” (#12), and “Model Option Computation” (#13) return all Greeks (delta, gamma, vega, theta), the underlying price and the stock and option reference price when requested.
MODEL_OPTION_COMPUTATION also returns model implied volatility.
Note that to receive live greek values it is necessary to have market data subscriptions for both the option and the underlying contract.
The implied volatility for an option given its price and the price of the underlying can be calculated with the function EClient.calculateImpliedVolatility.
Alternatively, given the price of the underlying and an implied volatility it is possible to calculate the option price using the function EClient.calculateOptionPrice.
After the request, the option specific information will be delivered via the EWrapper.tickOptionComputation method.
reqId: int. Request identifier for tracking data.
contract: Contract. Contract object used for specifying an instrument.
genericTickList: String. Comma separated ids of the available generic ticks.
snapshot: bool. Set to True for snapshot data with a relevant subscription or False for live data.
regulatorySnapshot: bool. Set to True for a paid, regulatory snapshot or False for live data.
mktDataOptions: List<TagValue>. Internal use only. )
Greeks are requested automatically when pulling market data for an Options contract. Users that do not have a valid Market Data Subscription for the underlying contract will receive an error that Market Data Is Not Subscribed. This error can be ignored if Greeks are not wanted.




reqId: int. Request identifier used to track data.
contract: Contract. The Contract object for which the depth is being requested
volatility: double. Hypothetical volatility.
underPrice: double. Hypothetical option’s underlying price.
optionPriceOptions: List<TagValue>. Internal use only. Send an empty tag value list. )
Calculates an option’s price based on the provided volatility and its underlying’s price.





reqId: int. Request identifier used to track data.
contract: Contract. The Contract object for which the depth is being requested
optionPrice: double. Hypothetical option price.
underPrice: double. Hypothetical option’s underlying price.
impliedVolatilityOptions: List<TagValue>. Internal use only. Send an empty tag value list. )
Calculate the volatility for an option. Request the calculation of the implied volatility based on hypothetical option and its underlying prices.





tickerId the request’s unique identifier.
field: int. Specifies the type of option computation. Pass the field value into TickType.getField(int tickType) to retrieve the field description. For example, a field value of 13 will map to modelOptComp, etc. 10 = Bid 11 = Ask 12 = Last
tickAttrib: int. 0 – return based, 1- price based.
impliedVolatility: double. the implied volatility calculated by the TWS option modeler, using the specified tick type value.
delta: double. The option delta value.
optPrice: double. The option price.
pvDividend: double. The present value of dividends expected on the option’s underlying.
gamma: double. The option gamma value.
vega: double. The option vega value.
theta: double. The option theta value.
undPrice: double. The price of the underlying. )
Receives option specific market data. This method is called when the market in an option or its underlier moves. TWS’s option model volatilities, prices, and deltas, along with the present value of dividends expected on that options underlier are received.





Streaming market data values corresponding to data shown in TWS watchlists is available via the EClient.reqMktData. This data is not tick-by-tick but consists of aggregate snapshots taken several times per second. A set of ‘default’ tick types are returned by default from a call to EClient.reqMktData, and additional tick types are available by specifying the corresponding generic tick type in the market data request. Including the generic tick types many, but not all, types of data are available that can be displayed in TWS watchlists by adding additional columns.
Using the TWS API, you can request real time market data for trading and analysis. From the API, market data returned from the function IBApi.EClient.reqMktData corresponds to market data displayed in TWS watchlists. This data is not tick-by-tick but consists of aggregated snapshots taken at intra-second intervals which differ depending on the type of instrument:
reqId: int. Request identifier for tracking data.
contract: Contract. Contract object used for specifying an instrument.
genericTickList : String. Comma separated ids of the available generic ticks.
snapshot: bool. Used to retrieve a single snapshot of data for those with an existing market data subscirption.
regulatorySnapshot: bool. Used to retrieve a single snapshot of paid data. Each snapshot costs $0.01. See here for more information about Regulatory Snapshots and Market Data.
mktDataOptions: List<TagValue>. Internal use only. )
Requests real time market data. Returns market data for an instrument either in real time or 10-15 minutes delayed data.





Watchlist market data at Interactive Brokers is derived from time-based snapshot intervals which vary by product and region. This means that a given tick will only update as frequently as its interval allows. See the table for more details on product specifics.
The most common tick types are delivered automatically after a successful market data request. There are however other tick types available by explicit request: the generic tick types. When invoking IBApi.EClient.reqMktData, specific generic ticks can be requested via the genericTickList parameter of the function:
See the Available Tick Types section for more information on generic ticks.
With an exchange market data subscription, such as Network A (NYSE), Network B(ARCA), or Network C(NASDAQ) for US stocks, it is possible to request a snapshot of the current state of the market once instead of requesting a stream of updates continuously as market values change. By invoking the EClient.reqMktData function passing in true for the snapshot parameter, the client application will receive the currently available market data once before a EWrapper.tickSnapshotEnd event is sent 11 seconds later. Snapshot requests can only be made for the default tick types; no generic ticks can be specified. It is important to note that a snapshot request will only return available data over the 11 second span; in some cases values may not be returned for all tick types.
tickerId: int. Request identifier used to track data. )
When requesting market data snapshots, this market will indicate the snapshot reception is finished. Expected to occur 11 seconds after beginning of request.





The fifth argument to reqMktData specifies a regulatory snapshot request to US stocks and options.
For stocks, there are individual exchange-specific market data subscriptions necessary to receive streaming quotes. For instance, for NYSE stocks this subscription is known as “Network A”, for ARCA/AMEX stocks it is called “Network B” and for NASDAQ stocks it is “Network C”. Each subscription is added a la carte and has a separate market data fee.
Alternatively, there is also a “US Securities Snapshot Bundle” subscription which does not provide streaming data but which allows for real time calculated snapshots of US market NBBO prices. By setting the 5th parameter in the function EClient::reqMktData to True , a regulatory snapshot request can be made from the API. The returned value is a calculation of the current market state based on data from all available exchanges.
Important: Each regulatory snapshot made will incur a fee of 0.01 USD to the account. This applies to both live and paper accounts. . If the monthly fee for regulatory snapshots reaches the price of a particular ‘Network’ subscription, the user will automatically be subscribed to that Network subscription for continuous streaming quotes and charged the associated fee for that month. At the end of the month the subscription will be terminated. Each listing exchange will be capped independently and will not be combined across listing exchanges.
Requesting regulatory snapshots is subject to pacing limitations:
The following table lists the cost and maximum allocation for regulatory snapshot quotes:
Note: Please be aware that in the event subsequent orders are received with the same price value, but different size values, no new tickPrice value should be returned. Only an updated tickSize will denote that a new order was retrieved with the assumption the last tickPrice value will also correlate with the new size.
tickerId: int. Request identifier used to track data.
field: int. The type of tick being received.
value: double. Return value corresponding to value. See Available Tick Types for more details. )
Returns generic data back to requester. Used for an array of tick types and is used to represent general evaluations.





tickerId: int. Request identifier used to track data.
tickType: int. The type of the price being received (See Tick ID field in Available Tick Types ).
price: double. The monetary value for the given tick type.
attribs: TickAttrib. A TickAttrib object that contains price attributes such as TickAttrib::CanAutoExecute, TickAttrib::PastLimit and TickAttrib::PreOpen. )
Market data tick price callback. Handles all price related ticks. Every tickPrice callback is followed by a tickSize. A tickPrice value of -1 or 0 followed by a tickSize of 0 indicates there is no data for this field currently available, whereas a tickPrice with a positive tickSize indicates an active quote of 0 (typically for a combo contract).





tickerId: int. Request identifier used to track data.
field: int. the type of size being received (i.e. bid size)
size: int. the actual size. US stocks have a multiplier of 100. )
Market data tick size callback. Handles all size-related ticks.





tickerId: int. Request identifier used to track data.
field: int. The type of the tick being received
value: String. Variable containining message response. )
Market data callback.
Note: Every tickPrice is followed by a tickSize. There are also independent tickSize callbacks anytime the tickSize changes, and so there will be duplicate tickSize messages following a tickPrice.





A market data request is able to return data from multiple exchanges. After a market data request is made for an instrument covered by market data subscriptions, a message will be sent to function IBApi::EWrapper::tickReqParams with information about ‘minTick’, BBO exchange mapping, and available snapshot permissions.
The exchange mapping identifier bboExchange will be a symbol such as “a6” which can be used to decode the single letter exchange abbreviations returned to the bidExch, askExch, and lastExch fields by invoking the function IBApi::EClient::reqSmartComponents. More information about Component Exchanges.
The minTick returned to tickReqParams indicates the minimum increment in market data values returned to the API. It can differ from the minTick value in the ContractDetails class. For instance, combos will often have a minimum increment of 0.01 for market data and a minTick of 0.05 for order placement.
tickerId: int. Request identifier used to track data.
minTick: Minimum tick for the contract on the exchange.
bboExchange: String. Exchange offering the best bid offer.
snapshotPermissions: Based on the snapshot parameter in EClient.reqMktData. )
Displays the ticker with BBO exchange.





IB does not provide market data for certain types of instruments, such as stock CFDs and forex CFDs. If a stock CFD or forex CFD is entered into a TWS watchlist, TWS will automatically display market data for the underlying ticker and show a ‘U’ icon next to the instrument name to indicate that the data is for the underlying instrument.
From the API, when level 1 or level 2 market data is requested for a stock CFD or a forex CFD, a callback is made to the functions EWrapper.rerouteMktDataReq or EWrapper.rerouteMktDepthReq respectively with details about the underlying instrument in IB’s database which does have market data.
reqId: int. Request identifier used to track data.
conId: int. Contract identifier of the underlying instrument which has market data.
exchange: int. Primary exchange of the underlying. )
Returns conid and exchange for CFD market data request re-route.





reqId: int. Request identifier used to track data.
conId: int. Contract identifier of the underlying instrument which has market data.
exchange: int. Primary exchange of the underlying. )
Returns the conId and exchange for an underlying contract when a request is made for level 2 data for an instrument which does not have data in IB’s database. For example stock CFDs and index CFDs.





tickerId: int. Request identifier used to track data. )
Cancels a watchlist market data request.





EClient.reqMktData will return data to various methods such as EWrapper.tickPrice, EWrapper.tickSize, EWrapper.tickString, etc. The values returned are dependent upon the generic tick requested and the type of data returned. The table below references which tick ID will be returned upon requesting a given generic tick.
*RDD: These tick types are provided only when the user makes a request to EClient.reqMarketDataType(3) prior to their market data request.
– : These ticks are returned by default and do not have any generic tick requirements.
The Halted tick type indicates if a contract has been halted for trading. It can have the following values:
The shortable tick is an indicative on the amount of shares which can be sold short for the contract:
Receiving the actual number of shares available to short requires TWS 974+. For detailed information about shortability data (shortable shares, fee rate) available outside of TWS, IB also provides an FTP site. For more information on the FTP site, see knowledge base article 2024
The API reports the current day’s volume in several ways. They are summarized as follows:
The RT Volume tick type corresponds to the TWS’ Time & Sales window and contains the last trade’s price, size and time along with current day’s total traded volume, Volume Weighted Average Price (VWAP) and whether or not the trade was filled by a single market maker.
There is a setting in TWS which displays tick-by-tick data in the TWS Time & Sales Window. If this setting is checked, it will provide a higher granularity of data than RTVolume.
Example: 701.28;1;1348075471534;67854;701.46918464;true
As volume for US stocks is reported in lots, a volume of 0 reported in RTVolume will typically indicate an odd lot data point (less than 100 shares).
It is important to note that while the TWS Time & Sales Window also has information about trade conditions available with data points, this data is not available through the API. So for instance, the ‘unreportable’ trade status displayed with points in the Time & Sales Window is not available through the API, and that trade data will appear in the API just as any other data point. As always, an API application needs to exercise caution in responding to single data points.
Note: Please be aware that RT Volume is not supported with Cryptocurrencies.
RT Trade Volume
The RT Trade Volume is similar to RT Volume, but designed to avoid relaying back “Unreportable Trades” shown in TWS Time&Sales via the API. RT Trade Volume will not contain average price or derivative trades which are included in RTVolume.
This tick type provides four different comma-separated elements:
Example: 0.83,0.92,20130219,0.23
To receive dividend information it is sometimes necessary to direct-route rather than smart-route market data requests.
In TWS, tick-by-tick data is available in the Time & Sales Window.
The maximum number of simultaneous tick-by-tick subscriptions allowed for a user is 5% of the user’s total market data lines. See Specialized Market Data Lines for more information.
Real time tick-by-tick data is currently not available for options. Historical tick-by-tick data is available.
The tick type field is case sensitive – it must be BidAsk, Last, AllLast, MidPoint. AllLast has additional trade types such as combos, derivatives, and average price trades which are not included in Last.
reqId: int. unique identifier of the request.
contract: Contract. the contract for which tick-by-tick data is requested.
tickType: String. tick-by-tick data type: “Last”, “AllLast”, “BidAsk” or “MidPoint”.
numberOfTicks: int. If a non-zero value is entered, then historical tick data is first returned via one of the Historical Time and Sales Ewrapper Methods respectively. (Max number of historical Ticks is 1000)
ignoreSize: bool. Omit updates that reflect only changes in size, and not price. Applicable to Bid_Ask data requests . )
Requests tick by tick or Time & Sales data.

Note:
EClient.reqTickByTickData() uses Max Market Depth (Level II) data lines, instead of market data lines (Level I). For market data lines, please check: https://www.interactivebrokers.com/campus/ibkr-api-page/market-data-subscriptions/#market-data-lines





reqId: int. unique identifier of the request.
tickType: int. 0: “Last” or 1: “AllLast”.
time: long. tick-by-tick real-time tick timestamp.
price: double. tick-by-tick real-time tick last price.
size: decimal. tick-by-tick real-time tick last size.
tickAttribLast: TickAttribLast. tick-by-tick real-time last tick attribs (bit 0 – past limit, bit 1 – unreported).
exchange: String. tick-by-tick real-time tick exchange.
specialConditions: String. tick-by-tick real-time tick special conditions. Conditions under which the operation took place (Refer to Trade Conditions Page ) )
Returns “Last” or “AllLast” tick-by-tick real-time tick.





reqId: int. unique identifier of the request.
time: long. timestamp of the tick.
bidPrice: double. bid price of the tick.
askPrice: double. ask price of the tick.
bidSize: decimal. bid size of the tick.
askSize: decimal. ask size of the tick.
tickAttribBidAsk: TickAttribBidAsk. tick-by-tick real-time bid/ask tick attribs (bit 0 – bid past low, bit 1 – ask past high). )
Returns “BidAsk” tick-by-tick real-time tick.





reqId: int. Request identifier used to track data.
time: long. Timestamp of the tick.
midPoint: double. Mid point value of the tick. )
Returns “MidPoint” tick-by-tick real-time tick.





requestId: int. Request identifier used to track data. )
Cancels specified tick-by-tick data.





The Tick-By-Tick attribute has been introduced. The tick attribute pastLimit is also returned with historical Tick-By-Tick responses.
Some scans in the TWS Advanced Market Scanner can be accessed via the TWS API through the EClient.reqScannerSubscription.
Results are delivered via EWrapper.scannerData and the EWrapper.scannerDataEnd marker will indicate when all results have been delivered. The returned results to scannerData simply consist of a list of contracts. There are no market data fields (bid, ask, last, volume, …) returned from the scanner, and so if these are desired they have to be requested separately with the reqMktData function. Since the scanner results do not include any market data fields, it is not necessary to have market data subscriptions to use the API scanner. However to use filters, market data subscriptions are generally required.
Since the EClient.reqScannerSubscription request keeps a subscription open you will keep receiving periodic updates until the request is cancelled via EClient.cancelScannerSubscription :
Scans are limited to a maximum result of 50 results per scan code, and only 10 API scans can be active at a time.
scannerSubscriptionFilterOptions has been added to the API to allow for generic filters. This field is entered as a list of TagValues which have a tag followed by its value, e.g. TagValue(“usdMarketCapAbove”, “10000”) indicates a market cap above 10000 USD. Available filters can be found using the EClient.reqScannerParameters function.
A string containing all available XML-formatted parameters will then be returned via EWrapper.scannerParameters.
Important: remember the TWS API is just an interface to the TWS. If you are having problems defining a scanner, always make sure you can create a similar scanner using the TWS’ Advanced Market Scanner .
A string containing all available XML-formatted parameters will then be returned via EWrapper.scannerParameters.
Requests an XML list of scanner parameters valid in TWS.





xml: String. The xml-formatted string with the available parameters. )
Provides the xml-formatted parameters available from TWS market scanners (not all available in API).





All values used for the ScannerSubscription object are pulled from EClient.scannerParams response. The XML tree will relay a tree containing a corresponding code to each ScannerSubscription field as documented below.
instrument: <ScanParameterResponse> <InstrumentList> <Instrument> <type>
Location Code: <ScanParameterResponse> <LocationTree> <Location> <LocationTree> <Location> <locationCode>
Scan Code: <ScanParameterResponse> <ScanTypeList> <ScanType> <scanCode>
Subscription Options should be an empty array of TagValues.
Filter Options: <ScanParameterResponse> <FilterList> <RangeFilter> <AbstractField> <code>


Instrument: String. Instrument Type to use.
Location Code: String. Country or region for scanner to search.
Scan Code: String. Value for scanner to sort by.
Subscription Options: Array of TagValues. For internal use only.
Filter Options: Array of TagValues. Contains an array of TagValue objects which filters the scanner subscription.
reqId: int. Request identifier used for tracking data.
subscription: ScannerSubscription. Object containing details on what values should be used to construct and sort the list.
scannerSubscriptionOptions: List. Internal use only.
scannerSubscriptionFilterOptions: List. List of values used to filter the results of the scanner subscription. May result in an empty scanner response from over-filtering. )
Starts a subscription to market scan results based on the provided parameters.





reqid: int. Request identifier used to track data.
rank: int. The ranking position of the contract in the scanner sort.
contractDetails: ContractDetails. Contract object of the resulting object.
distance: String. Internal use only.
benchmark: String. Internal use only.
projection: String. Internal use only.
legStr: String. Describes the combo legs when the scanner is returning EFP )
Provides the data resulting from the market scanner request.





tickerId: int. Request identifier used to track data. )
Cancels the specified scanner subscription using the tickerId.





API news requires news subscriptions that are specific to the API; most news services in TWS are not also available in the API. There are three API news services enabled in accounts by default and available from the API. They are:
There are also four additional news services available with all TWS versions which require API-specific subscriptions to first be made in Account Management. They have different data fees than the subscription for the same news in TWS-only. As with all subscriptions, they only apply to the specific TWS username under which they were made:
The API functions which handle news are able to query available news provides, subscribe to news in real time to receive headlines as they are released, request specific news articles, and return a historical list of news stories that are cached in the system.
Adding or removing API news subscriptions from an account is accomplished through Account Management. From the API, currently subscribed news sources can be retrieved using the function IBApi::EClient::reqNewsProviders. A list of available subscribed news sources is returned to the function IBApi::EWrapper::newsProviders
Requests news providers which the user has subscribed to.





newsProviders: NewsProviders[]. Unique array containing all available news sources. )
Returns array of subscribed API news providers for this user





Important: in order to obtain news feeds via the TWS API you need to acquire the relevant API-specific subscriptions via your Account Management.
News articles provided through the API may not correspond to what is available directly through the Trader Workstation. Off-platform distribution of data is at the discretion of the news source provider, not by Interactive Brokers.
When invoking IBApi.EClient.reqMktData, for a specific IBApi.Contract you will follow the same format convention as any other basic contracts. The News Source is identified by the genericTickList argument.
Note: The error message “invalid tick type” will be returned if the username has not added the appropriate API news subscription.
Note : For Briefing Trader live head lines via the API is only offered on a case-by-case basis directly from Briefing.com offers Briefing Trader subscribers access to the subscription live head lines via the API. For more information and to submit an API entitlement application, please contact Briefing.com directly at dbeasley@briefing.com .
reqId: int. Request identifier for tracking data.
contract: Contract. Contract object used for specifying an instrument.
genericTickList: String. Comma separated ids of the available generic ticks.
snapshot: bool. Always set to false for news data.
regulatorySnapshot: bool. Always set to false for news data.
mktDataOptions: List<TagValue>. Internal use only. )
Used to request market data typically, but can also be used to retrieve news. “mdoff” can be specified to disable standard market data while retrieving news. For news sources, genericTick 292 needs to be specified followed by a colon and the news provider’s code.





For BroadTape News you specify the contract for the specific news source. This is uniquely identified by the symbol and exchange. The symbol of an instrument can easily be obtained via the EClientSocket.reqContractDetails request.
The symbol is typically the provider code, a colon, then the news provider codes appended with “_ALL”





reqId: int. Request identifier for tracking data.
contract: Contract. Contract object used for specifying an instrument.
genericTickList: String. Comma separated ids of the available generic ticks.
snapshot: bool. Always set to false for news data.
regulatorySnapshot: bool. Always set to false for news data.
mktDataOptions: List<TagValue>. Internal use only. )
Used to request market data typically, but can also be used to retrieve news. “mdoff” can be specified to disable standard market data while retrieving news.
For news sources, genericTick 292 needs to be specified.





tickerId: int. Request identifier used to track data.
timeStamp: int. Epoch time of the article’s published time.
providerCode: String. News provider code based on requested data.
articleId: String. Identifier used to track the particular article. See News Article for more.
headline: String. Headline of the provided news article.
extraData: String. Returns any additional data available about the article. )
Returns news headlines for requested contracts.





With the appropriate API news subscription, historical news headlines can be requested from the API using the function EClient::reqHistoricalNews. The resulting headlines are returned to EWrapper::historicalNews.
requestId: int. Request identifier used to track data.
conId: int. Contract id of ticker. See Contract Details for how to retrieve conId.
providerCodes: String. A ‘+’-separated list of provider codes.
startDateTime: String. Marks the (exclusive) start of the date range. The format is yyyy-MM-dd HH:mm:ss.
endDateTime: String. Marks the (inclusive) end of the date range. The format is yyyy-MM-dd HH:mm:ss.
totalResults: int. The maximum number of headlines to fetch (1 – 300)
historicalNewsOptions: Null. Reserved for internal use. Should be defined as null. )
Requests historical news headlines.





requestId: int. Request identifier used to track data.
time: int. Epoch time of the article’s published time.
providerCode: String. News provider code based on requested data.
articleId: String. Identifier used to track the particular article. See News Article for more.
headline: String. Headline of the provided news article. )
Returns news headlines for requested contracts.





requestId: int. Request identifier used to track data.
hasMore: bool. Returns whether there is more data (true) or not (false). )
Returns news headlines end marker





After requesting news headlines using one of the above functions, the body of a news article can be requested with the article ID returned by invoking the function IBApi::EClient::reqNewsArticle. The body of the news article is returned to the function IBApi::EWrapper::newsArticle.
requestId: int. id of the request.
providerCode: String. Short code indicating news provider, e.g. FLY.
articleId: String. Id of the specific article.
newsArticleOptions: List. Reserved for internal use. Should be defined as null. )
Requests news article body given articleId.





requestId: int. Request identifier used to track data.
articleType: int. The type of news article (0 – plain text or html, 1 – binary data / pdf).
articleText: String. The body of article (if articleType == 1, the binary data is encoded using the Base64 scheme). )
Called when receiving a News Article in response to reqNewsArticle().





The nextValidId event provides the next valid identifier needed to place an order. It is necessary to use an order ID with new orders which is greater than all previous order IDs used to place an order. While requests such as EClient.reqMktData will not increment the minimum request ID value, more than one market data request cannot use the same request ID at the same time.
The nextValidId value may be queried on each request. However, it is often recommended to make a request once at the beginning of the session, and then locally increment the value for each request.
numIds: int. This parameter will not affect the value returned to nextValidId but is required. )
Requests the next valid order ID at the current moment be returned to the EWrapper.nextValidId function.





orderId: int. Receives next valid order id. )
Will be invoked automatically upon successful API client connection, or after call to EClient.reqIds.





The next valid identifier is persistent between TWS sessions.
If necessary, you can reset the order ID sequence within the API Settings dialogue. Note however that the order sequence Id can only be reset if there are no active API orders.

Each TWS API connection maintains its own ClientID to the host through the EClient.connect function. There are two unique client ID behaviors developers must be aware of:
The Master ClientID value can be assigned to 0 so that a connection can retrieve orders placed from TWS, FIX sessions, and all API connections on the account.

When an order is filled either fully or partially, the IBApi.EWrapper.execDetails and IBApi.EWrapper.commissionReport events will deliver IBApi.Execution and IBApi.CommissionAndFeesReport objects. This allows to obtain the full picture of the order’s execution and the resulting commissions.
commissionAndFeesReport: CommissionAndFeesReport . Returns a commissions report object containing the fields execId, commission, currency, realizedPnl, yield, and yieldRedemptionDate. )
Provides the Commission Report of an Execution





IBApi.Execution and IBApi.CommissionReport can be requested on demand via the IBApi.EClient.reqExecutions method which receives a IBApi.ExecutionFilter object as parameter to obtain only those executions matching the given criteria. An empty IBApi.ExecutionFilter object can be passed to obtain all previous executions.
Once all matching executions have been delivered, an IBApi.EWrapper.execDetailsEnd event will be triggered.
Important: By default, only those executions occurring since midnight for that particular account will be delivered. If you want to request executions from the last 7 days, TWS’s Trade Log setting “Show trades for …” must be adjusted to your requirement. The IB Gateway is limited to only executions from the current trading day since midnight.
If a correction to an execution is published it will be received as an additional IBApi.EWrapper.execDetails callback with all parameters identical except for the execID in the Execution object. The execID will differ only in the digits after the final period.
By default, most ExecID values will return as 4-segment alphanumeric sequence to identify each unique order. In the case of Combo orders, you may encounter a 5-segment alphanumeric sequence which will be used to denote per-leg executions. As an example, if a 1:1 combo for 200 shares of both contracts is placed, the first leg may fill for 200 shares, then leg 2 may fill for 100 in one execution, and then another execution for leg 2 of 100. The fifth segment will distinguish between these unique inner-combo executions.
The Execution object is used to maintain all data related to a user’s traded orders. This can be used in both querying execution details and navigating received data. The details provided will display all information pertaining to the execution, including how many shares were filled, the price of the execution, and what time it took place.
OrderId: int. The API client’s order Id. May not be unique to an account.
ClientId: int. The API client identifier which placed the order which originated this execution.
ExecId: String. The execution’s identifier. Each partial fill has a separate ExecId. A correction is indicated by an ExecId which differs from a previous ExecId in only the digits after the final period, e.g. an ExecId ending in “.02” would be a correction of a previous execution with an ExecId ending in “.01”.
Time: String. The execution’s server time.
AcctNumber: String. The account to which the order was allocated.
Exchange: String. The exchange where the execution took place.
Side: String. Specifies if the transaction was buy or sale BOT for bought, SLD for sold.
Shares: decimal. The number of shares filled.
Price: double. The order’s execution price excluding commissions.
PermId: int. The TWS order identifier. The PermId can be 0 for trades originating outside IB.
Liquidation: int. Identifies whether an execution occurred because of an IB-initiated liquidation.
CumQty: decimal. Cumulative quantity. Used in regular trades, combo trades and legs of the combo.
AvgPrice: double. Average price. Used in regular trades, combo trades and legs of the combo. Does not include commissions.
OrderRef: String. The OrderRef is a user-customizable string that can be set from the API or TWS and will be associated with an order for its lifetime.
EvRule: String. The Economic Value Rule name and the respective optional argument. The two values should be separated by a colon. For example, aussieBond:YearsToExpiration=3. When the optional argument is not present, the first value will be followed by a colon.
EvMultiplier: double. Tells you approximately how much the market value of a contract would change if the price were to change by 1. It cannot be used to get market value by multiplying the price by the approximate multiplier.
ModelCode: String. model code
LastLiquidity: Liquidity. The liquidity type of the execution.
pendingPriceRevision: bool. Describes if the execution is still pending price revision.
Given additional structures for executions are ever evolving, it is recommended to review the relevant Execution class in your programming language for a comprehensive review of what fields are available.
reqId: int. The request’s unique identifier.
filter: ExecutionFilter. The filter criteria used to determine which execution reports are returned. )
Requests current day’s (since midnight) executions and commission report matching the filter. Only the current day’s executions can be retrieved.





reqId: int. The request’s identifier.
contract: Contract. The Contract of the Order.
execution: Execution. The Execution details. )
Provides the executions which happened in the last 24 hours.





reqId: int. The request’s identifier )
Indicates the end of the Execution reception.





orderId: int. The order’s unique id
contract: Contract. The order’s Contract.
order: Order. The currently active Order.
orderState: OrderState. The order’s OrderState )
Feeds in currently open orders.





Notifies the end of the open orders’ reception.





orderId: int. The order’s client id.
status: String. The current status of the order.
filled: decimal. Number of filled positions.
remaining: decimal. The remnant positions.
avgFillPrice: double. Average filling price.
permId: int. The order’s permId used by the TWS to identify orders.
parentId: int. Parent’s id. Used for bracket and auto trailing stop orders.
lastFillPrice: double. Price at which the last positions were filled.
clientId: int. API client which submitted the order.
whyHeld: String. this field is used to identify an order held when TWS is trying to locate shares for a short sell. The value used to indicate this is ‘locate’.
mktCapPrice: double. If an order has been capped, this indicates the current capped price. )
Gives the up-to-date information of an order every time it changes. Often there are duplicate orderStatus messages.





As long as an order is active, it is possible to retrieve it using the TWS API. Orders submitted via the TWS API will always be bound to the client application (i.e. client Id) they were submitted from meaning only the submitting client will be able to modify the placed order. Three different methods are provided to allow for maximum flexibility. Active orders will be returned via the IBApi.EWrapper.openOrder and IBApi.EWrapper.orderStatus methods as already described in The openOrder callback and The orderStatus callback sections
Note: it is not possible to obtain cancelled or fully filled orders.
The IBApi.EClient.reqOpenOrders method allows to obtain all active orders submitted by the client application connected with the exact same client Id with which the order was sent to the TWS. If client 0 invokes reqOpenOrders, it will cause currently open orders placed from TWS manually to be ‘bound’, i.e. assigned an order ID so that they can be modified or cancelled by the API client 0.
When an order is bound by API client 0 there will be callback to IBApi::EWrapper::orderBound. This indicates the mapping between API order ID and permID. The IBApi.EWrapper.orderBound callback in response to newly bound orders that indicates the mapping between the permID (unique account-wide) and API Order ID (specific to an API client). In the API settings in Global Configuration, is a setting checked by default “Use negative numbers to bind automatic orders” which will specify how manual TWS orders are assigned an API order ID.
Because binding the order will change the order ID, this function will be rejected when used with the API Read-Only Mode enabled. You can find the steps for disabling read-only mode at in TWS Settings .
Requests all open orders places by this specific API client (identified by the API client id). For client ID 0, this will bind previous manual TWS orders.





Requests all current open orders in associated accounts at the current moment. The existing orders will be received via the openOrder and orderStatus events. Open orders are returned once; this function does not initiate a subscription.





autoBind: bool. If set to true, the newly created orders will be assigned an API order ID and implicitly associated with this client. If set to false, future orders will not be. )
Requests status updates about future orders placed from TWS. Can only be used with client ID 0.
Important: only those applications connecting with client Id 0 will be able to take over manually submitted orders





orderId: long. IBKR permId.
apiClientId: int. API client id.
apiOrderId: int. API order id. )
Response to API bind order control message.





EClient.reqCompletedOrders allows users to request all orders for the given day that are no longer modifiable. This will include orders have that executed, been rejected, or have been cancelled by the user. Clients may use these requests in order to retain a roster of those order submissions that are no longer traceable via reqOpenOrders.
apiOnly: bool. Determines if only API orders should be returned or if TWS submitted orders should be included.
)





contract: Contract. The order’s Contract. order: Order. The currently active Order. orderState: OrderState. The order’s OrderState )





The order object is an essential piece of the TWS API which is used to both place and manage orders. This is primarily built with an ever increasing range of attributes used to create the best order possible. With that being said, the value to the right represents the required fields in order to place or reference any order. Keep in mind that there are several other attributes that can and should be referenced.
action: String. Determines whether the contract should be a BUY or SELL.
auxPrice: double. Used to determine the stop price for STP, STP LMT, and TRAIL orders.
lmtPrice: double. Used to determine the limit price for LMT, STP LMT, and TRAIL orders.
orderType: String. Specify the type of order to place. For example, MKT, LMT, STP.
tif: String. Time in force for the order. Default tif is DAY.
totalQuantity: decimal. Total size of the order.
Given additional structures for orders are ever evolving, it is recommended to review the relevant order class in your programming language for a comprehensive review of what fields are available.
An order can be cancelled from the API with the functions EClient.cancelOrder and EClient::reqGlobalCancel.
EClient.cancelOrder can only be used to cancel an order that was placed originally by a client with the same client ID (or from TWS for client ID 0).
EClient.reqGlobalCancel will cancel all open orders, regardless of how they were originally placed.
orderId: int. Specify which order should be cancelled by its identifier.
orderCancel: orderCancel. An OrderCancel object that can receive the manualOrderCancelTime, manualOrderIndicator, and extOperator fields. See OrderCancel Reference for more insight on the OrderCancel class. )
Cancels an active order placed by from the same API client ID.
Note: API clients cannot cancel individual orders placed by other clients. Only reqGlobalCancel is available.





This method will cancel ALL open orders including those placed directly from TWS.
orderCancel: orderCancel. An OrderCancel object that can receive the manualOrderCancelTime, manualOrderIndicator, and extOperator fields. See OrderCancel Reference for more insight on the OrderCancel class. )





Options are exercised or lapsed from the API with the function EClient.exerciseOptions.
tickerId: int. Exercise request’s identifier
contract: Contract. the option Contract to be exercised.
exerciseAction: int. Set to 1 to exercise the option, set to 2 to let the option lapse.
exerciseQuantity: int. Number of contracts to be exercised
account: String. Destination account
ovrd: int. Specifies whether your setting will override the system’s natural action. Set to 1 to override, set to 0 not to.
For example, if your action is “exercise” and the option is not in-the-money, by natural action the option would not exercise. If you have override set to “yes” the natural action would be overridden and the out-of-the money option would be exercised.
manualOrderTime: String. Specify the time at which the options should be exercised. An empty string will assume the current time. Required TWS API 10.26 or higher. )
Exercises an options contract.
Note: this function is affected by a TWS setting which specifies if an exercise request must be finalized.





The minimum increment is the minimum difference between price levels at which a contract can trade. Some trades have constant price increments at all price levels. However some contracts have difference minimum increments on different exchanges on which they trade and/or different minimum increments at different price levels. In the contractDetails class, there is a field ‘minTick’ which specifies the smallest possible minimum increment encountered on any exchange or price. For complete information about minimum price increment structure, there is the IB Contracts and Securities search site, or the API function EClient.reqMarketRule.
The function EClient.reqContractDetails when used with a Contract object will return contractDetails object to the contractDetails function which has a list of the valid exchanges where the instrument trades. Also within the contractDetails object is a field called marketRuleIDs which has a list of “market rules”. A market rule is defined as a rule which defines the minimum price increment given the price. The market rule list returned in contractDetails has a list of market rules in the same order as the list of valid exchanges. In this way, the market rule ID for a contract on a particular exchange can be determined.
With the market rule ID number, the corresponding rule can be found with the API function EClient.reqMarketRule. The rule is returned to the function EWrapper.marketRule.
marketRuleId : int. The id of market rule )
Requests details about a given market rule. The market rule for an instrument on a particular exchange provides details about how the minimum price increment changes with price.
A list of market rule ids can be obtained by invoking EClient.reqContractDetails on a particular contract. The returned market rule ID list will provide the market rule ID for the instrument in the correspond valid exchange list in contractDetails.





marketRuleId: int. Market Rule ID requested.
priceIncrements: PriceIncrement[]. Returns the available price increments based on the market rule. )
Returns minimum price increment structure for a particular market rule ID market rule IDs for an instrument on valid exchanges can be obtained from the contractDetails object for that contract





For EEA investment firms required to comply with MiFIR reporting, and who have opted in to Enriched and Delegated Transaction Reporting, we have added four new order attributes to the Order class, and several new presets to TWS and IB Gateway Global Configuration.
New order attributes include:
New TWS and IB Gateway Order Presets can be found in the Orders > MiFIR page of Global Configuration, and include TWS Decision-Maker Defaults, API Decision-Maker Defaults, and Executing Trader/Algo presets.
The following choices are available for the “investment decision within the firm” IBApi.Order.Mifid2DecisionMaker and IBApi.Order.Mifid2DecisionAlgo attributes:
You can configure the preset to indicate this via TWS Global Configuration using the Orders > MiFIR page. In this scenario, the orders for the proprietary account will need to be placed via TWS.
NOTE: Only ONE investment decision-maker, either a primary person or algorithm, should be provided on an order, or selected as the default.
The following choices are available for “execution within the firm” IBApi.Order.Mifid2ExecutionTrader and IBApi.Order.Mifid2ExecutionAlgo attributes:
For more information, or to obtain short codes for persons or algos defined in IB Account Management, please contact IB Client Services.
To find out more about the MiFIR transaction reporting obligations, see the MiFIR Enriched and Delegated Transaction Reporting for EEA Investment Firms knowledge base article.
Modification of an API order can be done if the API client is connected to a session of TWS with the same username of TWS and using the same API client ID. The function EClient.placeOrder can then be called with the same fields as the open order, except for the parameter to modify. This includes the Order.OrderId, which must match the Order.OrderId of the open order. It is not generally recommended to try to change order fields aside from order price, size, and tif (for DAY -> IOC modifications). To change other parameters, it might be preferable to instead cancel the open order, and create a new one.
Orders are submitted via the EClient.placeOrder method.
Immediately after an order is submitted correctly, the TWS will start sending events concerning the order’s activity via EWrapper.openOrder and EWrapper.orderStatus
Advisors executing allocation orders will receive execution details and commissions for the allocation order itself. To receive allocation details and commissions for a specific subaccount EClient.reqExecutions can be used.
An order can be sent to TWS but not transmitted to the IB server by setting the Order.Transmit flag in the order class to False. Untransmitted orders will only be available within that TWS session (not for other usernames) and will be cleared on restart. Also, they can be cancelled or transmitted from the API but not viewed while they remain in the “untransmitted” state.
id: int. The order’s unique identifier. If a new order is placed with an order ID less than or equal to the order ID of a previous order an error will occur.
contract: Contract. The order’s contract
order: Order. The order object. )
Places or modifies an order.





By default, the Trader Workstation implements several precautionary settings that will notify customers of potential order risks to make sure users are well informed before transmitting orders. As a result, customers will typically need to acknowledge a precautionary message and manually transmit the orders through the Trader Workstation. These precautionary messages may be disabled if the user is comfortable and aware of the behavior they are disabling.
When placing orders via the API and building a robust trading system, it is important to monitor for callback notifications, specifically for IBApi::EWrapper::error , IBApi: : EWrapper::orderStatus changes, IBApi::EWrapper::openOrder warnings, and IBApi::EWrapper::execDetails to ensure proper operation.
If you experience issues with orders you place via the API, such as orders not filling, the first thing to check is what these callbacks returned. Your order may have been rejected or cancelled. If needed, see the API Log section, for information on obtaining your API logs or submitting them for review.
Common cases of order rejections, cancellations, and warnings, and the corresponding message returned:
The TWS API supports the ability to pre-borrow shares for shorting.
To place a Pre-Borrow order, users must:




From the API it is possible to check how a specified trade execution is expected to change the account margin requirements for an account in real time. This is done by creating an Order object which has the IBApi.Order.WhatIf flag set to true. By default, the whatif boolean in Order has a false value, but if set to True in an Order object with is passed to IBApi.EClient.placeOrder , instead of sending the order to a destination the IB server it will undergo a credit check for the expected post-trade margin requirement. The estimated post-trade margin requirement is returned to the IBApi.OrderState object in the EWrapper.openOrder callback..
This is equivalent to creating a order ticket in TWS, clicking “Preview”, and viewing the information in the “Margin Impact” panel.

For example, most users want to check the margin details or available leverage of the order. Here is the example of checking the Initial Maintenance Margin Change.
Python:
Expected output:
You can see that 12567.5 is the initMarginChange which matches the Initial Margin Change result shown in TWS Order Ticket Preview.


Apart from InitMarginChange, there are other supported variables. For details, please visit: https://www.interactivebrokers.com/campus/ibkr-api-page/twsapi-ref/#orderstate-ref

The Trigger Method defined in the IBApi.Order class specifies how simulated stop, stop-limit, and trailling stops, and conditional orders are triggered. Valid values are:
Below is a table which indicates whether a given secType is compatible with bid/ask-driven or last-driven trigger methods (method 7 only used in iBot alerts)
Important notes :
Display Groups function allows API clients to integrate with TWS Color Grouping Windows .
TWS Color Grouping Windows are identified by a colored chain in TWS and by an integer number via the API. Currently that number ranges from 1 to 7 and are mapped to specific colors, as indicated in TWS.
The IBApi.EClient.queryDisplayGroups method is used to request all available Display Groups in TWS. The IBApi.EWrapper.displayGroupList is a one-time response to IBApi.EClient.queryDisplayGroups.
It returns a list of integers representing visible Group ID separated by the “|” character, and sorted by most used group first. This list will not change during TWS session. In other words, user cannot add a new group, but only the sorting of the group numbers can change.
Example: “4|1|2|5|3|6|7”
requestId: int. Request identifier used to track data. )
Requests all available Display Groups in TWS.





requestId: Request identifier used to track data.
groups: String. Returns a list of integers representing visible Group ID separated by the “|” character, and sorted by most used group first. )
A one-time response to querying the display groups.





To integrate with a specific Group, you need to first subscribe to the group number by invoking IBApi.EClient.subscribeToGroupEvents. The IBApi.EWrapper.displayGroupUpdated call back is triggered once after receiving the subscription request, and will be sent again if the selected contract in the subscribed display group has changed.
requestId: int. Request identifier used to track data.
groupId: int. The display group for integration. )
Integrates API client and TWS window grouping.





requestId: int. Request identifier used to track data.
contractInfo: String. Contract information produced for the active display group.
) Call triggered once after receiving the subscription request, and will be sent again if the selected contract in the subscribed * display group has changed.





requestId: int. Request identifier used to track data. )
Cancels a TWS Window Group subscription.





requestId: int. Request identifier used for tracking data.
contractInfo: String. An encoded value designating a unique IB contract. Possible values include:
Updates the contract displayed in a TWS Window Group.





Note: This request from the API does not get a response from TWS unless an error occurs.
In this sample we have commanded TWS Windows that chained with Group #1 to display IBM@SMART. The screenshot of TWS Mosaic to the right shows that both the pink chained (Group #1) windows are now displaying IBM@SMART, while the green chained (Group #4) window remains unchanged.

Calendar and Event data can be retrieved from the Wall Street Horizon Event Calendar and accessed via the TWS API through the functions IBApi.EClient.reqWshMetaData and IBApi.EClient.reqWshEventData.
It is necessary to have the Wall Street Horizon Corporate Event Data research subscription activated first in Account Management .
WSH provides IBKR with corporate event datasets, including earnings dates, dividend dates, options expiration dates, splits, spinoffs and a wide variety of investor-related conferences.
The function IBApi.EClient.reqWshMetaData is used to request available event types, or supported filter values, that may be used in the call for EClient.reqWshEventData() filter field.
Regardless of whether or not you are aware of the Meta Data filters, this request must always be called once per session prior to the EClient.reqWshEventData() function.
While this list contains an array of Meta Data filters that may be used, please be aware that new values may be made available or removed without notice.
In addition to the EClient.reqWshMetaData field being mandatory prior to the EClient.reqWshEventData() function, the JSON content will also return the appropriate column values that are returned along with the function.
requestId: int. Request identifier used to track data. )
Requests metadata from the WSH calendar.





requestId: int. Request identifier used to track data.
dataJson: String. metadata in json format. )
Returns meta data from the WSH calendar





Once the json content has been received, the specific event types used to filter EClient.reqWshEventData() are listed under “meta_data” -> “event_types”.
The “name” field will express what the filter will return, such as “Board of Directors Meeting”
The “tag” field will return the filter used in your JSON query. The related example would be “wshe_bod”.
requestId: int. Request identifier used to track data. )
Cancels pending request for WSH metadata.





The function EClient.reqWshEventData is used to request various calendar events from Wall Street Horizon. The event data is then received via the callback EWrapper.wshEventData. Pending event data requests can be canceled with the function IBApi.EClient.cancelWshEventData.
Note: Prior to sending this message, the API client must make a request for metadata via EClient.reqWshMetaData .
Also note that TWS will not support multiple concurrent requests. Previous request should succeed, fail, or be cancelled by client before next one. TWS will reject such requests with text “Duplicate WSH meta-data request” or “Duplicate WSH event request”.
When making a request to the Wall Street Horizons Event Calendar with the API, users must create a wshEventData Object. This object contains several fields, along with a filter field, which takes a json-formatted string. The filter values are returned from WSH Meta Data requests.
When creating the object, users are able to specify either the WshEventData.conId, WshEventData.startDate, and WshEventData.endDate, or they may choose to use the WshEventData.filter value. Attempting to use both will result in an error.
Only one Event Type tag may be passed per request. Multiple submitted filters will be ignored beyond the final request.
conId: String. Specify the contract identifier for the event request.
startDate: String. Specify the start date of the event requests. Formatted as “YYYYMMDD”
endDate: String. Specify the end date of the event requests. Formatted as “YYYYMMDD”
fillCompetitors: bool. Automatically fill in competitor values of existing positions.
fillPortfolio: bool. Automatically fill in portfolio values.
fillWatchlist: bool. Automatically fill in watchlist values.
totalLimit: int. Maximum of 100.
filter: String. Json-formatted string containing all filter values. Some available values include:
requestId: int. Request identifier used to track data.
wshEventData: WshEventData. Unique object used to track all parameters for the event data request. See WshEventData Object for more details. )
MIN_SERVER_VER_WSH_EVENT_DATA_FILTERS_DATE: *Only passed in the Python implementation. Server version of the API implementationmust be passed. This can be accomplished with the EClient.serverVersion() function call.
Requests event data from the WSH calendar.





requestId: int. Request identifier used to track data.
dataJson: String. Event data json format. )
Returns calendar events from the WSH.





requestId: int. Request identifier used to track data.
)
Cancels pending WSH event data request.





IBKR Campus Newsletters
Get updates on podcasts, webinars, courses, and more from our IBKR pillars.
View the latest financial news articles from the top voices in the industry.
Get updates on podcasts, webinars, courses, and more from our IBKR pillars.
For those wanting to trade markets using computer-power by coders and developers.
Hear about the latest tools and techniques from our own IBKR API staff.
© 2025 Interactive Brokers, LLC
The risk of loss in online trading of stocks, options, futures, forex, foreign equities, and fixed income can be substantial. Before trading, clients must read the relevant risk disclosure statements on IBKR's Warnings and Disclosures page .
The analysis in this material is provided for information only and is not and should not be construed as an offer to sell or the solicitation of an offer to buy any security. To the extent that this material discusses general market activity, industry or sector trends or other broad-based economic or political conditions, it should not be construed as research or investment advice. To the extent that it includes references to specific securities, commodities, currencies, or other instruments, those references do not constitute a recommendation by IBKR to buy, sell or hold such investments. This material does not and is not intended to take into account the particular financial conditions, investment objectives or requirements of individual customers. Before acting on this material, you should consider whether it is suitable for your particular circumstances and, as necessary, seek professional advice.
Securities or other financial instruments mentioned in the material posted are not suitable for all investors. The material posted does not take into account your particular investment objectives, financial situations or needs and is not intended as a recommendation to you of any particular securities, financial instruments or strategies. Before making any investment or trade, you should consider whether it is suitable for your particular circumstances and, as necessary, seek professional advice. Past performance is no guarantee of future results.
Information posted on IBKR Campus that is provided by third-parties does NOT constitute a recommendation that you should contract for the services of that third party. Third-party participants who contribute to IBKR Campus are independent of Interactive Brokers and Interactive Brokers does not make any representations or warranties concerning the services offered, their past or future performance, or the accuracy of the information provided by the third party. Past performance is no guarantee of future results.
Any information posted by employees of IBKR or an affiliated company is based upon information that is believed to be reliable. However, neither IBKR nor its affiliates warrant its completeness, accuracy or adequacy. IBKR does not make any representations or warranties concerning the past or future performance of any financial instrument. By posting material on IBKR Campus, IBKR is not representing that any particular financial instrument or trading strategy is appropriate for you.
Any trading symbols displayed are for illustrative purposes only and are not intended to portray recommendations.
Please note that any advertisement has not been reviewed by the Monetary Authority of Singapore.
This site is protected by reCAPTCHA and the Google Privacy Policy and Terms of Service apply. If you have any questions or comments, or are interested in becoming a contributor to the IBKR Campus, please contact us here .
Is a member NYSE - FINRA - SIPC and regulated by the US Securities and Exchange Commission and the Commodity Futures Trading Commission. Headquarters: One Pickwick Plaza, Greenwich, CT 06830 USA. Website: www.interactivebrokers.com
Is a member of the Investment Industry Regulatory Organization of Canada (CIRO) and Member - Canadian Investor Protection Fund.
 Registered Office: 1800 McGill College Avenue, Suite 2106, Montreal, Quebec, H3A 3J6, Canada. Website: www.interactivebrokers.ca
ABN 98 166 929 568 is licensed and regulated by the Australian Securities and Investments Commission (AFSL: 453554) and is a participant of ASX, ASX 24 and Cboe Australia.
 Registered Office: Level 11, 175 Pitt Street, Sydney, New South Wales 2000, Australia. Website: www.interactivebrokers.com.au
Is regulated by the Hong Kong Securities and Futures Commission, and is a member of the SEHK and the HKFE.
 Registered Office: Suite 1512, Two Pacific Place, 88 Queensway, Admiralty, Hong Kong SAR. Website: www.interactivebrokers.com.hk
Is a trading member of NSE, BSE, and depository participant of NSDL. SEBI Registration No. INZ000217730; NSDL: IN-DP-602-2021. CIN-U67120MH2007FTC170004.
 Registered Office: 502/A, Times Square, Andheri Kurla Road, Andheri East, Mumbai 400059, India.
 Phone: +91-22-61289888 | Fax: +91-22-61289898. Website: www.interactivebrokers.co.in
Is regulated by Kanto Local Finance Bureau (Registration No.187) and is a member of Japan Securities Dealers Association and The Commodity Futures Association of Japan.
 Registered Office: Kasumigaseki Building 25F, 2-5 Kasumigaseki 3-chome, Chiyoda-ku, Tokyo, 100-6025 Japan.
 Phone: +81 (0)3-4588-9700 (On business days from 8:30-17:30 JST). Website: www.interactivebrokers.co.jp
Is licensed and regulated by the Monetary Authority of Singapore (Licence No. CMS100917).
 Registered Office: #40-02A, Asia Square Tower 1, 8 Marina View, Singapore 018960. Website: www.interactivebrokers.com.sg
This website uses cookies to collect usage information in order to offer a better browsing experience. By browsing this site or by clicking on the "ACCEPT COOKIES" button you accept our Cookie Policy.
To view this page, you must acknowledge that you have received the Characteristics & Risks of Standardized Options, also known as the options disclosure document (ODD). Options involve risk and are not suitable for all investors. For more information, click here to read the " Characteristics and Risks of Standardized Options " or visit: ibkr.com/occ
By acknowledging this disclosure you are also allowing this website to use "functional" cookies on your brpwser. To find out more about cookies, see our privacy settings.
When you visit any website it may use cookies and web beacons to store or retrieve information on your browser. This information might be about you, your preferences or your device and is typically used to make the website work as expected. The information does not usually directly identify you, but can provide a personalized browsing experience. Because we respect your right to privacy, you can choose not to allow some types of cookies and web beacons. Please click on the different category headings to find out more and change our default settings. However, blocking some types of cookies may impact your experience on our website and limit the services we can offer.
Strictly necessary cookies are necessary for the website to function and cannot be switched off in our systems. They are typically set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, logging in or filling in forms. While you can set your browser to block or alert you about these cookies, some parts of the website will not work. These cookies do not store any personally identifiable information.
ALWAYS ACTIVE
Performance cookies and web beacons allow us to count visits and traffic sources so we can measure and improve website performance. They help us to know which pages are the most and least popular and see how visitors navigate around our website. All information these cookies and web beacons collect is aggregated and anonymous. If you do not allow these cookies and web beacons we will not know when you have visited our website and will not be able to monitor its performance.
Allow Performance Cookies:
Functional cookies enable our website to provide enhanced functionality and personalization. They may be set by us or by third party providers whose services we have added to our pages. If you do not allow these cookies then some or all of these services may not function properly.
Allow Functional Cookies:
Marketing Cookies and web beacons may be set through our website by our advertising partners. They may be used by those companies to build a profile of your interests and show you relevant adverts on other websites. They do not directly store personal information, but uniquely identify your browser and internet device. If you do not allow these cookies and web beacons, you will experience less targeted advertising. Our website does not track users when they cross to third party websites, does not provide targeted advertising to them and therefore does not respond to "Do Not Track" signals.
Allow Marketing Cookies:
What are Cookies and Web Beacons?
Cookies are pieces of data that a website transfers to a user's hard drive for record-keeping purposes. Web beacons are transparent pixel images that are used in collecting information about website usage, e-mail response and tracking. Generally, cookies may contain information about your Internet Protocol ("IP") addresses, the region or general location where your computer or device is accessing the internet, browser type, operating system and other usage information about the website or your usage of our services, including a history of the pages you view.
How We Use Cookies and Web Beacons
Interactive Brokers Group collects information from cookies and web beacons and stores it in an internal database. This information is retained in accordance with our Privacy Policy. This website uses the following cookies and web beacons:
Strictly Necessary Cookies
These cookies are necessary for the website to function and cannot be switched off in our systems. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, logging in or filling in forms. You can configure your browser to block or alert you about these cookies, but certain areas of the site will not function properly. These cookies do not store any personal data.
Performance Cookies and Web Beacons
These cookies and web beacons allow us to count visits and traffic sources so we can measure and improve the performance of our site. They help us to know which pages are the most and least popular and see how visitors move around the site. All information that these cookies and web beacons collect is aggregated and, therefore, anonymous. If you do not allow these cookies and web beacons our aggregated statistics will not have a record of your visit.
 The website uses Google Analytics, a web analytics service provided by Google, Inc. ("Google"). Google Analytics uses cookies to help analyse how you use this website. The information generated by the cookie about your use of this website (including your IP address) will be transmitted to and stored by Google on servers in the United States. Google will use this information for the purposes of evaluating your use of the website, compiling reports on website activity for website operators and providing other services relating to website activity and internet usage. Google may also transfer this information to third parties where required to do so by law, or where such third parties process the information on Google's behalf. Google will not associate your IP address with any other data held by Google.
Functional Cookies
These cookies enable the website to provide enhanced functionality and personalization. They may be set by us or by third party providers whose services we have added to our pages. If you do not allow these cookies, some or all of these services may not function properly.
Marketing Cookies and Web Beacons
These cookies and web beacons may be set throughout our site by our advertising partners. They may be used by those companies to build a profile of your interests and show you relevant advertisements on other sites. They do not store personal information that could identify you directly, but are based on uniquely identifying your browser and internet device. If you do not allow these cookies and web beacons, you will experience less targeted advertising. The website does not track users when they cross to third party websites, does not provide targeted advertising to them and therefore does not respond to Do Not Track ("DNT") signals.
Managing Your Cookie Preferences
You have many choices with regards to the management of cookies on your computer. All major browsers allow you to block or delete cookies from your system. However, if you do decide to disable cookies you may not be able to access some areas of our website or the website may function incorrectly. To learn more about your ability to manage cookies and web beacons and how to disable them, please consult the privacy features in your browser or visit www.allaboutcookies.org.
 This website may link through to third party websites which may also use cookies and web beacons over which we have no control. We recommend that you check the relevant third parties privacy policy for information about any cookies and web beacons that may be used.
We are redirecting you to the Interactive Brokers LLC (U.S.) Website. Should you decide to open an account, you will be redirected to the account application for your region. You can also find the website of the IBKR entity for your region at the bottom of this page.

```
Login failed = Soft token=0 received instead of expected permanent for zdc1.ibllc.com:4001 (SSL)
```


```
{TWS API}\source\pythonclient
```


```
python setup.py install
```


```
python -m pip show ibapi
```


```
class TestWrapper(wrapper.EWrapper):
```


```
public class EWrapperImpl implements EWrapper {
```


```
class TestCppClient : public EWrapper
    {
```


```
public class EWrapperImpl : EWrapper 
   {
```


```
Public Class EWrapperImpl
    Implements EWrapper
```


```
class TestClient(EClient):
     def __init__(self, wrapper):
         EClient.__init__(self, wrapper)
...
class TestApp(TestWrapper, TestClient):
	def __init__(self):
	TestWrapper.__init__(self)
         TestClient.__init__(self, wrapper=self)
```


```
private EReaderSignal readerSignal;
private EClientSocket clientSocket;
protected int currentOrderId = -1;
```


```
public EWrapperImpl() {
    readerSignal = new EJavaSignal();
    clientSocket = new EClientSocket(this, readerSignal);
}
```


```
EReaderOSSignal m_osSignal;
    EClientSocket * const m_pClient;
```


```
TestCppClient::TestCppClient() :
      m_osSignal(2000)//2-seconds timeout
    , m_pClient(new EClientSocket(this, &m_osSignal))
    , m_state(ST_CONNECT)
    , m_sleepDeadline(0)
    , m_orderId(0)
    , m_extraAuth(false)
{
}
```


```
EClientSocket clientSocket;
public readonly EReaderSignal Signal;
```


```
public EWrapperImpl()
{
    Signal = new EReaderMonitorSignal();
    clientSocket = new EClientSocket(this, Signal);
}
```


```
Public eReaderSignal As EReaderSignal
Public socketClient As EClientSocket
```


```
Sub New()
    eReaderSignal = New EReaderMonitorSignal
    socketClient = New EClientSocket(Me, eReaderSignal)
End Sub
```


```
app.connect("127.0.0.1", args.port, clientId=0)
```


```
m_client.eConnect("127.0.0.1", 7497, 2);
```


```
bool bRes = m_pClient->eConnect( host, port, clientId, m_extraAuth);
```


```
clientSocket.eConnect("127.0.0.1", 7497, 0);
```


```
socketClient.eConnect("127.0.0.1", 7497, 0)
```


```
def connectAck(self):
    print("API Connection Established.")
```


```
public void connectAck(){
	System.out.println("API Connection Established.");
}
```


```
void TestCppClient::connectAck()
{
    printf("API Connection Established.");
}
```


```
public void connectAck()
{
    Console.WriteLine("API Connection Established.");
}
```


```
print(app.isConnected())
```


```
System.out.println(m_client.isConnected());
```


```
printf(m_pClient->isConnected());
```


```
Console.WriteLine(clientSocket.isConnected());
```


```
socketClient.eConnect("127.0.0.1", 7497, 0)
```


```
final EReader reader = new EReader(m_client, m_signal); 

reader.start();
//An additional thread is created in this program design to empty the messaging queue
new Thread(() -> {
    while (m_client.isConnected()) {
        m_signal.waitForSignal();
        try {
             reader.processMsgs();
        } catch (Exception e) {
            System.out.println("Exception: "+e.getMessage());
        }
    }
}).start();
```


```
m_pReader = std::unique_ptr<EReader>( new EReader(m_pClient, &m_osSignal) );
m_pReader->start();
```


```
//Create a reader to consume messages from the TWS. The EReader will consume the incoming messages and put them in a queue
var reader = new EReader(clientSocket, readerSignal);
reader.Start();
//Once the messages are in the queue, an additional thread can be created to fetch them
new Thread(() => { while (clientSocket.IsConnected()) { readerSignal.waitForSignal(); reader.processMsgs(); } }) { IsBackground = true }.Start();
```


```
'Once the messages are in the queue, an additional thread need to fetch them
Dim msgThread As Thread = New Thread(AddressOf messageProcessing)
msgThread.IsBackground = True
If (wrapperImpl.serverVersion() > 0) Then Call msgThread.Start()
```


```
Private Sub messageProcessing()
    Dim reader As EReader = New EReader(wrapperImpl.socketClient, wrapperImpl.eReaderSignal)
    reader.Start()
    While (wrapperImpl.socketClient.IsConnected)
        wrapperImpl.eReaderSignal.waitForSignal()
        reader.processMsgs()
    End While
End Sub
```


```
def connectClosed(self):
    print("API Connection Lost.")
```


```
public void connectClosed(){
	System.out.println("API Connection Lost.");
}
```


```
void TestCppClient::connectClosed()
{
    printf("API Connection Lost.");
}
```


```
public void connectClosed()
{
    Console.WriteLine("API Connection Lost.");
}
```


```
self.reqAccountSummary(9001, "All", AccountSummaryTags.AllTags)
```


```
from ibapi.client import *
from ibapi.wrapper import *
from ibapi.contract import Contract
import time

class TradeApp(EWrapper, EClient): 
    def __init__(self): 
        EClient.__init__(self, self) 

    def accountSummary(self, reqId: int, account: str, tag: str, value: str,currency: str):
        print("AccountSummary. ReqId:", reqId, "Account:", account,"Tag: ", tag, "Value:", value, "Currency:", currency)
    
    def accountSummaryEnd(self, reqId: int):
        print("AccountSummaryEnd. ReqId:", reqId)
    
app = TradeApp()      
app.connect("127.0.0.1", 7496, clientId=1)

time.sleep(1)

app.reqAccountSummary(9001, "All", 'NetLiquidation')
app.run()
```


```
client.reqAccountSummary(9001, "All", "AccountType,NetLiquidation,TotalCashValue,SettledCash,AccruedCash,BuyingPower,EquityWithLoanValue,PreviousEquityWithLoanValue,GrossPositionValue,ReqTEquity,ReqTMargin,SMA,InitMarginReq,MaintMarginReq,AvailableFunds,ExcessLiquidity,Cushion,FullInitMarginReq,FullMaintMarginReq,FullAvailableFunds,FullExcessLiquidity,LookAheadNextChange,LookAheadInitMarginReq ,LookAheadMaintMarginReq,LookAheadAvailableFunds,LookAheadExcessLiquidity,HighestSeverity,DayTradesRemaining,Leverage");
```


```
m_pClient->reqAccountSummary(9001, "All", AccountSummaryTags::getAllTags());
```


```
client.reqAccountSummary(9001, "All", AccountSummaryTags.GetAllTags());
```


```
client.reqAccountSummary(9001, "All", AccountSummaryTags.GetAllTags())
```


```
def accountSummary(self, reqId: int, account: str, tag: str, value: str,currency: str):
  print("AccountSummary. ReqId:", reqId, "Account:", account,"Tag: ", tag, "Value:", value, "Currency:", currency)
```


```
@Override
public void accountSummary(int reqId, String account, String tag, String value, String currency) {
    System.out.println(EWrapperMsgGenerator.accountSummary(reqId, account, tag, value, currency));
}
```


```
void TestCppClient::accountSummary( int reqId, const std::string& account, const std::string& tag, const std::string& value, const std::string& currency) {
    printf( "Acct Summary. ReqId: %d, Account: %s, Tag: %s, Value: %s, Currency: %s\n", reqId, account.c_str(), tag.c_str(), value.c_str(), currency.c_str());
}
```


```
public virtual void accountSummary(int reqId, string account, string tag, string value, string currency)
{
    Console.WriteLine("Acct Summary. ReqId: " + reqId + ", Acct: " + account + ", Tag: " + tag + ", Value: " + value + ", Currency: " + currency);
}
```


```
Public Sub accountSummary(reqId As Integer, account As String, tag As String, value As String, currency As String) Implements IBApi.EWrapper.accountSummary
    Console.WriteLine("AccountSummary - ReqId [" & reqId & "] Account [" & account & "] Tag [" & tag & "] Value [" & value & "] Currency [" & currency & "]")
End Sub
```


```
def accountSummaryEnd(self, reqId: int):
    print("AccountSummaryEnd. ReqId:", reqId)
```


```
@Override
public void accountSummaryEnd(int reqId) {
    System.out.println("Account Summary End. Req Id: " + EWrapperMsgGenerator.accountSummaryEnd(reqId));
}
```


```
void TestCppClient::accountSummaryEnd( int reqId) {
    printf( "AccountSummaryEnd. Req Id: %d\n", reqId);
}
```


```
public virtual void accountSummaryEnd(int reqId)
{
    Console.WriteLine("AccountSummaryEnd. Req Id: "+reqId+"\n");
}
```


```
Public Sub accountSummaryEnd(reqId As Integer) Implements IBApi.EWrapper.accountSummaryEnd
    Console.WriteLine("AccountSummaryEnd - ReqId [" & reqId & "]")
End Sub
```


```
self.cancelAccountSummary(9001)
```


```
m_pClient->cancelAccountSummary(9001);
```


```
self.reqAccountUpdates(True, self.account)
```


```
from ibapi.client import *
from ibapi.wrapper import *
from ibapi.contract import Contract
import time

class TradeApp(EWrapper, EClient): 
    def __init__(self): 
        EClient.__init__(self, self) 

    def updateAccountValue(self, key: str, val: str, currency: str,accountName: str):
        print("UpdateAccountValue. Key:", key, "Value:", val, "Currency:", currency, "AccountName:", accountName)
    
    def updatePortfolio(self, contract: Contract, position: Decimal,marketPrice: float, marketValue: float, averageCost: float, unrealizedPNL: float, realizedPNL: float, accountName: str):
        print("UpdatePortfolio.", "Symbol:", contract.symbol, "SecType:", contract.secType, "Exchange:",contract.exchange, "Position:", decimalMaxString(position), "MarketPrice:", floatMaxString(marketPrice),"MarketValue:", floatMaxString(marketValue), "AverageCost:", floatMaxString(averageCost), "UnrealizedPNL:", floatMaxString(unrealizedPNL), "RealizedPNL:", floatMaxString(realizedPNL), "AccountName:", accountName)

    def updateAccountTime(self, timeStamp: str):
        print("UpdateAccountTime. Time:", timeStamp)

    def accountDownloadEnd(self, accountName: str):
        print("AccountDownloadEnd. Account:", accountName)
    
app = TradeApp()      
app.connect("127.0.0.1", 7496, clientId=1)

time.sleep(1)

app.reqAccountUpdates(True, 'U123456')
app.run()
```


```
client.reqAccountUpdates(true, "U1234567");
```


```
m_pClient->reqAccountUpdates(true, "U150462");
```


```
client.reqAccountUpdates(true, "U1234567");
```


```
client.reqAccountUpdates(True, "U1234567")
```


```
def updateAccountValue(self, key: str, val: str, currency: str,accountName: str):
    print("UpdateAccountValue. Key:", key, "Value:", val, "Currency:", currency, "AccountName:", accountName)
```


```
@Override
public void updateAccountValue(String key, String value, String currency, String accountName) {
    System.out.println(EWrapperMsgGenerator.updateAccountValue( key, value, currency, accountName));
}
```


```
void TestCppClient::updateAccountValue(const std::string& key, const std::string& val, const std::string& currency, const std::string& accountName) {
    printf("UpdateAccountValue. Key: %s, Value: %s, Currency: %s, Account Name: %s\n", key.c_str(), val.c_str(), currency.c_str(), accountName.c_str());
}
```


```
public virtual void updateAccountValue(string key, string value, string currency, string accountName)
{
    Console.WriteLine("UpdateAccountValue. Key: " + key + ", Value: " + value + ", Currency: " + currency + ", AccountName: " + accountName);
}
```


```
Public Sub updateAccountValue(key As String, value As String, currency As String, accountName As String) Implements IBApi.EWrapper.updateAccountValue
        Console.WriteLine("UpdateAccountValue. Key: " & key & ", Value: " & value & ", Currency: " & currency & ", AccountName: " & accountName)
End Sub
```


```
def updatePortfolio(self, contract: Contract, position: Decimal,marketPrice: float, marketValue: float, averageCost: float, unrealizedPNL: float, realizedPNL: float, accountName: str):
    print("UpdatePortfolio.", "Symbol:", contract.symbol, "SecType:", contract.secType, "Exchange:",contract.exchange, "Position:", decimalMaxString(position), "MarketPrice:", floatMaxString(marketPrice),"MarketValue:", floatMaxString(marketValue), "AverageCost:", floatMaxString(averageCost), "UnrealizedPNL:", floatMaxString(unrealizedPNL), "RealizedPNL:", floatMaxString(realizedPNL), "AccountName:", accountName)
```


```
@Override
public void updatePortfolio(Contract contract, Decimal position, double marketPrice, double marketValue, double averageCost, double unrealizedPNL, double realizedPNL, String accountName) {
    System.out.println(EWrapperMsgGenerator.updatePortfolio( contract, position, marketPrice, marketValue, averageCost, unrealizedPNL, realizedPNL, accountName));
}
```


```
void TestCppClient::updatePortfolio(const Contract& contract, Decimal position, double marketPrice, double marketValue, double averageCost, double unrealizedPNL, double realizedPNL, const std::string& accountName){
    printf("UpdatePortfolio. %s, %s @ %s: Position: %s, MarketPrice: %s, MarketValue: %s, AverageCost: %s, UnrealizedPNL: %s, RealizedPNL: %s, AccountName: %s\n", (contract.symbol).c_str(), (contract.secType).c_str(), (contract.primaryExchange).c_str(), decimalStringToDisplay(position).c_str(), Utils::doubleMaxString(marketPrice).c_str(), Utils::doubleMaxString(marketValue).c_str(), Utils::doubleMaxString(averageCost).c_str(), Utils::doubleMaxString(unrealizedPNL).c_str(), Utils::doubleMaxString(realizedPNL).c_str(), accountName.c_str());
}
```


```
public virtual void updatePortfolio(Contract contract, decimal position, double marketPrice, double marketValue, double averageCost, double unrealizedPNL, double realizedPNL, string accountName)
{
    Console.WriteLine("UpdatePortfolio. " + contract.Symbol + ", " + contract.SecType + " @ " + contract.Exchange + ": Position: " + Util.DecimalMaxString(position) + ", MarketPrice: " + Util.DoubleMaxString(marketPrice) + ", MarketValue: " + Util.DoubleMaxString(marketValue) +  ", AverageCost: " + Util.DoubleMaxString(averageCost) + ", UnrealizedPNL: " + Util.DoubleMaxString(unrealizedPNL) + ", RealizedPNL: " + Util.DoubleMaxString(realizedPNL) +  ", AccountName: " + accountName);
}
```


```
Public Sub updatePortfolio(contract As IBApi.Contract, position As Decimal, marketPrice As Double, marketValue As Double, averageCost As Double, unrealizedPNL As Double, realizedPNL As Double, accountName As String) Implements IBApi.EWrapper.updatePortfolio
        Console.WriteLine("UpdatePortfolio. " & contract.Symbol & ", " & contract.SecType & " @ " & contract.Exchange & ": Position: " & Util.DecimalMaxString(position) & ", MarketPrice: " & Util.DoubleMaxString(marketPrice) & ", MarketValue: " & Util.DoubleMaxString(marketValue) & ", AverageCost: " & Util.DoubleMaxString(averageCost) & ", UnrealizedPNL: " & Util.DoubleMaxString(unrealizedPNL) & ", RealizedPNL: " & Util.DoubleMaxString(realizedPNL) & ", AccountName: " & accountName)
End Sub
```


```
def updateAccountTime(self, timeStamp: str):
     print("UpdateAccountTime. Time:", timeStamp)
```


```
@Override
public void updateAccountTime(String timeStamp) {
    System.out.println(EWrapperMsgGenerator.updateAccountTime( timeStamp));
}
```


```
void TestCppClient::updateAccountTime(const std::string& timeStamp) {
    printf( "UpdateAccountTime. Time: %s\n", timeStamp.c_str());
}
```


```
public virtual void updateAccountTime(string timestamp)
{
        Console.WriteLine("UpdateAccountTime. Time: " + timestamp+"\n");
}
```


```
Public Sub updateAccountTime(timestamp As String) Implements IBApi.EWrapper.updateAccountTime
    Console.WriteLine("UpdateAccountTime. Time: " & timestamp)
End Sub
```


```
def accountDownloadEnd(self, accountName: str):
    print("AccountDownloadEnd. Account:", accountName)
```


```
@Override
public void accountDownloadEnd(String accountName) {
    System.out.println(EWrapperMsgGenerator.accountDownloadEnd(accountName));
}
```


```
void TestCppClient::accountDownloadEnd(const std::string& accountName) {
    printf( "Account download finished: %s\n", accountName.c_str());
}
```


```
public virtual void accountDownloadEnd(string account)
{
    Console.WriteLine("Account download finished: "+account+"\n");
}
```


```
Public Sub accountDownloadEnd(account As String) Implements IBApi.EWrapper.accountDownloadEnd
    Console.WriteLine("accountDownloadEnd - Account[" & account & "]")
End Sub
```


```
self.reqAccountUpdates(False, self.account)
```


```
client.reqAccountUpdates(false, "U1234567");
```


```
m_pClient->reqAccountUpdates(true, "U150462");
```


```
client.reqAccountUpdates(true, "U1234567");
```


```
client.reqAccountUpdates(True, "U1234567")
```


```
self.reqAccountUpdatesMulti(reqId, self.account, "", True)
```


```
from ibapi.client import *
from ibapi.wrapper import *
import time

class TradeApp(EWrapper, EClient): 
    def __init__(self): 
        EClient.__init__(self, self) 

    def accountUpdateMulti(self, reqId: int, account: str, modelCode: str, key: str, value: str, currency: str):
        print("AccountUpdateMulti. RequestId:", reqId, "Account:", account, "ModelCode:", modelCode, "Key:", key, "Value:", value, "Currency:", currency)

    def accountUpdateMultiEnd(self, reqId: int):
        print("AccountUpdateMultiEnd. RequestId:", reqId)
    
app = TradeApp()      
app.connect("127.0.0.1", 7496, clientId=1)

time.sleep(1)

app.reqAccountUpdatesMulti(103, 'U123456', "", True)

app.run()
```


```
client.reqAccountUpdatesMulti(reqId, "U1234567", "", true);
```


```
m_pClient->reqAccountUpdatesMulti(reqId, "U1234567", "", true);
```


```
client.reqAccountUpdatesMulti(reqId, "U1234567", "", true);
```


```
client.reqAccountUpdatesMulti(reqId, "U1234567", "", True)
```


```
def accountUpdateMulti(self, reqId: int, account: str, modelCode: str, key: str, value: str, currency: str):
  print("AccountUpdateMulti. RequestId:", reqId, "Account:", account, "ModelCode:", modelCode, "Key:", key, "Value:", value, "Currency:", currency)
```


```
@Override
public void accountUpdateMulti(int reqId, String account, String modelCode, String key, String value, String currency) {
    System.out.println("Account Update Multi: " + EWrapperMsgGenerator.accountUpdateMulti(reqId, account, modelCode, key, value, currency));
}
```


```
void TestCppClient::accountUpdateMulti( int reqId, const std::string& account, const std::string& modelCode, const std::string& key, const std::string& value, const std::string& currency) {
    printf("AccountUpdate Multi. Request: %d, Account: %s, ModelCode: %s, Key, %s, Value: %s, Currency: %s\n", reqId, account.c_str(), modelCode.c_str(), key.c_str(), value.c_str(), currency.c_str());
}
```


```
public virtual void accountUpdateMulti(int reqId, string account, string modelCode, string key, string value, string currency)
{
    Console.WriteLine("Account Update Multi. Request: " + reqId + ", Account: " + account + ", ModelCode: " + modelCode + ", Key: " + key + ", Value: " + value + ", Currency: " + currency + "\n");
}
```


```
Public Sub accountUpdateMulti(requestId As Integer, account As String, modelCode As String, key As String, value As String, currency As String) Implements IBApi.EWrapper.accountUpdateMulti
    Console.WriteLine("accountUpdateMulti. Id: " & requestId & ", Account: " & account & ", modelCode: " & modelCode & ", key: " & key & ", value: " & value & ", currency: " & currency)
End Sub
```


```
def accountUpdateMultiEnd(self, reqId: int):
    print("AccountUpdateMultiEnd. RequestId:", reqId)
```


```
@Override
public void accountUpdateMultiEnd(int reqId, ) {
    System.out.println( "Account Update Multi End: " + EWrapperMsgGenerator.accountUpdateMultiEnd(reqId));
}
```


```
void TestCppClient::accountUpdateMultiEnd( int reqId) {
    printf("Account Update Multi End. Request: %d\n", reqId);
}
```


```
public virtual void accountUpdateMultiEnd(int reqId)
{
    Console.WriteLine("Account Update Multi End. Request: " + reqId + "\n");
}
```


```
Public Sub accountUpdateMultiEnd(requestId As Integer) Implements IBApi.EWrapper.accountUpdateMultiEnd
    Console.WriteLine("accountUpdateMultiEnd. id: " & requestId)
End Sub
```


```
self.reqAccountUpdatesMulti(reqId, self.account, "", False)
```


```
client.reqAccountUpdatesMulti(reqId, "U1234567", "", false);
```


```
m_pClient->reqAccountUpdatesMulti(reqId, "U1234567", "", true);
```


```
client.reqAccountUpdatesMulti(reqId, "U1234567", "", false);
```


```
client.reqAccountUpdatesMulti(reqId, "U1234567", "", False)
```


```
self.reqFamilyCodes()
```


```
client.reqFamilyCodes();
```


```
m_pClient->reqFamilyCodes();
```


```
client.reqFamilyCodes()
```


```
client.reqFamilyCodes()
```


```
def familyCodes(self, familyCodes: ListOfFamilyCode):
    print("Family Codes:", familyCode)
```


```
@Override
public void familyCodes(FamilyCode[] familyCodes) {
    System.out.print(EWrapperMsgGenerator.familyCodes(familyCodes));
}
```


```
void TestCppClient::familyCodes(const std::vector<FamilyCode> &familyCodes) {
    printf("Family codes (%lu):\n", familyCodes.size());
    for (unsigned int i = 0; i < familyCodes.size(); i++) {
        printf("Family code [%d] - accountID: %s familyCodeStr: %s\n", i, familyCodes[i].accountID.c_str(), familyCodes[i].familyCodeStr.c_str());
    }
}
```


```
public void familyCodes(FamilyCode[] familyCodes)
{
  Console.WriteLine("Family Codes:");
  foreach (var familyCode in familyCodes)
  {
    Console.WriteLine("Account ID: {0}, Family Code Str: {1}", familyCode.AccountID, familyCode.FamilyCodeStr);
  }
}
```


```
Public Sub familyCodes(familyCodes As FamilyCode()) Implements EWrapper.familyCodes
  Console.WriteLine("Family Codes:")
  For Each familyCode In familyCodes
    Console.WriteLine("Account ID: " & familyCode.AccountID & " Family Code Str: " & familyCode.FamilyCodeStr)
  Next
End Sub
```


```
self.reqManagedAccts()
```


```
client.reqManagedAccts();
```


```
m_pClient->reqManagedAccts();
```


```
client.reqManagedAccts();
```


```
client.reqManagedAccts()
```


```
def managedAccounts(self, accountsList: str):
    print("Account list:", accountsList)
```


```
@Override
public void managedAccounts(String accountsList) {
	System.out.println("Account list: " + accountsList);
}
```


```
void TestCppClient::managedAccounts( const std::string& accountsList) {
    printf( "Account List: %s\n", accountsList.c_str());
}
```


```
public virtual void managedAccounts(string accountsList) 
{
	Console.WriteLine("Account list: "+accountsList);
}
```


```
Public Sub managedAccounts(accountsList As String) Implements IBApi.EWrapper.managedAccounts
	Console.WriteLine("ManagedAccounts - AccountsList [" & accountsList & "]")
End Sub
```


```
self.reqPositions()
```


```
from ibapi.client import *
from ibapi.wrapper import *
import threading
import time

class TradingApp(EWrapper, EClient):
    def __init__(self):
        EClient.__init__(self,self)

    def position(self, account: str, contract: Contract, position: Decimal, avgCost: float):
        print("Position.", "Account:", account, "Contract:", contract, "Position:", position, "Avg cost:", avgCost)
        
    def positionEnd(self):
       print("PositionEnd")
       
def websocket_con():
    app.run()
    
app = TradingApp()      
app.connect("127.0.0.1", 7496, clientId=1)

con_thread = threading.Thread(target=websocket_con, daemon=True)
con_thread.start()
time.sleep(1) 

app.reqPositions()
time.sleep(1)
```


```
client.reqPositions();
```


```
m_pClient->reqPositions();
```


```
client.reqPositions();
```


```
client.reqPositions()
```


```
def position(self, account: str, contract: Contract, position: Decimal, avgCost: float):
  print("Position.", "Account:", account, "Contract:", contract, "Position:", position, "Avg cost:", avgCost)
```


```
@Override
public void position(String account, Contract contract, Decimal pos, double avgCost) {
    System.out.println(EWrapperMsgGenerator.position(account, contract, pos, avgCost));
}
```


```
@Override
public void position(String account, Contract contract, Decimal pos, double avgCost) {
    System.out.println(EWrapperMsgGenerator.position(account, contract, pos, avgCost));
}
```


```
public virtual void position(string account, Contract contract, decimal pos, double avgCost)
{
Console.WriteLine("Position. " + account + " - Symbol: " + contract.Symbol + ", SecType: " + contract.SecType + ", Currency: " + contract.Currency + ", Position: " + Util.DecimalMaxString(pos) + ", Avg cost: " + Util.DoubleMaxString(avgCost));
}
```


```
Public Sub position(account As String, contract As IBApi.Contract, pos As Decimal, avgCost As Double) Implements IBApi.EWrapper.position
  Console.WriteLine("Position. " & account & " - Symbol: " & contract.Symbol & ", SecType: " & contract.SecType & ", Currency: " &  contract.Currency & ", Position: " & Util.DecimalMaxString(pos) & ", Avg cost: " & Util.DoubleMaxString(avgCost))
End Sub
```


```
def positionEnd(self):
  print("PositionEnd")
```


```
@Override
public void positionEnd() {
	System.out.println("Position End: " + EWrapperMsgGenerator.positionEnd());
}
```


```
void TestCppClient::positionEnd() {
    printf( "PositionEnd\n");
}
```


```
public virtual void positionEnd()
{
	Console.WriteLine("PositionEnd \n");
}
```


```
Public Sub positionEnd() Implements IBApi.EWrapper.positionEnd
	Console.WriteLine("PositionEnd")
End Sub
```


```
self.cancelPositions()
```


```
client.cancelPositions();
```


```
m_pClient->cancelPositions();
```


```
client.cancelPositions()
```


```
client.cancelPositions()
```


```
self.reqPositionsMulti(requestid, "U1234567", "")
```


```
from ibapi.client import *
from ibapi.wrapper import *
import threading
import time

class TradingApp(EWrapper, EClient):
    def __init__(self):
        EClient.__init__(self,self)
            
    def positionMulti(self, reqId: int, account: str, modelCode: str, contract: Contract, pos: Decimal, avgCost: float):
       print("PositionMulti. RequestId:", reqId, "Account:", account, "ModelCode:", modelCode, "Contract:", contract, ",Position:", pos, "AvgCost:", avgCost)         
        
    def positionMultiEnd(self, reqId: int):
        print("")
        print("PositionMultiEnd. RequestId:", reqId)       

def websocket_con():
    app.run()
    
app = TradingApp()      
app.connect("127.0.0.1", 7497, clientId=1)

con_thread = threading.Thread(target=websocket_con, daemon=True)
con_thread.start()
time.sleep(1) 

app.reqPositionsMulti(2, "DU1234567", "")  #To specify a U-account number
time.sleep(1)

app.reqPositionsMulti(3, "Group1", "")     #To specify a Financial Advisor Group / Profile 
time.sleep(1)
```


```
client.reqPositionsMulti(requestid, "U1234567", "");
```


```
m_pClient->reqPositionsMulti(requestid, "U1234567", "");
```


```
client.reqPositionsMulti(requestid, "U1234567", "");
```


```
client.reqPositionsMulti(requestid, "U1234567", "")
```


```
def positionMulti(self, reqId: int, account: str, modelCode: str, contract: Contract, pos: Decimal, avgCost: float):
  print("PositionMulti. RequestId:", reqId, "Account:", account, "ModelCode:", modelCode, "Contract:", contract, ",Position:", pos, "AvgCost:", avgCost)
```


```
@Override
public void positionMulti(int reqId, String account, String modelCode, Contract contract, Decimal pos, double avgCost) {
	System.out.println(EWrapperMsgGenerator.positionMulti(reqId, account, modelCode, contract, pos, avgCost));
}
```


```
void TestCppClient::positionMulti( int reqId, const std::string& account,const std::string& modelCode, const Contract& contract, Decimal pos, double avgCost) {
    printf("Position Multi. Request: %d, Account: %s, ModelCode: %s, Symbol: %s, SecType: %s, Currency: %s, Position: %s, Avg Cost: %s\n", reqId, account.c_str(), modelCode.c_str(), contract.symbol.c_str(), contract.secType.c_str(), contract.currency.c_str(), decimalStringToDisplay(pos).c_str(), Utils::doubleMaxString(avgCost).c_str());
}
```


```
public virtual void positionMulti(int reqId, string account, string modelCode, Contract contract, decimal pos, double avgCost)
{
	Console.WriteLine("Position Multi. Request: " + reqId + ", Account: " + account + ", ModelCode: " + modelCode + ", contract: " + contract + ", Position: " + Util.DecimalMaxString(pos) + ", Avg cost: " + Util.DoubleMaxString(avgCost) + "\n");
}
```


```
Public Sub positionMulti(requestId As Integer, account As String, modelCode As String, contract As Contract, pos As Decimal, avgCost As Double) Implements IBApi.EWrapper.positionMulti
	Console.WriteLine("PositionMulti. Id: " & requestId & ", Account: " & account & ", ModelCode: " & modelCode & ", Contract: " & contract.Symbol & ", pos: " & Util.DecimalMaxString(pos) & ", avgCost: " & Util.DoubleMaxString(avgCost))
End Sub
```


```
def positionMultiEnd(self, reqId: int):
	print("PositionMultiEnd. RequestId:", reqId)
```


```
@Override
public void positionMultiEnd(int reqId) {
	System.out.println("Position Multi End: " + EWrapperMsgGenerator.positionMultiEnd(reqId));
}
```


```
void TestCppClient::positionMultiEnd( int reqId) {
    printf("Position Multi End. Request: %d\n", reqId);
}
```


```
public virtual void positionMultiEnd(int reqId)
{
	Console.WriteLine("Position Multi End. Request: " + reqId + "\n");
}
```


```
Public Sub positionMultiEnd(requestId As Integer) Implements IBApi.EWrapper.positionMultiEnd
	Console.WriteLine("PositionMultiEnd")
End Sub
```


```
self.cancelPositionsMulti(requestid)
```


```
client.cancelPositionsMulti(requestid);
```


```
m_pClient->cancelPositionsMulti(requestid);
```


```
client.cancelPositionsMulti(requestid);
```


```
client.cancelPositionsMulti(requestid)
```


```
self.reqPnLSingle(requestId, "U1234567", "", 265598)
```


```
from ibapi.client import *
from ibapi.wrapper import *
import time

class TradeApp(EWrapper, EClient): 
    def __init__(self): 
        EClient.__init__(self, self) 

    def pnlSingle(self, reqId: int, pos: Decimal, dailyPnL: float, unrealizedPnL: float, realizedPnL: float, value: float):
        print("Daily PnL Single. ReqId:", reqId, "Position:", pos, "DailyPnL:", dailyPnL, "UnrealizedPnL:", unrealizedPnL, "RealizedPnL:", realizedPnL, "Value:", value)
    
app = TradeApp()      
app.connect("127.0.0.1", 7496, clientId=1)

time.sleep(1)
app.reqPnLSingle(101, "U123456", "", 8314) #IBM conId: 8314

app.run()
```


```
client.reqPnLSingle(requestId, "U1234567", "", 265598);
```


```
m_pClient->reqPnLSingle(requestId, "U1234567", "", 265598);
```


```
client.reqPnLSingle(requestId, "U1234567", "", 265598);
```


```
client.reqPnLSingle(requestId, "U1234567", "", 265598)
```


```
def pnlSingle(self, reqId: int, pos: Decimal, dailyPnL: float, unrealizedPnL: float, realizedPnL: float, value: float):
  print("Daily PnL Single. ReqId:", reqId, "Position:", pos, "DailyPnL:", dailyPnL, "UnrealizedPnL:", unrealizedPnL, "RealizedPnL:", realizedPnL, "Value:", value)
```


```
@Override
public void pnlSingle(int reqId, Decimal pos, double dailyPnL, double unrealizedPnL, double realizedPnL, double value) {
  System.out.println(EWrapperMsgGenerator.pnlSingle(reqId, pos, dailyPnL, unrealizedPnL, realizedPnL, value));                
}
```


```
void TestCppClient::pnlSingle(int reqId, Decimal pos, double dailyPnL, double unrealizedPnL, double realizedPnL, double value) {
    printf("PnL Single. ReqId: %d, pos: %s, daily PnL: %s, unrealized PnL: %s, realized PnL: %s, value: %s\n", reqId, decimalStringToDisplay(pos).c_str(), Utils::doubleMaxString(dailyPnL).c_str(), Utils::doubleMaxString(unrealizedPnL).c_str(), Utils::doubleMaxString(realizedPnL).c_str(), Utils::doubleMaxString(value).c_str());
}
```


```
public void pnlSingle(int reqId, decimal pos, double dailyPnL, double unrealizedPnL, double realizedPnL, double value)
{
	Console.WriteLine("PnL Single. Request Id: {0}, Pos {1}, Daily PnL {2}, Unrealized PnL {3}, Realized PnL: {4}, Value: {5}", reqId, Util.DecimalMaxString(pos), Util.DoubleMaxString(dailyPnL), Util.DoubleMaxString(unrealizedPnL),
		Util.DoubleMaxString(realizedPnL), Util.DoubleMaxString(value));
}
```


```
Public Sub pnlSingle(reqId As Integer, pos As Decimal, dailyPnL As Double, unrealizedPnL As Double, realizedPnL As Double, value As Double) Implements EWrapper.pnlSingle
	Console.WriteLine("PnL Single. Request Id: {0}, pos: {1}, daily PnL: {2}, unrealized PnL: {3}, realized PnL: {4}, value: {5}", reqId, Util.DecimalMaxString(pos), Util.DoubleMaxString(dailyPnL), Util.DoubleMaxString(unrealizedPnL), Util.DoubleMaxString(realizedPnL), Util.DoubleMaxString(value))
End Sub
```


```
self.cancelPnLSingle(requestId);
```


```
client.cancelPnLSingle(reqId);
```


```
m_pClient->cancelPnLSingle(reqId);
```


```
client.cancelPnLSingle(reqId);
```


```
client.cancelPnLSingle(reqId);
```


```
self.reqPnL(reqId, "U1234567", "")
```


```
from ibapi.client import *
from ibapi.wrapper import *
import time

class TradeApp(EWrapper, EClient): 
    def __init__(self): 
        EClient.__init__(self, self) 

    def pnl(self, reqId: int, dailyPnL: float, unrealizedPnL: float, realizedPnL: float):
        print("Daily PnL. ReqId:", reqId, "DailyPnL:", dailyPnL, "UnrealizedPnL:", unrealizedPnL, "RealizedPnL:", realizedPnL)
    
app = TradeApp()      
app.connect("127.0.0.1", 7496, clientId=1)

time.sleep(1)
app.reqPnL(102, "U123456", "")

app.run()
```


```
client.reqPnL(reqId, "U1234567", "");
```


```
m_pClient->reqPnL(reqId, "U1234567", "");
```


```
client.reqPnL(reqId, "U1234567", "");
```


```
client.reqPnL(reqId, "U1234567", "")
```


```
def pnl(self, reqId: int, dailyPnL: float, unrealizedPnL: float, realizedPnL: float):
  print("Daily PnL. ReqId:", reqId, "DailyPnL:", dailyPnL, "UnrealizedPnL:", unrealizedPnL, "RealizedPnL:", realizedPnL)
```


```
@Override
public void pnl(int reqId, double dailyPnL, double unrealizedPnL, double realizedPnL) {
	System.out.println(EWrapperMsgGenerator.pnl(reqId, dailyPnL, unrealizedPnL, realizedPnL));
}
```


```
void TestCppClient::pnl(int reqId, double dailyPnL, double unrealizedPnL, double realizedPnL) {
    printf("PnL. ReqId: %d, daily PnL: %s, unrealized PnL: %s, realized PnL: %s\n", reqId, Utils::doubleMaxString(dailyPnL).c_str(), Utils::doubleMaxString(unrealizedPnL).c_str(), 
        Utils::doubleMaxString(realizedPnL).c_str());
}
```


```
public void pnl(int reqId, double dailyPnL, double unrealizedPnL, double realizedPnL)
{
	Console.WriteLine("PnL. Request Id: {0}, Daily PnL: {1}, Unrealized PnL: {2}, Realized PnL: {3}", reqId, Util.DoubleMaxString(dailyPnL), Util.DoubleMaxString(unrealizedPnL), Util.DoubleMaxString(realizedPnL));
}
```


```
Public Sub pnl(reqId As Integer, dailyPnL As Double, unrealizedPnL As Double, realizedPnL As Double) Implements EWrapper.pnl
	Console.WriteLine("PnL. Request Id: {0}, daily PnL: {1}, unrealized PnL: {2}, realized PnL: {3}", reqId, Util.DoubleMaxString(dailyPnL), Util.DoubleMaxString(unrealizedPnL), Util.DoubleMaxString(realizedPnL))
End Sub
```


```
self.cancelPnL(reqId)
```


```
client.cancelPnL(reqId);
```


```
m_pClient->cancelPnL(7001);
```


```
client.cancelPnL(reqId);
```


```
client.cancelPnL(reqId)
```


```
self.reqUserInfo(reqId)
```


```
client.reqUserInfo(reqId);
```


```
m_pClient->reqUserInfo(0);
```


```
client.reqUserInfo(reqId);
```


```
client.reqUserInfo(reqId)
```


```
def userInfo(self, reqId: int, whiteBrandingId: str):
	print("UserInfo.", "ReqId:", reqId, "WhiteBrandingId:", whiteBrandingId)
```


```
@Override
public void userInfo(int reqId, String whiteBrandingId) {
	System.out.println(EWrapperMsgGenerator.userInfo(reqId, whiteBrandingId));
}
```


```
void TestCppClient::userInfo(int reqId, const std::string& whiteBrandingId) {
    printf("User Info. ReqId: %d, WhiteBrandingId: %s\n", reqId, whiteBrandingId.c_str());
}
```


```
public void userInfo(int reqId, string whiteBrandingId)
{
	Console.WriteLine($"User Info. ReqId: {reqId}, WhiteBrandingId: {whiteBrandingId}");
}
```


```
Public Sub userInfo(reqId As Integer, whiteBrandingId As String) Implements EWrapper.userInfo
  Console.WriteLine($"User Info. ReqId: {reqId}, WhiteBrandingId: {whiteBrandingId}")
End Sub
```


```
self.reqNewsBulletins(True)
```


```
client.reqNewsBulletins(true);
```


```
m_pClient->reqNewsBulletins(true);
```


```
client.reqNewsBulletins(true);
```


```
client.reqNewsBulletins(True)
```


```
def updateNewsBulletin(self, msgId: int, msgType: int, newsMessage: str, originExch: str):
  print("News Bulletins. MsgId:", msgId, "Type:", msgType, "Message:", newsMessage, "Exchange of Origin: ", originExch)
```


```
@Override
public void updateNewsBulletin(int msgId, int msgType, String message, String origExchange) {
	System.out.println("News Bulletin: " + EWrapperMsgGenerator.updateNewsBulletin( msgId, msgType, message, origExchange));
}
```


```
void TestCppClient::updateNewsBulletin(int msgId, int msgType, const std::string& newsMessage, const std::string& originExch) {
    printf( "News Bulletins. %d - Type: %d, Message: %s, Exchange of Origin: %s\n", msgId, msgType, newsMessage.c_str(), originExch.c_str());
}
```


```
public virtual void updateNewsBulletin(int msgId, int msgType, String message, String origExchange)
{
	Console.WriteLine("News Bulletins. "+msgId+" - Type: "+msgType+", Message: "+message+", Exchange of Origin: "+origExchange+"\n");
}
```


```
Public Sub updateNewsBulletin(msgId As Integer, msgType As Integer, message As String, origExchange As String) Implements IBApi.EWrapper.updateNewsBulletin
	Console.WriteLine("News Bulletins. " & msgId & " - Type: " & msgType & ", Message: " & message & ", Exchange of Origin: " & origExchange)
End Sub
```


```
self.cancelNewsBulletins()
```


```
client.cancelNewsBulletins();
```


```
m_pClient->cancelNewsBulletins();
```


```
client.cancelNewsBulletin();
```


```
client.cancelNewsBulletin()
```


```
self.reqContractDetails(reqId, contract)
```


```
client.reqContractDetails(reqId, contract)
```


```
m_pClient->reqContractDetails(reqId, contract);
```


```
client.reqContractDetails(reqId, contract);
```


```
client.reqContractDetails(reqId, contract)
```


```
def contractDetails(self, reqId: int, contractDetails: ContractDetails):
  print(reqId, contractDetails)
```


```
@Override
public void contractDetails(int reqId, ContractDetails contractDetails) {
	System.out.println(EWrapperMsgGenerator.contractDetails(reqId, contractDetails)); 
}
```


```
void TestCppClient::contractDetails( int reqId, const ContractDetails& contractDetails) {
    printf( "ContractDetails. ReqId: %d\n", reqId);
    printContractDetailsMsg(contractDetails);
}
```


```
public virtual void contractDetails(int reqId, ContractDetails contractDetails)
{
	Console.WriteLine("ContractDetails. ReqId: " + reqId);
	printContractDetailsMsg(contractDetails);
}
```


```
Public Sub contractDetails(reqId As Integer, contractDetails As IBApi.ContractDetails) Implements IBApi.EWrapper.contractDetails
	Console.WriteLine("ContractDetails. ReqId: " & reqId)
	printContractDetailsMsg(contractDetails)
End Sub
```


```
def contractDetailsEnd(self, reqId: int):
	print("ContractDetailsEnd. ReqId:", reqId)
```


```
@Override
public void contractDetailsEnd(int reqId) {
	System.out.println("Contract Details End: " + EWrapperMsgGenerator.contractDetailsEnd(reqId));
}
```


```
void TestCppClient::contractDetailsEnd( int reqId) {
    printf( "ContractDetailsEnd. %d\n", reqId);
}
```


```
public virtual void contractDetailsEnd(int reqId)
{
	Console.WriteLine("ContractDetailsEnd. "+reqId+"\n");
}
```


```
Public Sub contractDetailsEnd(reqId As Integer) Implements IBApi.EWrapper.contractDetailsEnd
            Console.WriteLine("ContractDetailsEnd - ReqId [" & reqId & "]")
        End Sub
```


```
def bondContractDetails(self, reqId: int, contractDetails: ContractDetails):
  printinstance(reqId, contractDetails)
```


```
@Override
public void bondContractDetails(int reqId, ContractDetails contractDetails) {
	System.out.println(EWrapperMsgGenerator.contractDetails(reqId, contractDetails)); 
}
```


```
void TestCppClient::bondContractDetails( int reqId, const ContractDetails& contractDetails) {
    printf( "BondContractDetails. ReqId: %d\n", reqId);
    printContractDetailsMsg(contractDetails);
}
```


```
public virtual void bondContractDetails(int reqId, ContractDetails contractDetails)
{
	Console.WriteLine("BondContractDetails. ReqId: " + reqId);
	printContractDetailsMsg(contractDetails);
}
```


```
Public Sub bondContractDetails(reqId As Integer, contractDetails As IBApi.ContractDetails) Implements IBApi.EWrapper.contractDetails
	Console.WriteLine("BondContractDetails. ReqId: " & reqId)
	printContractDetailsMsg(contractDetails)
End Sub
```


```
self.reqSecDefOptParams(0, "IBM", "", "STK", 8314)
```


```
client.reqSecDefOptParams(0, "IBM", "", "STK", 8314);
```


```
m_pClient->reqSecDefOptParams(0, "IBM", "", "STK", 8314);
```


```
client.reqSecDefOptParams(0, "IBM", "", "STK", 8314);
```


```
client.reqSecDefOptParams(0, "IBM", "", "STK", 8314)
```


```
def securityDefinitionOptionParameter(self, reqId: int, exchange: str, underlyingConId: int, tradingClass: str, multiplier: str, expirations: SetOfString, strikes: SetOfFloat):
  print("SecurityDefinitionOptionParameter.", "ReqId:", reqId, "Exchange:", exchange, "Underlying conId:", underlyingConId, "TradingClass:", tradingClass, "Multiplier:", multiplier, "Expirations:", expirations, "Strikes:", strikes)
```


```
@Override
public void securityDefinitionOptionalParameter(int reqId, String exchange, int underlyingConId, String tradingClass, String multiplier, Set expirations, Set strikes) {
	System.out.println("Security Definition Optional Parameter: " + EWrapperMsgGenerator.securityDefinitionOptionalParameter(reqId, exchange, underlyingConId, tradingClass, multiplier, expirations, strikes));
}
```


```
void TestCppClient::securityDefinitionOptionalParameter(int reqId, const std::string& exchange, int underlyingConId, const std::string& tradingClass,
                                                        const std::string& multiplier, const std::set& expirations, const std::set& strikes) {
    printf("Security Definition Optional Parameter. Request: %d, Trading Class: %s, Multiplier: %s\n", reqId, tradingClass.c_str(), multiplier.c_str());
}
```


```
public void securityDefinitionOptionParameter(int reqId, string exchange, int underlyingConId, string tradingClass, string multiplier, HashSet expirations, HashSet strikes)
{
	Console.WriteLine("Security Definition Option Parameter. Reqest: {0}, Exchange: {1}, Undrelying contract id: {2}, Trading class: {3}, Multiplier: {4}, Expirations: {5}, Strikes: {6}", reqId, exchange, Util.IntMaxString(underlyingConId), tradingClass, multiplier, string.Join(", ", expirations), string.Join(", ", strikes));
}
```


```
Public Sub securityDefinitionOptionParameter(reqId As Integer, exchange As String, underlyingConId As Integer, tradingClass As String, multiplier As String, expirations As HashSet(Of String), strikes As HashSet(Of Double)) Implements EWrapper.securityDefinitionOptionParameter
            Console.WriteLine("securityDefinitionOptionParameter: " & reqId & " tradingClass: " & tradingClass & " multiplier: ")
End Sub
```


```
self.reqMatchingSymbols(reqId, "IBM")
```


```
client.reqMatchingSymbols(reqId, "IB");
```


```
m_pClient->reqMatchingSymbols(reqId, "IBM");
```


```
client.reqMatchingSymbols(reqId, "IBM");
```


```
client.reqMatchingSymbols(reqId, "IBM")
```


```
def symbolSamples(self, reqId: int, contractDescriptions: ListOfContractDescription):
	print("Symbol Samples. Request Id: ", reqId)
	for contractDescription in contractDescriptions:
		derivSecTypes = ""
		for derivSecType in contractDescription.derivativeSecTypes:
			derivSecTypes += " "
			derivSecTypes += derivSecType
			print("Contract: conId:%s, symbol:%s, secType:%s primExchange:%s, "
				"currency:%s, derivativeSecTypes:%s, description:%s, issuerId:%s" % (
				contractDescription.contract.conId,
				contractDescription.contract.symbol,
				contractDescription.contract.secType,
				contractDescription.contract.primaryExchange,
				contractDescription.contract.currency, derivSecTypes,
				contractDescription.contract.description,
				contractDescription.contract.issuerId))
```


```
@Override
public void symbolSamples(int reqId, ContractDescription[] contractDescriptions) {
	System.out.println(EWrapperMsgGenerator.symbolSamples(reqId, contractDescriptions));
}
```


```
void TestCppClient::symbolSamples(int reqId, const std::vector &contractDescriptions) {
    printf("Symbol Samples (total=%lu) reqId: %d\n", contractDescriptions.size(), reqId);
    for (unsigned int i = 0; i < contractDescriptions.size(); i++) {
        Contract contract = contractDescriptions[i].contract;
        std::vector derivativeSecTypes = contractDescriptions[i].derivativeSecTypes;
        printf("Contract (%u): conId: %ld, symbol: %s, secType: %s, primaryExchange: %s, currency: %s, ", i, contract.conId, contract.symbol.c_str(), contract.secType.c_str(), contract.primaryExchange.c_str(), contract.currency.c_str());
        printf("Derivative Sec-types (%lu):", derivativeSecTypes.size());
        for (unsigned int j = 0; j < derivativeSecTypes.size(); j++) {
            printf(" %s", derivativeSecTypes[j].c_str());
        }
        printf(", description: %s, issuerId: %s", contract.description.c_str(), contract.issuerId.c_str());
        printf("\n");
    }
}
```


```
public void symbolSamples(int reqId, ContractDescription[] contractDescriptions) 
{
	string derivSecTypes;
	Console.WriteLine("Symbol Samples. Request Id: {0}", reqId);
	foreach (var contractDescription in contractDescriptions)
	{
		derivSecTypes = "";
		foreach (var derivSecType in contractDescription.DerivativeSecTypes)
		{
			derivSecTypes += derivSecType;
			derivSecTypes += " ";
		}
		Console.WriteLine("Contract: conId - {0}, symbol - {1}, secType - {2}, primExchange - {3}, currency - {4}, derivativeSecTypes - {5}, description - {6}, issuerId - {7}", 
			contractDescription.Contract.ConId, contractDescription.Contract.Symbol, contractDescription.Contract.SecType, 
			contractDescription.Contract.PrimaryExch, contractDescription.Contract.Currency, derivSecTypes, contractDescription.Contract.Description, contractDescription.Contract.IssuerId);
	}
}
```


```
Public Sub symbolSamples(reqId As Integer, contractDescriptions As ContractDescription()) Implements EWrapper.symbolSamples
	Dim derivSecTypes As String
	Console.WriteLine("Symbol Samples. Request Id: " & reqId)
	For Each contractDescription In contractDescriptions
		derivSecTypes = ""
		For Each derivSecType In contractDescription.DerivativeSecTypes
			derivSecTypes += derivSecType
			derivSecTypes += " "
		Next
		Console.WriteLine("Contract conId: " & contractDescription.Contract.ConId & ", symbol: " & contractDescription.Contract.Symbol &
						  ", secType: " & contractDescription.Contract.SecType & ", primExchange: " & contractDescription.Contract.PrimaryExch &
						  ", currency: " & contractDescription.Contract.Currency & ", derivativeSecTypes: " & derivSecTypes &
						  ", description: " & contractDescription.Contract.Description & ", issuerId: " & contractDescription.Contract.IssuerId)
	Next
End Sub
```


```
"PRODUCT EXPIRATION STRIKE RIGHT"
```


```
PRODUCT
```


```
EXPIRATION
```


```
MmmDD'YY
```


```
STRIKE
```


```
RIGHT
```


```
contract= Contract()
contract.symbol = "GCE"
contract.secType = "OPT"
contract.currency = "USD"
contract.exchange = "FORECASTX"
contract.lastTradeDateOrContractMonth = "20251231"
contract.right = "C"
contract.strike = 40500
```


```
Contract contract = new Contract();
contract.symbol("GCE");
contract.secType("OPT");
contract.currency("USD");
contract.exchange("FORECASTX");
contract.lastTradeDateOrContractMonth("20251231");
contract.right("C");
contract.strike(40500);
```


```
Contract contract;
contract.symbol = "GCE";
contract.secType = "OPT";
contract.currency = "USD";
contract.exchange = "FORECASTX";
contract.lastTradeDateOrContractMonth = "20251231";
contract.right = "C";
contract.strike = 40500;
```


```
Contract contract = new Contract();
contract.Symbol = "GCE";
contract.SecType = "OPT";
contract.Currency = "USD";
contract.Exchange = "FORECASTX";
contract.LastTradeDateOrContractMonth = "20251231";
contract.Right = "C";
contract.Strike = 40500;
```


```
order = Order()
order.action = "BUY"
order.orderType = "LMT"
order.totalQuantity = 1000
order.lmtPrice = 0.57
```


```
Order order = new Order();
order.action("BUY");
order.orderType("LMT");
order.totalQuantity(1000);
order.lmtPrice(0.57);
```


```
Order order;
order.action = "BUY";
order.orderType = "LMT";
order.totalQuantity = 1000;
order.lmtPrice = 0.57;
```


```
Order order = new Order();
order.Action = "BUY";
order.OrderType = "LMT";
order.TotalQuantity = 1000;
order.LmtPrice = 0.57;
```


```
def error(self, reqId: TickerId, errorTime: int, errorCode: int, errorString: str, advancedOrderRejectJson = ""):
  print("Error. Id:", reqId, errorTime, "Code:", errorCode, "Msg:", errorString, "AdvancedOrderRejectJson:", advancedOrderRejectJson)
```


```
@Override
public void error(int id, long errorTime, int errorCode, String errorMsg, String advancedOrderRejectJson) {
  String str = "Error. Id: " + id + ", Code: " + errorCode + ", Msg: " + errorMsg;
  if (advancedOrderRejectJson != null) {
    str += (", AdvancedOrderRejectJson: " + advancedOrderRejectJson);
  }
  System.out.println(str + "\n");
}
```


```
void TestCppClient::error(int id, time_t errorTime, int errorCode, const std::string& errorString, const std::string& advancedOrderRejectJson)
{
    printf("Error. Id: %d, Timestamp: %d, Code: %d, Msg: %s, AdvancedOrderRejectJson: %s\n", id, errorTime, errorCode, errorString.c_str(), advancedOrderRejectJson.c_str());
}
```


```
public virtual void error(int id, long errorTime, int errorCode, string errorMsg, string advancedOrderRejectJson)
{
  Console.WriteLine("Error. Id: " + id + "Timestamp: " + errorTime + ", Code: " + errorCode + ", Msg: " + errorMsg + ", AdvancedOrderRejectJson: " + advancedOrderRejectJson + "\n");
}
```


```
Public Sub [error](id As Integer, errorCode As Integer, errorMsg As String, advancedOrderRejectJson As String) Implements IBApi.EWrapper.error
            Console.WriteLine("Error - Id [" & id & "] ErrorCode [" & errorCode & "] ErrorMsg [" & errorMsg & "] AdvancedOrderRejectJson [" & advancedOrderRejectJson & "]")
End Sub
```


```
self.requestFA(1)
```


```
client.requestFA(1);
```


```
m_pClient->requestFA(1);
```


```
client.requestFA(1);
```


```
client.requestFA(1)
```


```
def receiveFA(self, faData: FaDataType, cxml: str):
	print("Receiving FA: ", faData)
	open('log/fa.xml', 'w').write(cxml)
```


```
@Override
public void receiveFA(int faDataType, String xml) {
	System.out.println("Receiving FA: " + faDataType + " - " + xml);
}
```


```
void TestCppClient::receiveFA(faDataType pFaDataType, const std::string& cxml) {
    std::cout << "Receiving FA: " << (int)pFaDataType << std::endl << cxml << std::endl;
}
```


```
public virtual void receiveFA(int faDataType, string faXmlData)
{
	Console.WriteLine("Receing FA: "+faDataType+" - "+faXmlData);
}
```


```
Public Sub receiveFA(faDataType As Integer, faXmlData As String) Implements IBApi.EWrapper.receiveFA
  Console.WriteLine("Receing FA: " & faDataType & " - " & faXmlData)
End Sub
```


```
self.replaceFa(reqId, 1, xml)
```


```
client.replaceFa(reqId, 1, xml);
```


```
m_pClient->replaceFa(reqId, 1, xml);
```


```
client.replaceFa(reqId, 1, xml);
```


```
client.replaceFa(reqId, 1, xml)
```


```
def replaceFAEnd(self, reqId: int, text: str):
    super().replaceFAEnd(reqId, text)
    print("ReplaceFAEnd.", "ReqId:", reqId, "Text:", text)
```


```
@Override
public void replaceFAEnd(int reqId, String text) {
        System.out.println(EWrapperMsgGenerator.replaceFAEnd(reqId, text));
}
```


```
void TestCppClient::replaceFAEnd(int reqId, const std::string& text) {
    printf("Replace FA End. Request: %d, Text:%s\n", reqId, text.c_str());
}
```


```
public virtual void replaceFAEnd(int reqId, string text)
{
    Console.WriteLine("Replace FA End. ReqId: " + reqId + ", Text: " + text + "\n");
}
```


```
Public Sub replaceFAEnd(reqId As Integer, text As String) Implements IBApi.EWrapper.replaceFAEnd
    Console.WriteLine("replaceFAEnd. ReqId: {0}, Text: {1}", reqId, text)
End Sub
```


```
<?xml version="1.0" encoding="UTF-8"?>
<ListOfGroups>
  <Group>
    <name>MyTestProfile2</name>
    <defaultMethod>AvailableEquity</defaultMethod>
    <ListOfAccts varName="list">
      <Account>
        <acct>DU6202167</acct>
      </Account>
      <Account>
        <acct>DU6202168</acct>
      </Account>
    </ListOfAccts>
  </Group>
</ListOfGroups>
```


```
<?xml version="1.0" encoding="UTF-8"?>
<ListOfGroups>
  <Group>
  <name>MyTestProfile2</name>
  <defaultMethod>ContractsOrShares</defaultMethod>
  
  <ListOfAccts varName="list">
  <Account>
    <acct>DU6202167</acct>
    <amount>100.0</amount>
  </Account>
  <Account>
    <acct>DU6202168</acct>
    <amount>200.0</amount>
  </Account>
  </ListOfAccts>
  </Group>
</ListOfGroups>
```


```
<?xml version="1.0" encoding="UTF-8"?>
<ListOfGroups>
  <Group>
    <name>MyTestProfile2</name>
    <defaultMethod>Equal</defaultMethod>
    <ListOfAccts varName="list">
      <Account>
        <acct>DU6202167</acct>
      </Account>
      <Account>
        <acct>DU6202168</acct>
      </Account>
    </ListOfAccts>
  </Group>
</ListOfGroups>
```


```
<?xml version="1.0" encoding="UTF-8"?>
<ListOfGroups>
  <Group>
  <name>MyTestProfile2</name>
  <defaultMethod>MonetaryAmount</defaultMethod>
  
  <ListOfAccts varName="list">
  <Account>
    <acct>DU6202167</acct>
    <amount>1000.0</amount>
  </Account>
  <Account>
    <acct>DU6202168</acct>
    <amount>2000.0</amount>
  </Account>
  </ListOfAccts>
  </Group>
</ListOfGroups>
```


```
<?xml version="1.0" encoding="UTF-8"?>
<ListOfGroups>
  <Group>
    <name>MyTestProfile2</name>
    <defaultMethod>NetLiq</defaultMethod>
    <ListOfAccts varName="list">
      <Account>
        <acct>DU6202167</acct>
      </Account>
      <Account>
        <acct>DU6202168</acct>
      </Account>
    </ListOfAccts>
  </Group>
</ListOfGroups>
```


```
<?xml version="1.0" encoding="UTF-8"?>
<ListOfGroups>
  <Group>
  <name>MyTestProfile2</name>
  <defaultMethod>Percent</defaultMethod>
  <ListOfAccts varName="list">
  <Account>
    <acct>DU6202167</acct>
    <amount>60.0</amount>
  </Account>
  <Account>
    <acct>DU6202168</acct>
    <amount>40.0</amount>
  </Account>
  </ListOfAccts>
  </Group>
</ListOfGroups>
```


```
<?xml version="1.0" encoding="UTF-8"?>
<ListOfGroups>
  <Group>
  <name>MyTestProfile2</name>
  <defaultMethod>Ratio</defaultMethod>
  
  <ListOfAccts varName="list">
  <Account>
    <acct>DU6202167</acct>
    <amount>1.0</amount>
  </Account>
  <Account>
    <acct>DU6202168</acct>
    <amount>2.0</amount>
  </Account>
  </ListOfAccts>
  </Group>
</ListOfGroups>
```


```
modelOrder = Order()
modelOrder.account = "DF12345"
modelOrder.modelCode = "Technology" # model for tech stocks first created in TWS
self.placeOrder(self.nextOrderId(), contract, modelOrder)
```


```
Order modelOrder = Order();
modelOrder.account("DF12345");  // master FA account number
modelOrder.modelCode("Technology"); // model for tech stocks first created in TWS
client.placeOrder(nextOrderId++, contract, modelOrder);
```


```
Order modelOrder = Order();
modelOrder.account = "DF12345";
modelOrder.modelCode = "Technology";
m_pClient->placeOrder(m_orderId++, contract, modelOrder);
```


```
Order modelOrder = Order();
modelOrder.Account = "DF12345";  // master FA account number
modelOrder.ModelCode = "Technology"; // model for tech stocks first created in TWS
client.placeOrder(nextOrderId++, contract, modelOrder);
```


```
Dim modelOrder As Order = Order()
modelOrder.Account = "DF12345" 'master FA account number
modelOrder.ModelCode = "Technology" 'model for tech stocks first created in TWS
client.placeOrder(increment(nextOrderId), contract, modelOrder)
```


```
order = Order()
order.action = "BUY"
order.orderType = "MKT"
order.totalQuantity = 50
order.faGroup = "MyTestProfile"
```


```
Order order = new Order();
order.action("BUY");
order.orderType("MKT");
order.totalQuantity(50);
order.faGroup("MyTestProfile");
```


```
Order order;
order.action = "BUY";
order.orderType = "MKT";
order.totalQuantity = 50;
order.faGroup = "MyTestProfile";
```


```
Order order = new Order();
order.Action = "BUY";
order.OrderType = "MKT";
order.TotalQuantity = 50;
order.FaGroup = "MyTestProfile";
```


```
Dim order As Order = New Order
order.Action = "BUY"
order.OrderType = "MKT"
order.TotalQuantity = 50
order.FaGroup = "MyTestProfile"
```


```
self.reqMarketDataType(3)
```


```
client.reqMarketDataType(2);
```


```
m_pClient->reqMarketDataType(3);
```


```
client.reqMarketDataType(3);
```


```
client.reqMarketDataType(4)
```


```
def marketDataType(self, reqId: TickerId, marketDataType: int):
	print("MarketDataType. ReqId:", reqId, "Type:", marketDataType)
```


```
@Override
public void marketDataType(int reqId, int marketDataType) {
	System.out.println("MarketDataType: " + EWrapperMsgGenerator.marketDataType(reqId, marketDataType));
}
```


```
void TestCppClient::marketDataType(TickerId reqId, int marketDataType) {
    printf( "MarketDataType. ReqId: %ld, Type: %d\n", reqId, marketDataType);
}
```


```
public virtual void marketDataType(int reqId, int marketDataType)
{
	Console.WriteLine("MarketDataType. "+reqId+", Type: "+marketDataType+"\n");
}
```


```
Public Sub marketDataType(reqId As Integer, marketDataType As Integer) Implements IBApi.EWrapper.marketDataType
	Console.WriteLine("MarketDataType - ReqId [" & reqId & "] MarketDataType [" & marketDataType & "]")
End Sub
```


```
SMART
```


```
self.reqHeadTimeStamp(1, ContractSamples.USStockAtSmart(), "TRADES", 1, 1)
```


```
client.reqHeadTimestamp(4003, contract, "TRADES", 1, 1);
```


```
m_pClient->reqHeadTimestamp(14001, contract, "MIDPOINT", 1, 1);
```


```
client.reqHeadTimestamp(14001, contract, "TRADES", 1, 1);
```


```
client.reqHeadTimestamp(14001, ContractSamples.USStock(), "TRADES", 1, 1)
```


```
def headTimestamp(self, reqId, headTimestamp):
        print(reqId, headTimestamp)
```


```
@Override
public void headTimestamp(int reqId, String headTimestamp) {
	System.out.println(EWrapperMsgGenerator.headTimestamp(reqId, headTimestamp));
}
```


```
void TestCppClient::headTimestamp(int reqId, const std::string& headTimestamp) {
    printf( "Head time stamp. ReqId: %d - Head time stamp: %s,\n", reqId, headTimestamp.c_str());
}
```


```
public void headTimestamp(int reqId, string headTimestamp)
{
	Console.WriteLine("Head time stamp. Request Id: {0}, Head time stamp: {1}", reqId, headTimestamp);
}
```


```
Public Sub headTimestamp(requestId As Integer, timeStamp As String) Implements IBApi.EWrapper.headTimestamp
	Console.WriteLine("Head time stamp. Request Id: {0}, Head time stamp: {1}", requestId, timeStamp)
End Sub
```


```
self.cancelHeadTimeStamp(reqId)
```


```
client.cancelHeadTimestamp(4003);
```


```
m_pClient->cancelHeadTimestamp(14001);
```


```
client.cancelHeadTimestamp(14001);
```


```
client.cancelHeadTimestamp(14001)
```


```
self.reqHistoricalData(4102, contract, queryTime, "1 M", "1 day", "MIDPOINT", 1, 1, False, [])
```


```
client.reqHistoricalData(4002, contract, formatted, "10 D", "1 min", "TRADES", 1, 1, false, null);
```


```
m_pClient->reqHistoricalData(4001, contract, queryTime, "1 M", "1 day", "MIDPOINT", 1, 1, false, TagValueListSPtr());
```


```
client.reqHistoricalData(4001, contract, queryTime, "1 M", "1 day", "MIDPOINT", 1, 1, false, null);
```


```
client.reqHistoricalData(4001, contract, queryTime, "1 M", "1 day", "MIDPOINT", 1, 1, False, Nothing)
```


```
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.56, Low: 188.54, Close: 188.55
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.56, Low: 188.54, Close: 188.55
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.56, Low: 188.54, Close: 188.55
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.56, Low: 188.54, Close: 188.55
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.56, Low: 188.54, Close: 188.55
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.56, Low: 188.54, Close: 188.56
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.56, Low: 188.54, Close: 188.56
Date: 20231204 13:30:30 US/Eastern, Open: 188.56, High: 188.57, Low: 188.54, Close: 188.55
Date: 20231204 13:30:45 US/Eastern, Open: 188.54, High: 188.54, Low: 188.54, Close: 188.54
```


```
def historicalData(self, reqId:int, bar: BarData):
	print("HistoricalData. ReqId:", reqId, "BarData.", bar)
```


```
@Override
public void historicalData(int reqId, Bar bar) {
	System.out.println("HistoricalData:  " + EWrapperMsgGenerator.historicalData(reqId, bar.time(), bar.open(), bar.high(), bar.low(), bar.close(), bar.volume(), bar.count(), bar.wap()));
}
```


```
void TestCppClient::historicalData(TickerId reqId, const Bar& bar) {
    printf( "HistoricalData. ReqId: %ld - Date: %s, Open: %s, High: %s, Low: %s, Close: %s, Volume: %s, Count: %s, WAP: %s\n", reqId, bar.time.c_str(), 
        Utils::doubleMaxString(bar.open).c_str(), Utils::doubleMaxString(bar.high).c_str(), Utils::doubleMaxString(bar.low).c_str(), Utils::doubleMaxString(bar.close).c_str(), 
        decimalStringToDisplay(bar.volume).c_str(), Utils::intMaxString(bar.count).c_str(), decimalStringToDisplay(bar.wap).c_str());
}
```


```
public virtual void historicalData(int reqId, Bar bar)
{
	Console.WriteLine("HistoricalData. " + reqId + " - Time: " + bar.Time + ", Open: " + Util.DoubleMaxString(bar.Open) + ", High: " + Util.DoubleMaxString(bar.High) + ", Low: " + Util.DoubleMaxString(bar.Low) + ", Close: " + Util.DoubleMaxString(bar.Close) + ", Volume: " + Util.DecimalMaxString(bar.Volume) + ", Count: " + Util.IntMaxString(bar.Count) + ", WAP: " + Util.DecimalMaxString(bar.WAP));
}
```


```
public virtual void historicalData(int reqId, Bar bar)
{
	Console.WriteLine("HistoricalData. " + reqId + " - Time: " + bar.Time + ", Open: " + Util.DoubleMaxString(bar.Open) + ", High: " + Util.DoubleMaxString(bar.High) + ", Low: " + Util.DoubleMaxString(bar.Low) + ", Close: " + Util.DoubleMaxString(bar.Close) + ", Volume: " + Util.DecimalMaxString(bar.Volume) + ", Count: " + Util.IntMaxString(bar.Count) + ", WAP: " + Util.DecimalMaxString(bar.WAP));
}
```


```
Date: 20241111-16:53:00, Open: 222.97, High: 222.97, Low: 222.96, Close: 222.97, Volume: 300, WAP: 222.965, BarCount: 2
Date: 20241111-16:53:05, Open: 222.97, High: 223.01, Low: 222.96, Close: 223.01, Volume: 5378, WAP: 222.981, BarCount: 38
Date: 20241111-16:53:10, Open: 223.02, High: 223.02, Low: 222.98, Close: 222.98, Volume: 3659, WAP: 222.997, BarCount: 24
Date: 20241111-16:53:15, Open: 222.98, High: 222.98, Low: 222.96, Close: 222.97, Volume: 2585, WAP: 222.963, BarCount: 24
```


```
def historicalSchedule(self, reqId: int, startDateTime: str, endDateTime: str, timeZone: str, sessions: ListOfHistoricalSessions):
	print("HistoricalSchedule. ReqId:", reqId, "Start:", startDateTime, "End:", endDateTime, "TimeZone:", timeZone)
	for session in sessions:
		print("\tSession. Start:", session.startDateTime, "End:", session.endDateTime, "Ref Date:", session.refDate)
```


```
@Override
public void historicalSchedule(int reqId, String startDateTime, String endDateTime, String timeZone, List sessions) {
	System.out.println(EWrapperMsgGenerator.historicalSchedule(reqId, startDateTime, endDateTime, timeZone, sessions));
}
```


```
void TestCppClient::historicalSchedule(int reqId, const std::string& startDateTime, const std::string& endDateTime, const std::string& timeZone, const std::vector& sessions) {
    printf("Historical Schedule. ReqId: %d, Start: %s, End: %s, TimeZone: %s\n", reqId, startDateTime.c_str(), endDateTime.c_str(), timeZone.c_str());
    for (unsigned int i = 0; i < sessions.size(); i++) {
        printf("\tSession. Start: %s, End: %s, RefDate: %s\n", sessions[i].startDateTime.c_str(), sessions[i].endDateTime.c_str(), sessions[i].refDate.c_str());
    }
}
```


```
public void historicalSchedule(int reqId, string startDateTime, string endDateTime, string timeZone, HistoricalSession[] sessions)
{
	Console.WriteLine($"Historical Schedule. ReqId: {reqId}, Start: {startDateTime}, End: {endDateTime}, Time Zone: {timeZone}");
	foreach (var session in sessions)
	{
		Console.WriteLine($"\tSession. Start: {session.StartDateTime}, End: {session.EndDateTime}, Ref Date: {session.RefDate}");
	}
}
```


```
public void historicalSchedule(int reqId, string startDateTime, string endDateTime, string timeZone, HistoricalSession[] sessions)
{
	Console.WriteLine($"Historical Schedule. ReqId: {reqId}, Start: {startDateTime}, End: {endDateTime}, Time Zone: {timeZone}");
	foreach (var session in sessions)
	{
		Console.WriteLine($"\tSession. Start: {session.StartDateTime}, End: {session.EndDateTime}, Ref Date: {session.RefDate}");
	}
}
```


```
def historicalDataUpdate(self, reqId: int, bar: BarData):
	print("HistoricalDataUpdate. ReqId:", reqId, "BarData.", bar)
```


```
@Override
public void historicalDataUpdate(int reqId, Bar bar) {
	System.out.println("HistoricalDataUpdate. " + EWrapperMsgGenerator.historicalData(reqId, bar.time(), bar.open(), bar.high(), bar.low(), bar.close(), bar.volume(), bar.count(), bar.wap()));
}
```


```
void TestCppClient::historicalDataUpdate(TickerId reqId, const Bar& bar) {
    printf( "HistoricalDataUpdate. ReqId: %ld - Date: %s, Open: %s, High: %s, Low: %s, Close: %s, Volume: %s, Count: %s, WAP: %s\n", reqId, bar.time.c_str(), 
        Utils::doubleMaxString(bar.open).c_str(), Utils::doubleMaxString(bar.high).c_str(), Utils::doubleMaxString(bar.low).c_str(), Utils::doubleMaxString(bar.close).c_str(), 
        decimalStringToDisplay(bar.volume).c_str(), Utils::intMaxString(bar.count).c_str(), decimalStringToDisplay(bar.wap).c_str());
}
```


```
public void historicalDataUpdate(int reqId, Bar bar)
{
	Console.WriteLine("HistoricalDataUpdate. " + reqId + " - Time: " + bar.Time + ", Open: " + Util.DoubleMaxString(bar.Open) + ", High: " + Util.DoubleMaxString(bar.High) + 
		", Low: " + Util.DoubleMaxString(bar.Low) + ", Close: " + Util.DoubleMaxString(bar.Close) + ", Volume: " + Util.DecimalMaxString(bar.Volume) + 
		", Count: " + Util.IntMaxString(bar.Count) + ", WAP: " + Util.DecimalMaxString(bar.WAP));
}
```


```
public void historicalDataUpdate(int reqId, Bar bar)
{
	Console.WriteLine("HistoricalDataUpdate. " + reqId + " - Time: " + bar.Time + ", Open: " + Util.DoubleMaxString(bar.Open) + ", High: " + Util.DoubleMaxString(bar.High) + ", Low: " + Util.DoubleMaxString(bar.Low) + ", Close: " + Util.DoubleMaxString(bar.Close) + ", Volume: " + Util.DecimalMaxString(bar.Volume) + ", Count: " + Util.IntMaxString(bar.Count) + ", WAP: " + Util.DecimalMaxString(bar.WAP));
}
```


```
def historicalDataEnd(self, reqId: int, start: str, end: str):
	print("HistoricalDataEnd. ReqId:", reqId, "from", start, "to", end)
```


```
@Override
public void historicalDataEnd(int reqId, String startDateStr, String endDateStr) {
	System.out.println("HistoricalDataEnd. " + EWrapperMsgGenerator.historicalDataEnd(reqId, startDateStr, endDateStr));
}
```


```
void TestCppClient::historicalDataEnd(int reqId, const std::string& startDateStr, const std::string& endDateStr) {
    std::cout << "HistoricalDataEnd. ReqId: " << reqId << " - Start Date: " << startDateStr << ", End Date: " << endDateStr << std::endl;   
}
```


```
public virtual void historicalDataEnd(int reqId, string startDate, string endDate)
{
	Console.WriteLine("HistoricalDataEnd - "+reqId+" from "+startDate+" to "+endDate);
}
```


```
public virtual void historicalDataEnd(int reqId, string startDate, string endDate)
        {
            Console.WriteLine("HistoricalDataEnd - "+reqId+" from "+startDate+" to "+endDate);
        }
```


```
self.reqHistogramData(4004, contract, false, "3 days")
```


```
client.reqHistogramData(4004, contract, false, "3 days");
```


```
m_pClient->reqHistogramData(15001, contract, false, "1 weeks");
```


```
client.reqHistogramData(15001, contract, false, "1 week");
```


```
client.reqHistogramData(15001, contract, False, "1 week")
```


```
def histogramData(self, reqId:int, items:HistogramDataList):
	print("HistogramData. reqid, items)
```


```
@Override
public void histogramData(int reqId, List items) {
	System.out.println(EWrapperMsgGenerator.histogramData(reqId, items));
}
```


```
void TestCppClient::histogramData(int reqId, const HistogramDataVector& data) {
    printf("Histogram. ReqId: %d, data length: %lu\n", reqId, data.size());
    for (const HistogramEntry& entry : data) {
        printf("\t price: %s, size: %s\n", Utils::doubleMaxString(entry.price).c_str(), decimalStringToDisplay(entry.size).c_str());
    }
}
```


```
public void histogramData(int reqId, HistogramEntry[] data)
{
	Console.WriteLine("Histogram data. Request Id: {0}, data size: {1}", reqId, data.Length);
	data.ToList().ForEach(i => Console.WriteLine("\tPrice: {0}, Size: {1}", Util.DoubleMaxString(i.Price), Util.DecimalMaxString(i.Size)));
}
```


```
Public Sub histogramData(reqId As Integer, data As HistogramEntry()) Implements EWrapper.histogramData
	Console.WriteLine("Histogram data. Request Id: {0}, data size: {1}", reqId, data.Length) 
	data.ToList().ForEach(Sub(i) Console.WriteLine(vbTab & "Price: {0}, Size: {1}", Util.DoubleMaxString(i.Price), Util.DecimalMaxString(i.Size)))
End Sub
```


```
self.reqHistogramData(4004)
```


```
client.cancelHistogramData(4004);
```


```
m_pClient->cancelHistogramData(15001);
```


```
client.cancelHistogramData(15001);
```


```
client.cancelHistogramData(15001)
```


```
self.reqHistoricalTicks(18001, contract, "20170712 21:39:33 US/Eastern", "", 10, "TRADES", 1, True, [])
```


```
client.reqHistoricalTicks(18001, contract, "20220808 10:00:00 US/Eastern", null, 10, "TRADES", 1, true, null);
```


```
m_pClient->reqHistoricalTicks(19001, contract, "20170621 09:38:33 US/Eastern", "", 10, "BID_ASK", 1, true, TagValueListSPtr());
```


```
client.reqHistoricalTicks(18001, contract, "20170712 21:39:33 US/Eastern", null, 10, "TRADES", 1, true, null);
```


```
client.reqHistoricalTicks(18001, contact, "20170712 21:39:33 US/Eastern", Nothing, 10, "TRADES", 1, True, Nothing)
```


```
def historicalTicks(self, reqId: int, ticks: ListOfHistoricalTickLast, done: bool):
	for tick in ticks:
		print("historicalTicks. ReqId:", reqId, tick)
```


```
@Override
public void historicalTicks(int reqId, List ticks, boolean done) {
	for (HistoricalTick tick : ticks) {
		System.out.println(EWrapperMsgGenerator.historicalTick(reqId, tick.time(), tick.price(), tick.size()));
	}
}
```


```
void TestCppClient::historicalTicks(int reqId, const std::vector& ticks, bool done) {
    for (const HistoricalTick& tick : ticks) {
    std::time_t t = tick.time;
        std::cout << "Historical tick. ReqId: " << reqId << ", time: " << ctime(&t) << ", price: "<< Utils::doubleMaxString(tick.price).c_str() << ", size: " << decimalStringToDisplay(tick.size).c_str() << std::endl;
    }
}
```


```
public void historicalTicks(int reqId, HistoricalTick[] ticks, bool done)
{
	foreach (var tick in ticks)
	{
		Console.WriteLine("Historical Tick. Request Id: {0}, Time: {1}, Price: {2}, Size: {3}", reqId, Util.UnixSecondsToString(tick.Time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(tick.Price), Util.DecimalMaxString(tick.Size));
	}
}
```


```
Public Sub historicalTick(reqId As Integer, ticks As HistoricalTick(), done As Boolean) Implements EWrapper.historicalTicks
	For Each tick In ticks
		Console.WriteLine("Historical Tick. Request Id: {0}, Time: {1}, Price: {2}, Size: {3}", reqId, Util.UnixSecondsToString(tick.Time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(tick.Price), Util.DecimalMaxString(tick.Size))
	Next
End Sub
```


```
def historicalTicksBidAsk(self, reqId: int, ticks: ListOfHistoricalTickLast, done: bool):
	for tick in ticks:
		print("historicalTicksBidAsk. ReqId:", reqId, tick)
```


```
@Override
public void historicalTicksBidAsk(int reqId, List ticks, boolean done) {
	for (HistoricalTickBidAsk tick : ticks) {
		System.out.println(EWrapperMsgGenerator.historicalTickBidAsk(reqId, tick.time(), tick.tickAttribBidAsk(), tick.priceBid(), tick.priceAsk(), tick.sizeBid(),
				tick.sizeAsk()));
	}
}
```


```
void TestCppClient::historicalTicksBidAsk(int reqId, const std::vector& ticks, bool done) {
    for (const HistoricalTickBidAsk& tick : ticks) {
		std::time_t t = tick.time;
        std::cout << "Historical tick bid/ask. ReqId: " << reqId << ", time: " << ctime(&t) << ", price bid: "<< Utils::doubleMaxString(tick.priceBid).c_str()  << ", price ask: "<< Utils::doubleMaxString(tick.priceAsk).c_str() << ", size bid: " << decimalStringToDisplay(tick.sizeBid).c_str() << ", size ask: " << decimalStringToDisplay(tick.sizeAsk).c_str() << ", bidPastLow: " << tick.tickAttribBidAsk.bidPastLow << ", askPastHigh: " << tick.tickAttribBidAsk.askPastHigh << std::endl;
    }
}
```


```
public void historicalTicksBidAsk(int reqId, HistoricalTickBidAsk[] ticks, bool done)
{
	foreach (var tick in ticks)
	{
		Console.WriteLine("Historical Tick Bid/Ask. Request Id: {0}, Time: {1}, Price Bid: {2}, Price Ask: {3}, Size Bid: {4}, Size Ask: {5}, Bid/Ask Tick Attribs: {6} ", reqId, Util.UnixSecondsToString(tick.Time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(tick.PriceBid), Util.DoubleMaxString(tick.PriceAsk), Util.DecimalMaxString(tick.SizeBid), Util.DecimalMaxString(tick.SizeAsk), tick.TickAttribBidAsk);
	}
}
```


```
Public Sub historicalTickBidAsk(reqId As Integer, ticks As HistoricalTickBidAsk(), done As Boolean) Implements EWrapper.historicalTicksBidAsk
	For Each tick In ticks
		Console.WriteLine("Historical Tick Bid/Ask. Request Id: {0}, Time: {1}, Price Bid: {2}, Price Ask: {3}, Size Bid: {4}, Size Ask: {5}, Bid/Ask Tick Attribs: {6}", reqId, Util.UnixSecondsToString(tick.Time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(tick.PriceBid), Util.DoubleMaxString(tick.PriceAsk), Util.DecimalMaxString(tick.SizeBid), Util.DecimalMaxString(tick.SizeAsk), tick.TickAttribBidAsk.ToString())
	Next
End Sub
```


```
def historicalTicksLast(self, reqId: int, ticks: ListOfHistoricalTickLast, done: bool):
	for tick in ticks:
		print("HistoricalTickLast. ReqId:", reqId, tick)
```


```
public void historicalTicksLast(int reqId, List ticks, boolean done) {
	for (HistoricalTickLast tick : ticks) {
		System.out.println(EWrapperMsgGenerator.historicalTickLast(reqId, tick.time(), tick.tickAttribLast(), tick.price(), tick.size(), tick.exchange(), 
			tick.specialConditions()));
	}
}
```


```
void TestCppClient::historicalTicksLast(int reqId, const std::vector& ticks, bool done) {
    for (HistoricalTickLast tick : ticks) {
		std::time_t t = tick.time;
        std::cout << "Historical tick last. ReqId: " << reqId << ", time: " << ctime(&t) << ", price: "<< Utils::doubleMaxString(tick.price).c_str() << ", size: " << decimalStringToDisplay(tick.size).c_str() << ", exchange: " << tick.exchange << ", special conditions: " << tick.specialConditions << ", unreported: " << tick.tickAttribLast.unreported << ", pastLimit: " << tick.tickAttribLast.pastLimit << std::endl;
    }
}
```


```
public void historicalTicksLast(int reqId, HistoricalTickLast[] ticks, bool done)
{
	foreach (var tick in ticks)
	{
		Console.WriteLine("Historical Tick Last. Request Id: {0}, Time: {1}, Price: {2}, Size: {3}, Exchange: {4}, Special Conditions: {5}, Last Tick Attribs: {6} ", reqId, Util.UnixSecondsToString(tick.Time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(tick.Price), Util.DecimalMaxString(tick.Size), tick.Exchange, tick.SpecialConditions, tick.TickAttribLast);
	}
}
```


```
Public Sub historicalTickLast(reqId As Integer, ticks As HistoricalTickLast(), done As Boolean) Implements EWrapper.historicalTicksLast
	For Each tick In ticks
		Console.WriteLine("Historical Tick Last. Request Id: {0}, Time: {1}, Price: {2}, Size: {3}, Exchange: {4}, Special Conditions: {5}, Last Tick Attribs: {6}", reqId, Util.UnixSecondsToString(tick.Time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(tick.Price), Util.DecimalMaxString(tick.Size), tick.Exchange, tick.SpecialConditions, tick.TickAttribLast.ToString())
	Next
End Sub
```


```
self.reqRealTimeBars(3001, contract, 5, "MIDPOINT", 0, [])
```


```
from ibapi.client import *
from ibapi.wrapper import *
from ibapi.contract import Contract
import time

class TradeApp(EWrapper, EClient): 
    def __init__(self): 
        EClient.__init__(self, self) 

    def realtimeBar(self, reqId: TickerId, time:int, open_: float, high: float, low: float, close: float, volume: Decimal, wap: Decimal, count: int):
        print("RealTimeBar. TickerId:", reqId, RealTimeBar(time, -1, open_, high, low, close, volume, wap, count))
    
app = TradeApp()      
app.connect("127.0.0.1", 7496, clientId=1)

contract = Contract() 
contract.symbol = "AAPL" 
contract.secType = "STK" 
contract.currency = "USD" 
contract.exchange = "SMART" 

app.reqRealTimeBars(3001, contract, 5, "TRADES", 0, [])

app.run()
```


```
client.reqRealTimeBars(3001, contract, 5, "MIDPOINT", true, null);
```


```
m_pClient->reqRealTimeBars(3001, contract, 5, "MIDPOINT", true, TagValueListSPtr());
```


```
client.reqRealTimeBars(3001, contract, 5, "MIDPOINT", true, null);
```


```
client.reqRealTimeBars(3001, contract, 5, "MIDPOINT", True, Nothing)
```


```
def realtimeBar(self, reqId: TickerId, time:int, open_: float, high: float, low: float, close: float, volume: Decimal, wap: Decimal, count: int):
	print("RealTimeBar. TickerId:", reqId, RealTimeBar(time, -1, open_, high, low, close, volume, wap, count))
```


```
@Override
public void realtimeBar(int reqId, long time, double open, double high, double low, double close, Decimal volume, Decimal wap, int count) {
	System.out.println("RealTimeBar: " + EWrapperMsgGenerator.realtimeBar(reqId, time, open, high, low, close, volume, wap, count));
}
```


```
void TestCppClient::realtimeBar(TickerId reqId, long time, double open, double high, double low, double close, Decimal volume, Decimal wap, int count) {
    printf( "RealTimeBars. %ld - Time: %s, Open: %s, High: %s, Low: %s, Close: %s, Volume: %s, Count: %s, WAP: %s\n", reqId, Utils::longMaxString(time).c_str(), Utils::doubleMaxString(open).c_str(), Utils::doubleMaxString(high).c_str(), Utils::doubleMaxString(low).c_str(), Utils::doubleMaxString(close).c_str(), decimalStringToDisplay(volume).c_str(), Utils::intMaxString(count).c_str(), decimalStringToDisplay(wap).c_str());
}
```


```
public virtual void realtimeBar(int reqId, long time, double open, double high, double low, double close, decimal volume, decimal WAP, int count)
{
	Console.WriteLine("RealTimeBars. " + reqId + " - Time: " + Util.LongMaxString(time) + ", Open: " + Util.DoubleMaxString(open) + ", High: " + Util.DoubleMaxString(high) +  ", Low: " + Util.DoubleMaxString(low) + ", Close: " + Util.DoubleMaxString(close) + ", Volume: " + Util.DecimalMaxString(volume) + ", Count: " + Util.IntMaxString(count) + ", WAP: " + Util.DecimalMaxString(WAP));
}
```


```
Public Sub realtimeBar(reqId As Integer, time As Long, open As Double, high As Double, low As Double, close As Double, volume As Decimal, WAP As Decimal, count As Integer) Implements IBApi.EWrapper.realtimeBar
	Console.WriteLine("RealTimeBars. " & reqId & " - Time: " & Util.LongMaxString(time) & ", Open: " & Util.DoubleMaxString(open) & ", High: " & Util.DoubleMaxString(high) & ", Low: " & Util.DoubleMaxString(low) & ", Close: " & Util.DoubleMaxString(close) & ", Volume: " & Util.DecimalMaxString(volume) & ", Count: " & Util.IntMaxString(count) & ", WAP: " & Util.DecimalMaxString(WAP))
End Sub
```


```
self.cancelRealTimeBars(3001)
```


```
client.cancelRealTimeBars(3001);
```


```
m_pClient->cancelRealTimeBars(3001);
```


```
client.cancelRealTimeBars(3001);
```


```
client.cancelRealTimeBars(3001)
```


```
self.reqSmartComponents(1018, "a6")
```


```
client.reqSmartComponents(1013, "a6");
```


```
m_pClient->reqSmartComponents(13002, m_bboExchange);
```


```
client.reqSmartComponents(13002, testImpl.BboExchange);
```


```
client.reqSmartComponents(13002, wrapperImpl.BboExchange)
```


```
def smartComponents(self, reqId:int, smartComponentMap:SmartComponentMap):
	print("SmartComponents:")
	for smartComponent in smartComponentMap:
		print("SmartComponent.", smartComponent)
```


```
@Override
public void smartComponents(int reqId, Map<Integer, Entry> theMap) {
	System.out.println(EWrapperMsgGenerator.smartComponents(reqId, theMap));
}
```


```
void TestCppClient::smartComponents(int reqId, const SmartComponentsMap& theMap) {
    printf("Smart components: (%lu):\n", theMap.size());
    for (SmartComponentsMap::const_iterator i = theMap.begin(); i != theMap.end(); i++) {
        printf(" bit number: %d exchange: %s exchange letter: %c\n", i->first, std::get(i->second).c_str(), std::get(i->second));
    }
}
```


```
public void smartComponents(int reqId, Dictionary<int, KeyValuePair> theMap)
{
	StringBuilder sb = new StringBuilder();
	sb.AppendFormat("==== Smart Components Begin (total={0}) reqId = {1} ====\n", theMap.Count, reqId);
	foreach (var item in theMap)
	{
		sb.AppendFormat("bit number: {0}, exchange: {1}, exchange letter: {2}\n", item.Key, item.Value.Key, item.Value.Value);
	}
	sb.AppendFormat("==== Smart Components Begin (total={0}) reqId = {1} ====\n", theMap.Count, reqId);
	Console.WriteLine(sb);
}
```


```
Public Sub smartComponents(reqId As Integer, theMap As Dictionary(Of Integer, KeyValuePair(Of String, Char))) Implements EWrapper.smartComponents
	Dim sb As New StringBuilder
	sb.AppendFormat("==== Smart Components Begin (total={0}) reqId = {1} ===={2}", theMap.Count, reqId, Environment.NewLine)
	For Each item In theMap
		sb.AppendFormat("bit number: {0}, exchange: {1}, exchange letter: {2}{3}", item.Key, item.Value.Key, item.Value.Value, Environment.NewLine)
	Next
	sb.AppendFormat("==== Smart Components Begin (total={0}) reqId = {1} ===={2}", theMap.Count, reqId, Environment.NewLine)
	Console.WriteLine(sb)
End Sub
```


```
self.reqMktDepthExchanges()
```


```
client.reqMktDepthExchanges();
```


```
m_pClient->reqMktDepthExchanges();
```


```
client.reqMktDepthExchanges();
```


```
client.reqMktDepthExchanges()
```


```
def mktDepthExchanges(self, depthMktDataDescriptions:ListOfDepthExchanges):
	print("MktDepthExchanges:")
	for desc in depthMktDataDescriptions:
		print("DepthMktDataDescription.", desc)
```


```
@Override
public void mktDepthExchanges(DepthMktDataDescription[] depthMktDataDescriptions) {
	System.out.println(EWrapperMsgGenerator.mktDepthExchanges(depthMktDataDescriptions));
}
```


```
void TestCppClient::mktDepthExchanges(const std::vector &depthMktDataDescriptions) {
	printf("Mkt Depth Exchanges (%lu):\n", depthMktDataDescriptions.size());
	for (unsigned int i = 0; i < depthMktDataDescriptions.size(); i++) {
		printf("Depth Mkt Data Description [%d] - exchange: %s secType: %s listingExch: %s serviceDataType: %s aggGroup: %s\n", i, depthMktDataDescriptions[i].exchange.c_str(), depthMktDataDescriptions[i].secType.c_str(), depthMktDataDescriptions[i].listingExch.c_str(), depthMktDataDescriptions[i].serviceDataType.c_str(), Utils::intMaxString(depthMktDataDescriptions[i].aggGroup).c_str());
	}
}
```


```
public void mktDepthExchanges(DepthMktDataDescription[] depthMktDataDescriptions)
{
	Console.WriteLine("Market Depth Exchanges:");
	foreach (var depthMktDataDescription in depthMktDataDescriptions)
	{
		Console.WriteLine("Depth Market Data Description: Exchange: {0}, Security Type: {1}, Listing Exch: {2}, Service Data Type: {3}, Agg Group: {4}", depthMktDataDescription.Exchange, depthMktDataDescription.SecType, depthMktDataDescription.ListingExch, depthMktDataDescription.ServiceDataType, Util.IntMaxString(depthMktDataDescription.AggGroup));
	}
}
```


```
Public Sub mktDepthExchanges(depthMktDataDescriptions As DepthMktDataDescription()) Implements EWrapper.mktDepthExchanges
	Console.WriteLine("Market Depth Exchanges:")
	For Each depthMktDataDescription In depthMktDataDescriptions
		Console.WriteLine("Depth Market Data Descriprion. Exchange: " & depthMktDataDescription.Exchange & " Security Type: " & depthMktDataDescription.SecType & " Listing Exch: " & depthMktDataDescription.ListingExch & " Service Data Type: " & depthMktDataDescription.ServiceDataType & "  Agg Group: " & Util.IntMaxString(depthMktDataDescription.AggGroup))
	Next
End Sub
```


```
self.reqMktDepth(2001, contract, 5, False, [])
```


```
client.reqMktDepth(2001, contract, 5, false, null);
```


```
m_pClient->reqMktDepth(2001, contract, 5, false, TagValueListSPtr());
```


```
client.reqMarketDepth(2001, contract, 5, false, null);
```


```
client.reqMarketDepth(2001, contract, 5, False, Nothing)
```


```
def updateMktDepth(self, reqId: TickerId, position: int, operation: int, side: int, price: float, size: Decimal):
		print("UpdateMarketDepth. ReqId:", reqId, "Position:", position, "Operation:", operation, "Side:", side, "Price:", floatMaxString(price), "Size:", decimalMaxString(size))
```


```
@Override
public void updateMktDepth(int tickerId, int position, int operation, int side, double price, Decimal size) {
	System.out.println(EWrapperMsgGenerator.updateMktDepth(tickerId, position, operation, side, price, size));
}
```


```
void TestCppClient::updateMktDepth(TickerId id, int position, int operation, int side, double price, Decimal size) {
    printf( "UpdateMarketDepth. %ld - Position: %s, Operation: %d, Side: %d, Price: %s, Size: %s\n", id, Utils::intMaxString(position).c_str(), operation, side, Utils::doubleMaxString(price).c_str(), decimalStringToDisplay(size).c_str());
}
```


```
public virtual void updateMktDepth(int tickerId, int position, int operation, int side, double price, decimal size)
{
	Console.WriteLine("UpdateMarketDepth. " + tickerId + " - Position: " + position + ", Operation: " + operation + ", Side: " + side + ", Price: " + Util.DoubleMaxString(price) + ", Size: " + Util.DecimalMaxString(size));
}
```


```
Public Sub updateMktDepth(tickerId As Integer, position As Integer, operation As Integer, side As Integer, price As Double, size As Decimal) Implements IBApi.EWrapper.updateMktDepth
	Console.WriteLine("UpdateMarketDepth. " & CStr(tickerId) & " - Position: " & CStr(position) & ", Operation: " & CStr(operation) & ", Side: " & CStr(side) & ", Price: " & Util.DoubleMaxString(price) & ", Size: " & Util.DecimalMaxString(size))
End Sub
```


```
def updateMktDepthL2(self, reqId: TickerId, position: int, marketMaker: str, operation: int, side: int, price: float, size: Decimal, isSmartDepth: bool):
	print("UpdateMarketDepthL2. ReqId:", reqId, "Position:", position, "MarketMaker:", marketMaker, "Operation:", operation, "Side:", side, "Price:", floatMaxString(price), "Size:", decimalMaxString(size), "isSmartDepth:", isSmartDepth)
```


```
@Override
public void updateMktDepthL2(int tickerId, int position, String marketMaker, int operation, int side, double price, Decimal size, boolean isSmartDepth) {
	System.out.println(EWrapperMsgGenerator.updateMktDepthL2( tickerId, position, marketMaker, operation, side, price, size, isSmartDepth));
}
```


```
void TestCppClient::updateMktDepthL2(TickerId id, int position, const std::string& marketMaker, int operation, int side, double price, Decimal size, bool isSmartDepth) {
    printf( "UpdateMarketDepthL2. %ld - Position: %s, Operation: %d, Side: %d, Price: %s, Size: %s, isSmartDepth: %d\n", id, Utils::intMaxString(position).c_str(), operation, side, Utils::doubleMaxString(price).c_str(), decimalStringToDisplay(size).c_str(), isSmartDepth);
}
```


```
public virtual void updateMktDepthL2(int tickerId, int position, string marketMaker, int operation, int side, double price, decimal size, bool isSmartDepth)
{
	Console.WriteLine("UpdateMarketDepthL2. " + tickerId + " - Position: " + position + ", Operation: " + operation + ", Side: " + side + ", Price: " + Util.DoubleMaxString(price) + ", Size: " + Util.DecimalMaxString(size) + ", isSmartDepth: " + isSmartDepth);
}
```


```
Public Sub updateMktDepthL2(tickerId As Integer, position As Integer, marketMaker As String, operation As Integer, side As Integer, price As Double, size As Decimal, isSmartDepth As Boolean) Implements IBApi.EWrapper.updateMktDepthL2
	Console.WriteLine("UpdateMarketDepthL2. " & CStr(tickerId) & " MarketMaker: " & marketMaker & ", Position: " & CStr(position) & ", Operation: " & CStr(operation) & ", Side: " & CStr(side) & ", Price: " & Util.DoubleMaxString(price) & ", Size: " & Util.DecimalMaxString(size) & ", isSmartDepth: " & CStr(isSmartDepth))
End Sub
```


```
self.cancelMktDepth(2001, False)
```


```
client.cancelMktDepth(2001, false);
```


```
m_pClient->cancelMktDepth(2001, false);
```


```
client.cancelMktDepth(2001, false);
```


```
client.cancelMktDepth(2001, False)
```


```
self.reqMktData(reqId, OptionContract, "", False, False, [])
```


```
client.reqMktData(reqId, OptionContract, "", false, false, null);
```


```
m_pClient->reqMktData(reqId, OptionContract, "", false, false, TagValueListSPtr());
```


```
client.reqMktData(reqId, OptionContract, "", false, false, null);
```


```
client.reqMktData(reqId, OptionContract, "", False, False, Nothing)
```


```
self.calculateOptionPrice(5002, OptionContract, 0.6, 55, [])
```


```
client.calculateOptionPrice(5002, OptionContract, 0.5, 55, null);
```


```
m_pClient->calculateOptionPrice(5002, OptionContract, 0.6, 55, TagValueListSPtr());
```


```
client.calculateOptionPrice(5002, OptionContract, 0.6, 55, null);
```


```
client.calculateOptionPrice(5002, OptionContract, 0.6, 55, Nothing)
```


```
self.calculateImpliedVolatility(5001, OptionContract, 0.5, 55, [])
```


```
client.calculateImpliedVolatility(5001, OptionContract, 0.6, 55, null);
```


```
m_pClient->calculateImpliedVolatility(5001, OptionContract, 0.5, 55, TagValueListSPtr());
```


```
client.calculateImpliedVolatility(5001, OptionContract, 0.5, 55, null);
```


```
client.calculateImpliedVolatility(5001, OptionContract, 0.5, 55, Nothing)
```


```
def tickOptionComputation(self, reqId: TickerId, tickType: TickType, tickAttrib: int, impliedVol: float, delta: float, optPrice: float, pvDividend: float, gamma: float, vega: float, theta: float, undPrice: float):
	print("TickOptionComputation. TickerId:", reqId, "TickType:", tickType, "TickAttrib:", intMaxString(tickAttrib), "ImpliedVolatility:", floatMaxString(impliedVol), "Delta:", floatMaxString(delta), "OptionPrice:", floatMaxString(optPrice), "pvDividend:", floatMaxString(pvDividend), "Gamma: ", floatMaxString(gamma), "Vega:", floatMaxString(vega), "Theta:", floatMaxString(theta), "UnderlyingPrice:", floatMaxString(undPrice))
```


```
@Override
public void tickOptionComputation(int tickerId, int field, int tickAttrib, double impliedVol, double delta, double optPrice,
		double pvDividend, double gamma, double vega, double theta, double undPrice) {
	System.out.println("TickOptionComputation: " + EWrapperMsgGenerator.tickOptionComputation( tickerId, field, tickAttrib, impliedVol, delta, optPrice, pvDividend, gamma, vega, theta, undPrice));
}
```


```
void TestCppClient::tickOptionComputation( TickerId tickerId, TickType tickType, int tickAttrib, double impliedVol, double delta, double optPrice, double pvDividend, double gamma, double vega, double theta, double undPrice) {
    printf( "TickOptionComputation. Ticker Id: %ld, Type: %d, TickAttrib: %s, ImpliedVolatility: %s, Delta: %s, OptionPrice: %s, pvDividend: %s, Gamma: %s, Vega: %s, Theta: %s, Underlying Price: %s\n", tickerId, (int)tickType, Utils::intMaxString(tickAttrib).c_str(), Utils::doubleMaxString(impliedVol).c_str(), Utils::doubleMaxString(delta).c_str(), Utils::doubleMaxString(optPrice).c_str(), Utils::doubleMaxString(pvDividend).c_str(), Utils::doubleMaxString(gamma).c_str(), Utils::doubleMaxString(vega).c_str(), Utils::doubleMaxString(theta).c_str(), Utils::doubleMaxString(undPrice).c_str());
}
```


```
public virtual void tickOptionComputation(int tickerId, int field, int tickAttrib, double impliedVolatility, double delta, double optPrice, double pvDividend, double gamma, double vega, double theta, double undPrice)
{
	Console.WriteLine("TickOptionComputation. TickerId: " + tickerId + ", field: " + field + ", TickAttrib: " + Util.IntMaxString(tickAttrib) + ", ImpliedVolatility: " + Util.DoubleMaxString(impliedVolatility) + ", Delta: " + Util.DoubleMaxString(delta) + ", OptionPrice: " + Util.DoubleMaxString(optPrice) +", pvDividend: " + Util.DoubleMaxString(pvDividend) + ", Gamma: " + Util.DoubleMaxString(gamma) + ", Vega: " + Util.DoubleMaxString(vega) + ", Theta: " + Util.DoubleMaxString(theta) + ", UnderlyingPrice: " + Util.DoubleMaxString(undPrice));
}
```


```
Public Sub tickOptionComputation(tickerId As Integer, field As Integer, tickAttrib As Integer, impliedVolatility As Double, delta As Double, optPrice As Double, pvDividend As Double, gamma As Double, vega As Double, theta As Double, undPrice As Double) Implements IBApi.EWrapper.tickOptionComputation
	Console.WriteLine("TickOptionComputation. TickerId: " & tickerId & ", field: " & field & ", TickAttrib: " & Util.IntMaxString(tickAttrib) & ", ImpliedVolatility: " & Util.DoubleMaxString(impliedVolatility) & ", Delta: " & Util.DoubleMaxString(delta) & ", OptionPrice: " & Util.DoubleMaxString(optPrice) & ", pvDividend: " & Util.DoubleMaxString(pvDividend) & ", Gamma: " & Util.DoubleMaxString(gamma) & ", Vega: " & Util.DoubleMaxString(vega) & ", Theta: " & Util.DoubleMaxString(theta) & ", UnderlyingPrice: " & Util.DoubleMaxString(undPrice))
End Sub
```


```
self.reqMktData(reqId, contract, "", False, False, [])
```


```
client.reqMktData(reqId, contract, "", false, false, null);
```


```
m_pClient->reqMktData(reqId, contract, "", false, false, TagValueListSPtr());
```


```
client.reqMktData(reqId, contract, "", false, false, null);
```


```
client.reqMktData(reqId, contract, "", False, False, Nothing)
```


```
def tickSnapshotEnd(self, reqId: int):
  print("TickSnapshotEnd. TickerId:", reqId)
```


```
@Override
public void tickSnapshotEnd(int reqId) {
  System.out.println("TickSnapshotEnd: " + EWrapperMsgGenerator.tickSnapshotEnd(reqId));
}
```


```
void TestCppClient::tickSnapshotEnd(int reqId) {
    printf( "TickSnapshotEnd: %d\n", reqId);
}
```


```
public virtual void tickSnapshotEnd(int tickerId)
{
  Console.WriteLine("TickSnapshotEnd: "+tickerId);
}
```


```
Public Sub tickSnapshotEnd(tickerId As Integer) Implements IBApi.EWrapper.tickSnapshotEnd
  Console.WriteLine("TickSnapshotEnd: " & CStr(tickerId))
End Sub
```


```
def tickGeneric(self, reqId: TickerId, tickType: TickType, value: float):
	print("TickGeneric. TickerId:", reqId, "TickType:", tickType, "Value:", floatMaxString(value))
```


```
@Override
public void tickGeneric(int tickerId, int tickType, double value) {
	System.out.println("Tick Generic: " + EWrapperMsgGenerator.tickGeneric(tickerId, tickType, value));
}
```


```
void TestCppClient::tickGeneric(TickerId tickerId, TickType tickType, double value) {
    printf( "Tick Generic. Ticker Id: %ld, Type: %d, Value: %s\n", tickerId, (int)tickType, Utils::doubleMaxString(value).c_str());
}
```


```
public virtual void tickGeneric(int tickerId, int field, double value)
{
	Console.WriteLine("Tick Generic. Ticker Id:" + tickerId + ", Field: " + field + ", Value: " + Util.DoubleMaxString(value));
}
```


```
Public Sub tickGeneric(tickerId As Integer, field As Integer, value As Double) Implements IBApi.EWrapper.tickGeneric
	Console.WriteLine("Tick Generic. Ticker Id:" & tickerId & ", Field: " & field & ", Value: " & Util.DoubleMaxString(value))
End Sub
```


```
def tickPrice(self, reqId: TickerId, tickType: TickType, price: float, attrib: TickAttrib):
	print(reqId, tickType, price, attrib)
```


```
@Override
public void tickPrice(int tickerId, int field, double price, TickAttrib attribs) {
	System.out.println("Tick Price: " + EWrapperMsgGenerator.tickPrice( tickerId, field, price, attribs));
}
```


```
void TestCppClient::tickPrice( TickerId tickerId, TickType field, double price, const TickAttrib& attribs) {
    printf( "Tick Price. Ticker Id: %ld, Field: %d, Price: %s, CanAutoExecute: %d, PastLimit: %d, PreOpen: %d\n", tickerId, (int)field, Utils::doubleMaxString(price).c_str(), attribs.canAutoExecute, attribs.pastLimit, attribs.preOpen);
}
```


```
public virtual void tickPrice(int tickerId, int field, double price, TickAttrib attribs) 
{
	Console.WriteLine("Tick Price. Ticker Id:" + tickerId + ", Field: " + field + ", Price: " + Util.DoubleMaxString(price) + ", CanAutoExecute: " + attribs.CanAutoExecute + ", PastLimit: " + attribs.PastLimit + ", PreOpen: " + attribs.PreOpen);
}
```


```
Public Sub tickPrice(tickerId As Integer, field As Integer, price As Double, attribs As TickAttrib) Implements IBApi.EWrapper.tickPrice
	Console.WriteLine("TickPrice - TickerId [" & CStr(tickerId) & "] Field [" & TickType.getField(field) & "] Price [" & Util.DoubleMaxString(price) & "] PreOpen [" & attribs.PreOpen & "]")
End Sub
```


```
def tickSize(self, reqId: TickerId, tickType: TickType, size: Decimal):
	print("TickSize. TickerId:", reqId, "TickType:", tickType, "Size: ", decimalMaxString(size))
```


```
@Override
public void tickSize(int tickerId, int field, Decimal size) {
    System.out.println("Tick Size: " + EWrapperMsgGenerator.tickSize( tickerId, field, size));
}
```


```
void TestCppClient::tickSize( TickerId tickerId, TickType field, Decimal size) {
    printf( "Tick Size. Ticker Id: %ld, Field: %d, Size: %s\n", tickerId, (int)field, decimalStringToDisplay(size).c_str());
}
```


```
public virtual void tickSize(int tickerId, int field, decimal size)
{
	Console.WriteLine("Tick Size. Ticker Id:" + tickerId + ", Field: " + field + ", Size: " + Util.DecimalMaxString(size));
}
```


```
Public Sub tickSize(tickerId As Integer, field As Integer, size As Decimal) Implements IBApi.EWrapper.tickSize
	Console.WriteLine("Tick Size. Ticker Id:" & CStr(tickerId) & ", Field: " & TickType.getField(field) & ", Size: " & Util.DecimalMaxString(size))
End Sub
```


```
def tickString(self, reqId: TickerId, tickType: TickType, value: str):
	print("TickString. TickerId:", reqId, "Type:", tickType, "Value:", value)
```


```
@Override
    public void tickString(int tickerId, int tickType, String value) {
        System.out.println("Tick String: " + EWrapperMsgGenerator.tickString(tickerId, tickType, value));
    }
```


```
void TestCppClient::tickString(TickerId tickerId, TickType tickType, const std::string& value) {
    printf( "Tick String. Ticker Id: %ld, Type: %d, Value: %s\n", tickerId, (int)tickType, value.c_str());
}
```


```
public virtual void tickString(int tickerId, int tickType, string value)
{
	Console.WriteLine("Tick string. Ticker Id:" + tickerId + ", Type: " + tickType + ", Value: " + value);
}
```


```
Public Sub tickString(tickerId As Integer, field As Integer, value As String) Implements IBApi.EWrapper.tickString
	Console.WriteLine("Tick string. Ticker Id:" & CStr(tickerId) & ", Type: " & TickType.getField(field) & ", Value: " & value)
End Sub
```


```
def tickReqParams(self, tickerId:int, minTick:float, bboExchange:str, snapshotPermissions:int):
	print("TickReqParams. TickerId:", tickerId, "MinTick:", floatMaxString(minTick), "BboExchange:", bboExchange, "SnapshotPermissions:", intMaxString(snapshotPermissions))
```


```
@Override
public void tickReqParams(int tickerId, double minTick, String bboExchange, int snapshotPermissions) {
	System.out.println("Tick req params: " + EWrapperMsgGenerator.tickReqParams(tickerId, minTick, bboExchange, snapshotPermissions));
}
```


```
void TestCppClient::tickReqParams(int tickerId, double minTick, const std::string& bboExchange, int snapshotPermissions) {
    printf("tickerId: %d, minTick: %s, bboExchange: %s, snapshotPermissions: %u\n", tickerId, Utils::doubleMaxString(minTick).c_str(), bboExchange.c_str(), snapshotPermissions);
    m_bboExchange = bboExchange;
}
```


```
public void tickReqParams(int tickerId, double minTick, string bboExchange, int snapshotPermissions)
{
	Console.WriteLine("id={0} minTick = {1} bboExchange = {2} snapshotPermissions = {3}", tickerId, Util.DoubleMaxString(minTick), bboExchange, Util.IntMaxString(snapshotPermissions)); BboExchange = bboExchange;
}
```


```
Public Sub tickReqParams(tickerId As Integer, minTick As Double, bboExchange As String, snapshotPermissions As Integer) Implements EWrapper.tickReqParams
	Console.WriteLine("id={0} minTick = {1} bboExchange = {2} snapshotPermissions = {3}", tickerId, Util.DoubleMaxString(minTick), bboExchange, Util.IntMaxString(snapshotPermissions))
	Me.BboExchange = bboExchange
End Sub
```


```
def rerouteMktDataReq(self, reqId: int, conId: int, exchange: str):
	print("Re-route market data request. ReqId:", reqId, "ConId:", conId, "Exchange:", exchange)
```


```
@Override
public void rerouteMktDataReq(int reqId, int conId, String exchange) {
	System.out.println(EWrapperMsgGenerator.rerouteMktDataReq(reqId, conId, exchange));
}
```


```
void TestCppClient::rerouteMktDataReq(int reqId, int conid, const std::string& exchange) {
    printf( "Re-route market data request. ReqId: %d, ConId: %d, Exchange: %s\n", reqId, conid, exchange.c_str());
}
```


```
public void rerouteMktDataReq(int reqId, int conId, string exchange)
{
	Console.WriteLine("Re-route market data request. Req Id: {0}, ConId: {1}, Exchange: {2}", reqId, conId, exchange);
}
```


```
Public Sub rerouteMktDataReq(reqId As Integer, conId As Integer, exchange As String) Implements IBApi.EWrapper.rerouteMktDataReq
	Console.WriteLine("Re-route market data request. Req Id: {0}, Con Id: {1}, Exchange: {2}", reqId, conId, exchange)
End Sub
```


```
def rerouteMktDepthReq(self, reqId: int, conId: int, exchange: str):
	print("Re-route market depth request. ReqId:", reqId, "ConId:", conId, "Exchange:", exchange)
```


```
@Override
public void rerouteMktDepthReq(int reqId, int conId, String exchange) {
	System.out.println(EWrapperMsgGenerator.rerouteMktDepthReq(reqId, conId, exchange));
}
```


```
void TestCppClient::rerouteMktDepthReq(int reqId, int conid, const std::string& exchange) {
    printf( "Re-route market depth request. ReqId: %d, ConId: %d, Exchange: %s\n", reqId, conid, exchange.c_str());
}
```


```
public void rerouteMktDepthReq(int reqId, int conId, string exchange)
{
	Console.WriteLine("Re-route market depth request. Req Id: {0}, ConId: {1}, Exchange: {2}", reqId, conId, exchange);
}
```


```
Public Sub rerouteMktDepthReq(reqId As Integer, conId As Integer, exchange As String) Implements IBApi.EWrapper.rerouteMktDepthReq
            Console.WriteLine("Re-route market depth request. Req Id: {0}, Con Id: {1}, Exchange: {2}", reqId, conId, exchange)
        End Sub
```


```
self.cancelMktData(2001)
```


```
client.cancelMktData(2001);
```


```
m_pClient->cancelMktData(2001);
```


```
client.cancelMktData(2001);
```


```
client.cancelMktData(2001)
```


```
self.reqTickByTickData(19001, contract, "Last", 0, True)
```


```
client.reqTickByTickData(19001, contract, "Last", 0, false);
```


```
m_pClient->reqTickByTickData(20005, contract, "Last", 10, false);
```


```
client.reqTickByTickData(19001, contract, "Last", 0, false);
```


```
client.reqTickByTickData(19001, contract, "Last", 0, False)
```


```
def tickByTickAllLast(self, reqId: int, tickType: int, time: int, price: float, size: Decimal, tickAtrribLast: TickAttribLast, exchange: str,specialConditions: str):
	print(" ReqId:", reqId, "Time:", time, "Price:", floatMaxString(price), "Size:", size, "Exch:" , exchange, "Spec Cond:", specialConditions, "PastLimit:", tickAtrribLast.pastLimit, "Unreported:", tickAtrribLast.unreported)
```


```
@Override
public void tickByTickAllLast(int reqId, int tickType, long time, double price, Decimal size, TickAttribLast tickAttribLast, String exchange, String specialConditions) {
	System.out.println(EWrapperMsgGenerator.tickByTickAllLast(reqId, tickType, time, price, size, tickAttribLast, exchange, specialConditions));
}
```


```
void TestCppClient::tickByTickAllLast(int reqId, int tickType, time_t time, double price, Decimal size, const TickAttribLast& tickAttribLast, const std::string& exchange, const std::string& specialConditions) {
    printf("Tick-By-Tick. ReqId: %d, TickType: %s, Time: %s, Price: %s, Size: %s, PastLimit: %d, Unreported: %d, Exchange: %s, SpecialConditions:%s\n", reqId, (tickType == 1 ? "Last" : "AllLast"), ctime(&time), Utils::doubleMaxString(price).c_str(), decimalStringToDisplay(size).c_str(), tickAttribLast.pastLimit, tickAttribLast.unreported, exchange.c_str(), specialConditions.c_str());
}
```


```
public void tickByTickAllLast(int reqId, int tickType, long time, double price, decimal size, TickAttribLast tickAttribLast, string exchange, string specialConditions)
        {
            Console.WriteLine("Tick-By-Tick. Request Id: {0}, TickType: {1}, Time: {2}, Price: {3}, Size: {4}, Exchange: {5}, Special Conditions: {6}, PastLimit: {7}, Unreported: {8}",
                reqId, tickType == 1 ? "Last" : "AllLast", Util.UnixSecondsToString(time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(price), Util.DecimalMaxString(size), exchange, specialConditions, tickAttribLast.PastLimit, tickAttribLast.Unreported);
        }
```


```
Public Sub tickByTickAllLast(reqId As Integer, tickType As Integer, time As Long, price As Double, size As Decimal, tickAttribLast As TickAttribLast, exchange As String, specialConditions As String) Implements EWrapper.tickByTickAllLast
	Dim tickTypeStr As String
	If tickType = 1 Then
		tickTypeStr = "Last"
	Else
		tickTypeStr = "AllLast"
	End If
	Console.WriteLine("Tick-By-Tick. Request Id: {0}, TickType: {1}, Time: {2}, Price: {3}, Size: {4}, Exchange: {5}, Special Conditions: {6}, PastLimit: {7}, Unreported: {8}",
		reqId, tickTypeStr, Util.UnixSecondsToString(time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(price), Util.DecimalMaxString(size), exchange, specialConditions,
		tickAttribLast.PastLimit, tickAttribLast.Unreported)
End Sub
```


```
def tickByTickBidAsk(self, reqId: int, time: int, bidPrice: float, askPrice: float, bidSize: Decimal, askSize: Decimal, tickAttribBidAsk: TickAttribBidAsk):
	print("BidAsk. ReqId:", reqId, "Time:", time, "BidPrice:", floatMaxString(bidPrice), "AskPrice:", floatMaxString(askPrice), "BidSize:", decimalMaxString(bidSize), "AskSize:", decimalMaxString(askSize), "BidPastLow:", tickAttribBidAsk.bidPastLow, "AskPastHigh:", tickAttribBidAsk.askPastHigh)
```


```
@Override
public void tickByTickBidAsk(int reqId, long time, double bidPrice, double askPrice, Decimal bidSize, Decimal askSize, TickAttribBidAsk tickAttribBidAsk) {
	System.out.println(EWrapperMsgGenerator.tickByTickBidAsk(reqId, time, bidPrice, askPrice, bidSize, askSize, tickAttribBidAsk));
}
```


```
void TestCppClient::tickByTickBidAsk(int reqId, time_t time, double bidPrice, double askPrice, Decimal bidSize, Decimal askSize, const TickAttribBidAsk& tickAttribBidAsk) {
    printf("Tick-By-Tick. ReqId: %d, TickType: BidAsk, Time: %s, BidPrice: %s, AskPrice: %s, BidSize: %s, AskSize: %s, BidPastLow: %d, AskPastHigh: %d\n", reqId, ctime(&time), Utils::doubleMaxString(bidPrice).c_str(), Utils::doubleMaxString(askPrice).c_str(), decimalStringToDisplay(bidSize).c_str(), decimalStringToDisplay(askSize).c_str(), tickAttribBidAsk.bidPastLow, tickAttribBidAsk.askPastHigh);
}
```


```
public void tickByTickBidAsk(int reqId, long time, double bidPrice, double askPrice, decimal bidSize, decimal askSize, TickAttribBidAsk tickAttribBidAsk)
{
	Console.WriteLine("Tick-By-Tick. Request Id: {0}, TickType: BidAsk, Time: {1}, BidPrice: {2}, AskPrice: {3}, BidSize: {4}, AskSize: {5}, BidPastLow: {6}, AskPastHigh: {7}", reqId, Util.UnixSecondsToString(time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(bidPrice), Util.DoubleMaxString(askPrice), Util.DecimalMaxString(bidSize), Util.DecimalMaxString(askSize), tickAttribBidAsk.BidPastLow, tickAttribBidAsk.AskPastHigh);
}
```


```
Public Sub tickByTickBidAsk(reqId As Integer, time As Long, bidPrice As Double, askPrice As Double, bidSize As Decimal, askSize As Decimal, tickAttribBidAsk As TickAttribBidAsk) Implements EWrapper.tickByTickBidAsk
            Console.WriteLine("Tick-By-Tick. Request Id: {0}, TickType: BidAsk, Time: {1}, BidPrice: {2}, AskPrice: {3}, BidSize: {4}, AskSize: {5}, BidPastLow: {6}, AskPastHigh: {7}",
                reqId, Util.UnixSecondsToString(time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(bidPrice), Util.DoubleMaxString(askPrice), Util.DecimalMaxString(bidSize), Util.DecimalMaxString(askSize),
                tickAttribBidAsk.BidPastLow, tickAttribBidAsk.AskPastHigh)
        End Sub
```


```
def tickByTickMidPoint(self, reqId: int, time: int, midPoint: float):
	print("Midpoint. ReqId:", reqId, "Time:", time, "MidPoint:", floatMaxString(midPoint))
```


```
@Override
public void tickByTickMidPoint(int reqId, long time, double midPoint) {
	System.out.println(EWrapperMsgGenerator.tickByTickMidPoint(reqId, time, midPoint));
}
```


```
void TestCppClient::tickByTickMidPoint(int reqId, time_t time, double midPoint) {
    printf("Tick-By-Tick. ReqId: %d, TickType: MidPoint, Time: %s, MidPoint: %s\n", reqId, ctime(&time), Utils::doubleMaxString(midPoint).c_str());
}
```


```
public void tickByTickMidPoint(int reqId, long time, double midPoint)
{
	Console.WriteLine("Tick-By-Tick. Request Id: {0}, TickType: MidPoint, Time: {1}, MidPoint: {2}", reqId, Util.UnixSecondsToString(time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(midPoint));
}
```


```
Public Sub tickByTickMidPoint(reqId As Integer, time As Long, midPoint As Double) Implements EWrapper.tickByTickMidPoint
	Console.WriteLine("Tick-By-Tick. Request Id: {0}, TickType: MidPoint, Time: {1}, MidPoint: {2}", reqId, Util.UnixSecondsToString(time, "yyyyMMdd-HH:mm:ss"), Util.DoubleMaxString(midPoint))
End Sub
```


```
self.cancelTickByTickData(19001)
```


```
client.cancelTickByTickData(19001);
```


```
m_pClient->cancelTickByTickData(20001);
```


```
client.cancelTickByTickData(19001);
```


```
client.cancelTickByTickData(19001)
```


```
self.reqScannerParameters()
```


```
client.reqScannerParameters();
```


```
m_pClient->reqScannerParameters();
```


```
client.reqScannerParameters();
```


```
client.reqScannerParameters()
```


```
def scannerParameters(self, xml: str):
	open('log/scanner.xml', 'w').write(xml)
	print("ScannerParameters received.")
```


```
@Override
public void scannerParameters(String xml) {
	System.out.println("ScannerParameters. " + xml + "\n");
}
```


```
void TestCppClient::scannerParameters(const std::string& xml) {
    printf( "ScannerParameters. %s\n", xml.c_str());
}
```


```
public virtual void scannerParameters(string xml)
{
	Console.WriteLine("ScannerParameters. "+xml+"\n");
}
```


```
Public Sub scannerParameters(xml As String) Implements IBApi.EWrapper.scannerParameters
	Console.WriteLine("ScannerParameters. " & xml & "\n")
End Sub
```


```
<ScanParameterResponse> <InstrumentList> <Instrument> <type>
```


```
<ScanParameterResponse> <LocationTree> <Location> <LocationTree> <Location> <locationCode>
```


```
<ScanParameterResponse> <ScanTypeList> <ScanType> <scanCode>
```


```
<ScanParameterResponse> <FilterList> <RangeFilter> <AbstractField> <code>
```


```
self.reqScannerSubscription(7002, scannerSubscription, [], filterTagvalues)
```


```
client.reqScannerSubscription(7002, scannerSubscription, null, FilterTagValues);
```


```
m_pClient->reqScannerSubscription(7002, scannerSubscription, TagValueListSPtr(), filterTagValues);
```


```
client.reqScannerSubscription(7002, scannerSubscription, null, filterTagValues);
```


```
client.reqScannerSubscription(7002, scannerSubscription, Nothing, filterTagValues)
```


```
def scannerData(self, reqId: int, rank: int, contractDetails: ContractDetails, distance: str, benchmark: str, projection: str, legsStr: str):
	print("ScannerData. ReqId:", reqId, ScanData(contractDetails.contract, rank, distance, benchmark, projection, legsStr))
```


```
@Override
public void scannerData(int reqId, int rank, ContractDetails contractDetails, String distance, String benchmark, String projection, String legsStr) {
	System.out.println("ScannerData: " + EWrapperMsgGenerator.scannerData(reqId, rank, contractDetails, distance, benchmark, projection, legsStr));
}
```


```
void TestCppClient::scannerData(int reqId, int rank, const ContractDetails& contractDetails, const std::string& distance, const std::string& benchmark, const std::string& projection, const std::string& legsStr) {
    printf( "ScannerData. %d - Rank: %d, Symbol: %s, SecType: %s, Currency: %s, Distance: %s, Benchmark: %s, Projection: %s, Legs String: %s\n", reqId, rank, contractDetails.contract.symbol.c_str(), contractDetails.contract.secType.c_str(), contractDetails.contract.currency.c_str(), distance.c_str(), benchmark.c_str(), projection.c_str(), legsStr.c_str());
}
```


```
public virtual void scannerData(int reqId, int rank, ContractDetails contractDetails, string distance, string benchmark, string projection, string legsStr)
{
	Console.WriteLine("ScannerData. "+reqId+" - Rank: "+rank+", Symbol: "+contractDetails.Contract.Symbol+", SecType: "+contractDetails.Contract.SecType+", Currency: "+contractDetails.Contract.Currency +", Distance: "+distance+", Benchmark: "+benchmark+", Projection: "+projection+", Legs String: "+legsStr);
}
```


```
Public Sub scannerData(reqId As Integer, rank As Integer, contractDetails As IBApi.ContractDetails, distance As String, benchmark As String, projection As String, legsStr As String) Implements IBApi.EWrapper.scannerData
	Console.WriteLine("ScannerData. " & reqId & " - Rank: " & rank & ", : " & contractDetails.Contract.Symbol & ", SecType: " &contractDetails.Contract.SecType & ", Currency: " & contractDetails.Contract.Currency & ", Distance: " & distance & ", Benchmark: " & benchmark & ", Projection: " & projection & ", Legs String: " & legsStr)
End Sub
```


```
self.cancelScannerSubscription(7003)
```


```
client.cancelScannerSubscription(7003);
```


```
m_pClient->cancelScannerSubscription(7002);
```


```
client.cancelScannerSubscription(7003);
```


```
client.cancelScannerSubscription(7003)
```


```
self.reqNewsProviders()
```


```
client.reqNewsProviders();
```


```
m_pClient->reqNewsProviders();
```


```
client.reqNewsProviders();
```


```
client.reqNewsProviders()
```


```
def newsProviders(self, newsProviders: ListOfNewsProviders):
	print("NewsProviders: ", newsProviders)
```


```
@Override
public void newsProviders(NewsProvider[] newsProviders) {
	System.out.print(EWrapperMsgGenerator.newsProviders(newsProviders));
}
```


```
void TestCppClient::newsProviders(const std::vector &newsProviders) {
    printf("News providers (%lu):\n", newsProviders.size());
    for (unsigned int i = 0; i < newsProviders.size(); i++) {
        printf("News provider [%d] - providerCode: %s providerName: %s\n", i, newsProviders[i].providerCode.c_str(), newsProviders[i].providerName.c_str());
    }
}
```


```
public void newsProviders(NewsProvider[] newsProviders)
{
	Console.WriteLine("News Providers:");
	foreach (var newsProvider in newsProviders)
	{
		Console.WriteLine("News provider: providerCode - {0}, providerName - {1}",
			newsProvider.ProviderCode, newsProvider.ProviderName);
	}
}
```


```
Public Sub newsProviders(newsProviders As NewsProvider()) Implements EWrapper.newsProviders
  Console.WriteLine("News Providers")
  For Each newsProvider In newsProviders
    Console.WriteLine("News Provider: providerCode - " & newsProvider.ProviderCode & ", providerName - " & newsProvider.ProviderName)
  Next
End Sub
```


```
self.reqMktData(reqId, contract, "mdoff,292:BRFG", False, False, [])
```


```
client.reqMktData(reqId, contract, "mdoff,292:BRFG", false, false, null);
```


```
m_pClient->reqMktData(reqId, contract, "mdoff,292:BRFG", false, false, TagValueListSPtr());
```


```
client.reqMktData(reqId, contract, "mdoff,292:BRFG", false, false, null);
```


```
client.reqMktData(reqId, contract, "mdoff,292:BRFG", False, False, Nothing)
```


```
contract = Contract()
contract.symbol  = "BRF:BRF_ALL"
contract.secType = "NEWS"
contract.exchange = "BRF"
```


```
Contract contract = new Contract();
contract.symbol("BRF:BRF_ALL");
contract.secType("NEWS");
contract.exchange("BRF");
```


```
Contract contract;
contract.symbol = "BRF:BRF_ALL"; 
contract.secType = "NEWS";
contract.exchange = "BRF";
```


```
Contract contract = new Contract();
contract.Symbol = "BRF:BRF_ALL";
contract.SecType = "NEWS";
contract.Exchange = "BRF";
```


```
Dim contract As Contract = New Contract()
contract.Symbol = "BRF:BRF_ALL"
contract.SecType = "NEWS"
contract.Exchange = "BRF"
```


```
self.reqMktData(reqId, contract, "mdoff,292", False, False, [])
```


```
client.reqMktData(reqId, contract, "mdoff,292", false, false, null);
```


```
m_pClient->reqMktData(reqId, contract, "mdoff,292", false, false, TagValueListSPtr());
```


```
client.reqMktData(reqId, contract, "mdoff,292", false, false, null);
```


```
client.reqMktData(reqId, contract, "mdoff,292", False, False, Nothing)
```


```
def tickNews(self, tickerId: int, timeStamp: int, providerCode: str, articleId: str, headline: str, extraData: str):
  print("TickNews. TickerId:", tickerId, "TimeStamp:", timeStamp, "ProviderCode:", providerCode, "ArticleId:", articleId, "Headline:", headline, "ExtraData:", extraData)
```


```
@Override
public void tickNews(int tickerId, long timeStamp, String providerCode, String articleId, String headline, String extraData) {
	System.out.println(EWrapperMsgGenerator.tickNews(tickerId, timeStamp, providerCode, articleId, headline, extraData));
}
```


```
void TestCppClient::tickNews(int tickerId, time_t timeStamp, const std::string& providerCode, const std::string& articleId, const std::string& headline, const std::string& extraData) {
    printf("News Tick. TickerId: %d, TimeStamp: %s, ProviderCode: %s, ArticleId: %s, Headline: %s, ExtraData: %s\n", tickerId, ctime(&(timeStamp /= 1000)), providerCode.c_str(), articleId.c_str(), headline.c_str(), extraData.c_str());
}
```


```
public void tickNews(int tickerId, long timeStamp, string providerCode, string articleId, string headline, string extraData)
{
	Console.WriteLine("Tick News. Ticker Id: {0}, Time Stamp: {1}, Provider Code: {2}, Article Id: {3}, headline: {4}, extraData: {5}", tickerId, Util.LongMaxString(timeStamp), providerCode, articleId, headline, extraData);
}
```


```
Public Sub tickNews(tickerId As Integer, timeStamp As Long, providerCode As String, articleId As String, headline As String, extraData As String) Implements IBApi.EWrapper.tickNews
	Console.WriteLine("Tick News. Ticker Id: " & tickerId & ", Time Stamp: " & Util.LongMaxString(timeStamp) & ", Provider Code: " & providerCode & ", Article Id: " & articleId & ", Headline: " & headline & ", Extra Data: " & extraData)
End Sub
```


```
self.reqHistoricalNews(reqId, 8314, "BRFG", "", "", 10, [])
```


```
client.reqHistoricalNews(reqId, 8314, "BZ+FLY", "", "", 10, null);
```


```
TagValueList* list = new TagValueList();
list->push_back((TagValueSPtr)new TagValue("manual", "1"));
m_pClient->reqHistoricalNews(reqId, 8314, "BZ+FLY", "", "", 5, TagValueListSPtr(list));
```


```
client.reqHistoricalNews(reqId, 8314, "BZ+FLY", "", "", 10, null);
```


```
client.reqHistoricalNews(reqId, 8314, "BZ+FLY", "", "", 10, Nothing)
```


```
def historicalNews(self, requestId: int, time: int, providerCode: str, articleId: str, headline: str):
  print("historicalNews. RequestId:", requestId, "Time:", time, "ProviderCode:", providerCode, "ArticleId:", articleId, "Headline:", headline)
```


```
@Override
public void historicalNews(int requestId, long time, String providerCode, String articleId, String headline) {
	System.out.println( EWrapperMsgGenerator.historicalNews( requestId, time, providerCode, articleId, headline));
}
```


```
void TestCppClient::historicalNews(int requestId, time_t time, const std::string& providerCode, const std::string& articleId, const std::string& headline) {
    printf("historicalNews. RequestId: %d, Time: %s, ProviderCode: %s, ArticleId: %s, Headline: %s\n", requestId, ctime(&(time /= 1000)), providerCode.c_str(), articleId.c_str(), headline.c_str());
}
```


```
public void historicalNews(int requestId, long time, string providerCode, string articleId, string headline)
{
	Console.WriteLine("historicalNews. RequestId: {0}, Time Stamp: {1}, Provider Code: {2}, Article Id: {3}, headline: {4}, extraData: {5}", requestId, Util.LongMaxString(time), providerCode, articleId, headline);
}
```


```
Public Sub historicalNews(requestId As Integer, time As Long, providerCode As String, articleId As String, headline As String) Implements IBApi.EWrapper.tickNews
	Console.WriteLine("Tick News. Ticker Id: " & tickerId & ", Time: " & Util.LongMaxString(time) & ", Provider Code: " & providerCode & ", Article Id: " & articleId & ", Headline: " & headline)
End Sub
```


```
def historicalDataEnd(self, reqId: int, hasMore: bool):
    print("historicalDataEnd. ReqId:", reqId, "Has More:", hasMore)
```


```
@Override
public void historicalDataEnd(int reqId, bool hasMore) {
    System.out.println("historicalDataEnd. Req Id: " + EWrapperMsgGenerator.historicalDataEnd(reqId, hasMore));
}
```


```
void TestCppClient::historicalDataEnd( int reqId, bool hasMore) {
    printf( "historicalDataEnd. Req Id: %d\n", reqId);
}
```


```
public virtual void historicalDataEnd(int reqId, bool hasMore)
{
    Console.WriteLine("historicalDataEnd. Req Id: "+reqId+"\n");
}
```


```
Public Sub historicalDataEnd(reqId As Integer, hasMore as Boolean) Implements IBApi.EWrapper.historicalDataEnd
    Console.WriteLine("historicalDataEnd - ReqId [" & reqId & "]")
End Sub
```


```
self.reqNewsArticle(10002,"BRFG", "BRFG$04fb9da2", [])
```


```
client.reqNewsArticle(10002, "BZ", "BZ$04507322", null);
```


```
TagValueList* list = new TagValueList();
m_pClient->reqNewsArticle(12001, "MST", "MST$06f53098", TagValueListSPtr(list));
```


```
client.reqNewsArticle(12002, "BZ", "BZ$04507322", null);
```


```
client.reqNewsArticle(10002, "BZ", "BZ$04507322", Nothing)
```


```
def newsArticle(self, requestId: int, articleType: int, articleText: str):
  print("requestId: ", requestId, "articleType: ", articleType, "articleText: ", articleText)
```


```
@Override
public void newsArticle(int requestId, int articleType, str articleText) {
  System.out.print(EWrapperMsgGenerator.newsArticle(requestId, articleType, articleText));
}
```


```
void TestCppClient::newsArticle(int requestId, int articleType, const std::string& articleText) {
    printf("newsArticle.", requestId, articleType, articleText);
}
```


```
public void newsArticle(int requestId, int articleType, string articleText)
{
  Console.WriteLine("newsArticle. Request Id: {0}, Article Type: {1}, Article Text: {2}", requestId, articleType, articleText);
}
```


```
Public Sub newsArticle(requestId As Integer, articleType As Integer, articleText As String) Implements IBApi.EWrapper.newsArticle
  Console.WriteLine("newsArticle. Request Id: " & requestId & ", Article Type: " & articleType & ", Article Text: " & articleText)
End Sub
```


```
self.reqIds(-1)
```


```
client.reqIds(-1);
```


```
m_pClient->reqIds(-1);
```


```
client.reqIds(-1);
```


```
client.reqIds(-1)
```


```
def nextValidId(self, orderId: int):
    print("NextValidId:", orderId)
```


```
@Override
public void nextValidId(int orderId) {
	System.out.println(EWrapperMsgGenerator.nextValidId(orderId));
	currentOrderId = orderId;
}
```


```
void TestCppClient::nextValidId( OrderId orderId)
{
    printf("Next Valid Id: %ld\n", orderId);
    m_orderId = orderId;
}
```


```
public virtual void nextValidId(int orderId) 
{
	Console.WriteLine("Next Valid Id: "+orderId);
	NextOrderId = orderId;
}
```


```
Public Sub nextValidId(orderId As Integer) Implements IBApi.EWrapper.nextValidId
	Console.WriteLine("NextValidId - OrderId [" & orderId & "]")
	nextOrderId = orderId
End Sub
```


```
def commissionAndFeesReport(self, commissionAndFeesReport: CommissionAndFeesReport):
    print("CommissionReport.", commissionAndFeesReport)
```


```
@Override
public void commissionAndFeesReport(CommissionAndFeesReport commissionAndFeesReport) {
     System.out.println(EWrapperMsgGenerator.commissionAndFeesReport(commissionAndFeesReport));
}
```


```
void TestCppClient::commissionAndFeesReport( const CommissionAndFeesReport& commissionAndFeesReport) {
    printf( "CommissionAndFeesReport. %s - %s %s RPNL %s\n", commissionAndFeesReport.execId.c_str(), Utils::doubleMaxString(commissionAndFeesReport.commission).c_str(), commissionAndFeesReport.currency.c_str(), Utils::doubleMaxString(commissionAndFeesReport.realizedPNL).c_str());
}
```


```
public virtual void commissionAndFeesReport(CommissionAndFeesReport commissionAndFeesReport)
{
  Console.WriteLine("CommissionAndFeesReport. " + commissionAndFeesReport.ExecId + " - " + Util.DoubleMaxString(commissionAndFeesReport.Commission) + " " + commissionAndFeesReport.Currency + " RPNL " + Util.DoubleMaxString(commissionAndFeesReport.RealizedPNL));
}
```


```
Public Sub commissionAndFeesReport(commissionAndFeesReportAs IBApi.CommissionAndFeesReport) Implements IBApi.EWrapper.commissionAndFeesReport
  Console.WriteLine("CommissionAndFeesReport - CommissionAndFeesReport[" & Util.DoubleMaxString(commissionAndFeesReport.Commission) & " " & commissionAndFeesReport.Currency & "]")
End Sub
```


```
self.reqExecutions(10001, ExecutionFilter())
```


```
client.reqExecutions(10001, new ExecutionFilter());
```


```
m_pClient->reqExecutions(10001, ExecutionFilter());
```


```
client.reqExecutions(10001, new ExecutionFilter());
```


```
client.reqExecutions(10001, New ExecutionFilter())
```


```
def execDetails(self, reqId: int, contract: Contract, execution: Execution):
  print("ExecDetails. ReqId:", reqId, "Symbol:", contract.symbol, "SecType:", contract.secType, "Currency:", contract.currency, execution)
```


```
@Override
public void execDetails(int reqId, Contract contract, Execution execution) {
	System.out.println(EWrapperMsgGenerator.execDetails( reqId, contract, execution));
}
```


```
void TestCppClient::execDetails( int reqId, const Contract& contract, const Execution& execution) {
    printf( "ExecDetails. ReqId: %d - %s, %s, %s - %s, %s, %s, %s, %s\n", reqId, contract.symbol.c_str(), contract.secType.c_str(), contract.currency.c_str(), execution.execId.c_str(), Utils::longMaxString(execution.orderId).c_str(), decimalStringToDisplay(execution.shares).c_str(), decimalStringToDisplay(execution.cumQty).c_str(), Utils::intMaxString(execution.lastLiquidity).c_str());
}
```


```
public virtual void execDetails(int reqId, Contract contract, Execution execution)
{
	Console.WriteLine("ExecDetails. " + reqId + " - " + contract.Symbol + ", " + contract.SecType+", " + contract.Currency+" - " + execution.ExecId + ", " + Util.IntMaxString(execution.OrderId) + 
		", " + Util.DecimalMaxString(execution.Shares) + ", " + Util.DecimalMaxString(execution.CumQty) + ", " + execution.LastLiquidity);
}
```


```
Public Sub execDetails(reqId As Integer, contract As IBApi.Contract, execution As IBApi.Execution) Implements IBApi.EWrapper.execDetails
  Console.WriteLine("ExecDetails - ReqId [" & reqId & "] Contract [" & contract.Symbol & ", " & contract.SecType &
          "] Execution [Price: " & Util.DoubleMaxString(execution.Price) & ", Exchange: " & execution.Exchange & ", Last Liquidity: " & execution.LastLiquidity.ToString() & ", Shares: " & Util.DecimalMaxString(execution.Shares) & ", Cum Qty: " & Util.DecimalMaxString(execution.CumQty) & "]")
End Sub
```


```
def execDetailsEnd(self, reqId: int):
	print("ExecDetailsEnd. ReqId:", reqId)
```


```
@Override
public void execDetailsEnd(int reqId) {
	System.out.println("Exec Details End: " + EWrapperMsgGenerator.execDetailsEnd( reqId));
}
```


```
void TestCppClient::execDetailsEnd( int reqId) {
    printf( "ExecDetailsEnd. %d\n", reqId);
}
```


```
public virtual void execDetailsEnd(int reqId)
{
	Console.WriteLine("ExecDetailsEnd. "+reqId+"\n");
}
```


```
Public Sub execDetailsEnd(reqId As Integer) Implements IBApi.EWrapper.execDetailsEnd
	Console.WriteLine("ExecDetailsEnd - ReqId [" & reqId & "]")
End Sub
```


```
def openOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
    print(orderId, contract, order, orderState)
```


```
@Override
public void openOrder(int orderId, Contract contract, Order order, OrderState orderState) {
	System.out.println(EWrapperMsgGenerator.openOrder(orderId, contract, order, orderState));
}
```


```
void TestCppClient::openOrder( OrderId orderId, const Contract& contract, const Order& order, const OrderState& orderState) {
    printf(orderId, contract, order, orderState);
}
```


```
public virtual void openOrder(int orderId, Contract contract, Order order, OrderState orderState)
{
	Console.WriteLine(orderId, contract, order, orderState);
}
```


```
Public Sub openOrder(orderId As Integer, contract As IBApi.Contract, order As IBApi.Order, orderState As IBApi.OrderState) Implements IBApi.EWrapper.openOrder
	Console.WriteLine(orderId, contract, order , orderState)
End Sub
```


```
def openOrderEnd(self):
	print("OpenOrderEnd")
```


```
@Override
public void openOrderEnd() {
	System.out.println("Open Order End: " + EWrapperMsgGenerator.openOrderEnd());
}
```


```
void TestCppClient::openOrderEnd() {
    printf( "OpenOrderEnd\n");
}
```


```
public virtual void openOrderEnd()
{
	Console.WriteLine("OpenOrderEnd");
}
```


```
Public Sub openOrderEnd() Implements IBApi.EWrapper.openOrderEnd
	Console.WriteLine("OpenOrderEnd")
End Sub
```


```
def orderStatus(self, orderId: OrderId, status: str, filled: Decimal, remaining: Decimal, avgFillPrice: float, permId: int, parentId: int, lastFillPrice: float, clientId: int, whyHeld: str, mktCapPrice: float):
	super().orderStatus(orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld, mktCapPrice)
```


```
@Override
public void orderStatus(int orderId, String status, Decimal filled, Decimal remaining, double avgFillPrice, int permId, int parentId, double lastFillPrice, int clientId, String whyHeld, double mktCapPrice) {
	System.out.println(EWrapperMsgGenerator.orderStatus( orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld, mktCapPrice));
}
```


```
void TestCppClient::orderStatus(OrderId orderId, const std::string& status, Decimal filled, Decimal remaining, double avgFillPrice, int permId, int parentId, double lastFillPrice, int clientId, const std::string& whyHeld, double mktCapPrice){
    printf(orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld, mktCapPrice);
}
```


```
public virtual void orderStatus(int orderId, string status, decimal filled, decimal remaining, double avgFillPrice, int permId, int parentId, double lastFillPrice, int clientId, string whyHeld, double mktCapPrice)
{
	Console.WriteLine("OrderStatus. Id: " + orderId + ", Status: " + status + ", Filled: " + Util.DecimalMaxString(filled) + ", Remaining: " + Util.DecimalMaxString(remaining)
		+ ", AvgFillPrice: " + Util.DoubleMaxString(orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld, mktCapPrice);
}
```


```
Public Sub orderStatus(orderId As Integer, status As String, filled As Decimal, remaining As Decimal, avgFillPrice As Double, permId As Integer, parentId As Integer, lastFillPrice As Double, clientId As Integer, whyHeld As String, mktCapPrice As Double) Implements IBApi.EWrapper.orderStatus
	Console.WriteLine(orderId , status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld, mktCapPrice)
End Sub
```


```
self.reqOpenOrders()
```


```
client.reqOpenOrders();
```


```
m_pClient->reqOpenOrders();
```


```
client.reqOpenOrders();
```


```
client.reqOpenOrders()
```


```
self.reqAllOpenOrders()
```


```
client.reqAllOpenOrders();
```


```
m_pClient->reqAllOpenOrders();
```


```
client.reqAllOpenOrders();
```


```
client.reqAllOpenOrders()
```


```
self.reqAutoOpenOrders(True)
```


```
client.reqAutoOpenOrders(true);
```


```
m_pClient->reqAutoOpenOrders(true);
```


```
client.reqAutoOpenOrders(true);
```


```
client.reqAutoOpenOrders(True)
```


```
def orderBound(self, orderId: int, apiClientId: int, apiOrderId: int):
	print("OrderBound.", "OrderId:", intMaxString(orderId), "ApiClientId:", intMaxString(apiClientId), "ApiOrderId:", intMaxString(apiOrderId))
```


```
@Override
public void orderBound(long orderId, int apiClientId, int apiOrderId) {
	System.out.println(EWrapperMsgGenerator.orderBound(orderId, apiClientId, apiOrderId));
}
```


```
void TestCppClient::orderBound(long long orderId, int apiClientId, int apiOrderId) {
    printf("Order bound. OrderId: %s, ApiClientId: %s, ApiOrderId: %s\n", Utils::llongMaxString(orderId).c_str(), Utils::intMaxString(apiClientId).c_str(), Utils::intMaxString(apiOrderId).c_str());
}
```


```
public void orderBound(long orderId, int apiClientId, int apiOrderId)
{
	Console.WriteLine("Order bound. Order Id: {0}, Api Client Id: {1}, Api Order Id: {2}", Util.LongMaxString(orderId), Util.IntMaxString(apiClientId), Util.IntMaxString(apiOrderId));
}
```


```
Public Sub orderBound(orderId As Long, apiClientId As Integer, apiOrderId As Integer) Implements EWrapper.orderBound
	Console.WriteLine("Order bound. Order Id: {0}, Api Client Id: {1}, Api Order Id: {2}", Util.LongMaxString(orderId), Util.IntMaxString(apiClientId), Util.IntMaxString(apiOrderId))
End Sub
```


```
self.reqCompletedOrders(True)
```


```
client.reqCompletedOrders(True)
```


```
m_pClient->reqCompletedOrders(true)
```


```
client.reqCompletedOrders(true)
```


```
client.reqCompletedOrders(True)
```


```
def completedOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
    print(orderId, contract, order, orderState)
```


```
@Override
public void completedOrder(int orderId, Contract contract, Order order, OrderState orderState) {
  System.out.println(EWrapperMsgGenerator.openOrder(orderId, contract, order, orderState));
}
```


```
void TestCppClient::completedOrder( OrderId orderId, const Contract& contract, const Order& order, const OrderState& orderState) {
    printf(orderId, contract, order, orderState);
}
```


```
public virtual void completedOrder(int orderId, Contract contract, Order order, OrderState orderState)
{
  Console.WriteLine(orderId, contract, order, orderState);
}
```


```
Public Sub completedOrder(orderId As Integer, contract As IBApi.Contract, order As IBApi.Order, orderState As IBApi.OrderState) Implements IBApi.EWrapper.openOrder
  Console.WriteLine(orderId, contract, order , orderState)
End Sub
```


```
self.cancelOrder(orderId, OrderCancel())
```


```
client.cancelOrder(cancelID, new OrderCancel());
```


```
m_pClient->cancelOrder(m_orderId-1, OrderCancel());
```


```
client.cancelOrder(nextOrderId - 1, OrderCancel());
```


```
client.cancelOrder(nextOrderId - 1, OrderCancel)
```


```
self.reqGlobalCancel(OrderCancel())
```


```
client.reqGlobalCancel(new OrderCancel());
```


```
m_pClient->reqGlobalCancel(OrderCancel());
```


```
client.reqGlobalCancel(OrderCancel());
```


```
client.reqGlobalCancel()
```


```
self.exerciseOptions(5003, contract, 1, 1, self.account, 1, "")
```


```
client.exerciseOptions(5003, contract, 1, 1, "", 1, "");
```


```
m_pClient->exerciseOptions(5003, contract, 1, 1, "", 1, "");
```


```
client.exerciseOptions(5003, contract, 1, 1, null, 1, null);
```


```
client.exerciseOptions(5003, contract, 1, 1, Nothing, 1, Nothing)
```


```
self.reqMarketRule(26)
```


```
client.reqMarketRule(26);
```


```
m_pClient->reqMarketRule(26);
```


```
client.reqMarketRule(26);
```


```
client.reqMarketRule(26)
```


```
def marketRule(self, marketRuleId: int, priceIncrements: ListOfPriceIncrements):
	print("Market Rule ID: ", marketRuleId)
	for priceIncrement in priceIncrements:
	print("Price Increment.", priceIncrement)
```


```
@Override
public void marketRule(int marketRuleId, PriceIncrement[] priceIncrements) {
	System.out.println(EWrapperMsgGenerator.marketRule(marketRuleId, priceIncrements));
}
```


```
void TestCppClient::marketRule(int marketRuleId, const std::vector &priceIncrements) {
    printf("Market Rule Id: %s\n", Utils::intMaxString(marketRuleId).c_str());
    for (unsigned int i = 0; i < priceIncrements.size(); i++) {
        printf("Low Edge: %s, Increment: %s\n", Utils::doubleMaxString(priceIncrements[i].lowEdge).c_str(), Utils::doubleMaxString(priceIncrements[i].increment).c_str());
    }
}
```


```
public void marketRule(int marketRuleId, PriceIncrement[] priceIncrements) 
{
	Console.WriteLine("Market Rule Id: " + marketRuleId);
	foreach (var priceIncrement in priceIncrements) 
	{
		Console.WriteLine("Low Edge: {0}, Increment: {1}", Util.DoubleMaxString(priceIncrement.LowEdge), Util.DoubleMaxString(priceIncrement.Increment));
	}
}
```


```
Public Sub marketRule(marketRuleId As Integer, priceIncrements As PriceIncrement()) Implements EWrapper.marketRule
	Console.WriteLine("Market Rule Id:" & marketRuleId)
	For Each priceIncrement In priceIncrements
		Console.WriteLine("LowEdge: " & Util.DoubleMaxString(priceIncrement.LowEdge) & " Increment: " & Util.DoubleMaxString(priceIncrement.Increment))
	Next
End Sub
```


```
self.placeOrder(orderId, contract, order)
```


```
client.placeOrder(nextOrderId++, contract, order);
```


```
m_pClient->placeOrder(m_orderId++, 
 contract, order);
```


```
client.placeOrder(orderId, contract, order);
```


```
client.placeOrder(orderId, contract, order)
```


```
contract = Contract()
contract.symbol = symbol
contract.secType = "SBL"
contract.exchange = "PREBORROW"
contract.currency = "USD"

order = Order()
order.action = "BUY"
order.orderType = "MKT"
order.totalQuantity = quantity
```


```
Contract contract = new Contract();
contract.symbol(symbol);
contract.secType("SBL");
contract.currency("USD");
contract.exchange("PREBORROW");

Order order = new Order();
order.orderType("MKT");
order.totalQuantity(quantity);
```


```
Contract contract;
contract.symbol = symbol;
contract.secType = "SBL";
contract.currency = "USD";
contract.exchange = "PREBORROW";

Order order;
order.orderType = "MKT";
order.totalQuantity = quantity;
```


```
Contract contract = new Contract();
contract.Symbol = symbol;
contract.SecType = "SBL";
contract.Currency = "USD";
contract.Exchange = "PREBORROW";

Order order = new Order();
order.Action = action;
order.OrderType = "MKT";
order.TotalQuantity = quantity;
```


```
def openOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
    print(orderId, contract, order, orderState.initMarginChange) 

.
.
.
order.whatIf = True
.
.
.
self.placeOrder(order_id, contract, order)
```


```
210 152791428,700,STK,,0,?,,SEHK,,HKD,700,700,False,,,,combo: 210,1,1832692965: MKT BUY 100@0 DAY 12567.5
```


```
self.queryDisplayGroups(requestId)
```


```
client.queryDisplayGroups(requestId);
```


```
m_pClient->queryDisplayGroups(requestId);
```


```
client.queryDisplayGroups(requestId);
```


```
client.queryDisplayGroups(requestId)
```


```
def displayGroupList(self, reqId: int, groups: str):
  print("DisplayGroupList. ReqId:", reqId, "Groups", groups)
```


```
@Override
public void displayGroupList(int reqId, String groups) {
  System.out.println("Display Group List. ReqId: " + reqId + ", Groups: " + groups + "\n");
}
```


```
void TestCppClient::displayGroupList( int reqId, const std::string& groups) {
  printf("Display Group List. ReqId: %d, Groups: %s\n", reqId, groups.c_str());
}
```


```
public virtual void displayGroupList(int reqId, string groups)
{
  Console.WriteLine("DisplayGroupList. Request: " + reqId + ", Groups" + groups);
}
```


```
Public Sub displayGroupList(reqId As Integer, groups As String) Implements IBApi.EWrapper.displayGroupList
  Console.WriteLine("DisplayGroupList - ReqId [" & reqId & "] Groups [" & groups & "]")
End Sub
```


```
self.subscribeToGroupEvents(19002, 1)
```


```
client.subscribeToGroupEvents(9002, 1);
```


```
m_pClient->subscribeToGroupEvents(9002, 1);
```


```
client.subscribeToGroupEvents(9002, 1);
```


```
client.subscribeToGroupEvents(9002, 1)
```


```
def displayGroupUpdated(self, reqId: int, contractInfo: str):
	print("DisplayGroupUpdated. ReqId:", reqId, "ContractInfo:", contractInfo)
```


```
@Override
public void displayGroupUpdated(int reqId, String contractInfo) {
	System.out.println("Display Group Updated. ReqId: " + reqId + ", Contract info: " + contractInfo + "\n");
}
```


```
void TestCppClient::displayGroupUpdated( int reqId, const std::string& contractInfo) {
    std::cout << "Display Group Updated. ReqId: " << reqId << ", Contract Info: " << contractInfo << std::endl;
}
```


```
public virtual void displayGroupUpdated(int reqId, string contractInfo)
{
	Console.WriteLine("displayGroupUpdated. Request: " + reqId + ", ContractInfo: " + contractInfo);
}
```


```
Public Sub displayGroupUpdated(reqId As Integer, contractInfo As String) Implements IBApi.EWrapper.displayGroupUpdated
	Console.WriteLine("DisplayGroupUpdated - ReqId [" & reqId & "] ContractInfo [" & contractInfo & "]")
End Sub
```


```
self.unsubscribeFromGroupEvents(19002)
```


```
client.unsubscribeFromGroupEvents(9002);
```


```
m_pClient->unsubscribeFromGroupEvents(9002);
```


```
client.unsubscribeFromGroupEvents(9002);
```


```
client.unsubscribeFromGroupEvents(9002)
```


```
self.updateDisplayGroup(19002, "8314@SMART")
```


```
client.updateDisplayGroup(9002, "8314@SMART");
```


```
m_pClient->updateDisplayGroup(9002, "8314@SMART");
```


```
client.updateDisplayGroup(9002, "8314@SMART");
```


```
client.updateDisplayGroup(9002, "8314@SMART")
```


```
self.reqWshMetaData(1100)
```


```
client.reqWshMetaData(1100);
```


```
m_pClient->reqWshMetaData(30001);
```


```
client.reqWshMetaData(1100);
```


```
client.reqWshMetaData(1100)
```


```
def wshMetaData(self, reqId: int, dataJson: str):
	print("WshMetaData.", "ReqId:", reqId, "Data JSON:", dataJson)
```


```
@Override
public void wshMetaData(int reqId, String dataJson) {
	System.out.println(EWrapperMsgGenerator.wshMetaData(reqId, dataJson));
}
```


```
void TestCppClient::wshMetaData(int reqId, const std::string& dataJson) {
    printf("WSH Meta Data. ReqId: %d, dataJson: %s\n", reqId, dataJson.c_str());
}
```


```
public void wshMetaData(int reqId, string dataJson)
{
	Console.WriteLine($"WSH Meta Data. Request Id: {reqId}, Data JSON: {dataJson}\n");
}
```


```
Public Sub wshMetaData(reqId As Integer, dataJson As String) Implements EWrapper.wshMetaData
	Console.WriteLine($"WSH Meta Data. Request Id: {reqId}, Data JSON: {dataJson}")
End Sub
```


```
self.cancelWshMetaData(1100)
```


```
client.cancelWshMetaData(1100);
```


```
m_pClient->cancelWshMetaData(30001);
```


```
client.cancelWshMetaData(1100);
```


```
client.cancelWshMetaData(1100)
```


```
self.reqWshEventData(1101, eventDataObj, serverVersion)
```


```
client.reqWshEventData(1101, eventDataObj, serverVersion);
```


```
m_pClient->reqWshEventData(30002, eventDataObj, serverVersion);
```


```
client.reqWshEventData(1101, eventDataObj, serverVersion);
```


```
client.reqWshEventData(1101, eventDataobj, serverVersion)
```


```
def wshEventData(self, reqId: int, dataJson: str):
	print("WshEventData.", "ReqId:", reqId, "Data JSON:", dataJson)
```


```
@Override
public void wshEventData(int reqId, String dataJson) {
	System.out.println(EWrapperMsgGenerator.wshEventData(reqId, dataJson));
}
```


```
void TestCppClient::wshEventData(int reqId, const std::string& dataJson) {
    printf("WSH Event Data. ReqId: %d, dataJson: %s\n", reqId, dataJson.c_str());
}
```


```
public void wshEventData(int reqId, string dataJson)
{
	Console.WriteLine($"WSH Event Data. Request Id: {reqId}, Data JSON: {dataJson}\n");
}
```


```
Public Sub wshEventData(reqId As Integer, dataJson As String) Implements EWrapper.wshEventData
	Console.WriteLine($"WSH Event Data. Request Id: {reqId}, Data JSON: {dataJson}")
End Sub
```


```
self.cancelWshEventData(1101, eventDataObj)
```


```
client.cancelWshEventData(1101, eventDataObj);
```


```
m_pClient->cancelWshEventData(30002, eventDataObj);
```


```
client.cancelWshEventData(1101, eventDataObj);
```


```
client.cancelWshEventData(1101, eventDataobj)
```
